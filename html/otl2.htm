<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 25 March 2009), see www.w3.org">

  <title>Table of Contents</title>
</head>

<body>
  <h1>One-Page Oracle API, Oracle Call Interface Template Library (OTL), Version 2.0.0</h1>

  <p><i>Sergei Kuchin, email: <a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>, <a href="mailto:skuchin@gmail.com">skuchin@gmail.com</a></i></p>
  <pre>
Copyright (C) Sergei Kuchin, 1996, 1997, 1998
Permission to use, copy, modify and redistribute this
document for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all
copies.
</pre>

  <h1><a href="mailto:skuchin@gmail.com">Table of Contents</a></h1>

  <ul>
    <li><a href="#sec1">1. Introduction</a></li>

    <li><a href="#sec11">1.1. SQL streams</a></li>

    <li>
      <a href="#sec2">2. <i>One-page</i> Oracle API</a>

      <ul>
        <li><a href="#sec21">2.1. Connect object</a></li>

        <li>
          <a href="#sec22">2.2. otl_stream class</a>

          <ul>
            <li><a href="#sec221">2.2.1. Stream bind variables declaration</a></li>
          </ul>
        </li>

        <li><a href="#sec23">2.3. Exception handling</a></li>

        <li><a href="#sec24">2.4. Constant SQL statement or PL/SQL block</a></li>

        <li><a href="#sec25">2.5. Examples</a></li>
      </ul>
    </li>

    <li>
      <a href="#sec3">3. STL-compliant iterators for otl_stream</a>

      <ul>
        <li><a href="#sec31">3.1. Example</a></li>
      </ul>
    </li>

    <li><a href="#app_a">Appendix A. How to download the source code</a></li>

    <li><a href="#app_b">Appendix B. OTL exception list</a></li>
  </ul>

  <h1><a name="sec1" id="sec1">1. Introduction</a></h1>

  <p><a name="sec1" id="sec1">This document describes the Oracle Call Interface Template Library, Version 2.0.0 (OTL). The library introduces a <i>one-page</i> Oracle API in the form of</a> <a href="#sec11">SQL streams</a>.</p>

  <p>OTL is a new kind of C++ libraries, similar to the <a href="http://www.sgi.com/Technology/STL/">Standard Template Library</a>. This kind of libraries is easy to use, since the user needs only to include C++ header files which contain template classes and inline functions. There is no need to link additional object modules into C++ applications. The code instantiated from template classes and inline functions is efficient and reliable in terms of runtime performance and C++ strict type checking.</p>

  <p>OTL automatically uses Oracle Array Interface (<a href="#sec11">SQL streams</a> are buffered by definition) and has a higher runtime performance than Pro*C because there is no overhead on caching cursors and filling out the SQLCA global structure before every single SQL statement embedded into the program. Runtime performance can be improved even further by increasing the stream buffer size.</p>

  <p>OTL provides an exception handling mechanism in the format of the <a href="#sec23">otl_exception</a> class. This mechanism takes advantage of C++ exception handling compared to coding database applications in plain C. The user does not need to check out return codes after each function call. The code, instantiated from the OTL templates and inline functions is much nicer and cleaner in comparison with the code generated by the Pro*C precompiler.</p>

  <p>Also, OTL integrates with the <a href="http://www.sgi.com/Technology/STL/">Standard Template Library</a> by means of <a href="#sec3">STL-compliant iterator classes</a>. This feature is very powerful because it allows to combine the power of <a href="http://www.metabyte.com/%7Efbp/stl/readings.html">generic programming</a> and Oracle database backend into compact, reliable, top performance and easy-to-maintain C++ database applications.</p>

  <p>This version of OTL is available for both Oracle 7.x and Oracle 8.x. Both implemetations use native OCIs:</p>

  <ul>
    <li>OTL for Oracle 7 uses native OCI7</li>

    <li>OTL for Oracle 8 uses native OCI8</li>
  </ul>

  <p>It provides smooth transition from Oracle 7 to Oracle 8 with no changes to the custom source code. Besides, OTL compiles by many C++ compilers on major brands of Unix as well as Windows NT and Windows 95/98.</p>

  <p>The fact that OTL is available in source code adds more value to this material -- folks new to OCI can use the OTL source code to learn both OCI7 and OCI8 . Moreover, OTL can be used a guidance for migrating programs from native OCI7 to native OCI8.</p>

  <h2><a name="sec11" id="sec11">1.1. SQL stream classes</a></h2>

  <p><a name="sec11" id="sec11">OTL introduces the concept of SQL streams. The idea here is to combine streams and SQL. Any SQL statement or PL/SQL block can be treated as a functional element with input/output parameters. There are functions to put objects into a stream, that is, to assign values to input variables of the SQL statement. Also, there are functions to get objects from the stream, that is, to get values from output variables of the SQL statement.</a></p>

  <center>
    <a name="sec11" id="sec11"><img src="otl.gif"></a>
  </center>

  <p><a name="sec11" id="sec11">When values of all input variables of the functional element are filled out then the element is executed. Resulting values are assigned to the output variables right after the execution. Sets of input and output variables are allowed to overlap.</a></p>

  <p><a name="sec11" id="sec11">Logically, a SQL stream is a structured stream with input and output rows. The format of the input row is defined by a set of output variables of the stream. Similarly, the output row is defined by input variables of the stream. When objects are written into the stream, values are actually assigned to the input variables. Likewise, when objects are read from the stream, values are read from the output variables of the stream.</a></p>

  <p><a name="sec11" id="sec11">SQL streams are similar to buffered files. A SQL statement or PL/SQL block is opened as an ordinary buffered file. The logic of the SQL stream operations remains the same as the file operations with the only exception -- the SQL stream has separate input and output buffers which may overlap.</a></p>

  <p><a name="sec11" id="sec11">The SQL stream has a flush function for flushing its input buffer when the buffer gets full and a collection of &gt;&gt; and &lt;&lt; operators for reading and writing object of different data types. The most important advantage of the SQL streams is their unified interface to SQL statements and PL/ SQL blocks of any kind. This means that the application developer needs to remember just a few syntactical constructs and function names which he already got familiar with when he started working with C++ streams.</a></p>

  <p><a name="sec11" id="sec11">Inside the SQL stream there is a small parser for parsing</a> <a href="#sec221">declarations of bind variables</a> and their data types. There is no need to declare C/C++ host variables and bind them with placeholders by special bind function calls. All necessary buffers are created dynamically inside the stream. The stream just needs to be opened for reading input values and writing output values.</p>

  <p>The OTL stream interface requires use of the OTL exceptions. This means that potentially any OTL stream operation can throw an exception of the <a href="#sec23">otl_exception</a> type. In order to intercept the exception and prevent the program from aborting, wrap up the OTL stream code with the corresponding try &amp; catch block.</p>

  <h1><a name="sec2" id="sec2">2. <i>One-page</i> Oracle API</a></h1>

  <h2><a name="sec21" id="sec21">2.1. Connect object</a></h2>

  <p><a name="sec21" id="sec21">This class encapsulates the Oracle Call Interface <i>connect</i> functions: connect, commit, roll back, etc. In other words, otl_connect is the class for creating "connect" objects.</a></p><a name="ref002" id="ref002"></a>
  <pre>
class otl_connect{
public:
</pre>

  <ul>
    <li>Constants to initialize OCI. oci_threaded is needed in case of multithreaded program. oci_default is the default mode.
      <pre>
enum {oci_default,oci_threaded};
   
</pre>
    </li>

    <li>
      <a name="ref006" id="ref006"></a>Initialize OCI program. This function needs to be called only once before connecting to the database for the first time. The function is static in class.
      <pre>
static void otl_initialize(const int mode=oci_default);
   
</pre>
    </li>

    <li>Create "connect" object.
      <pre>
otl_connect();
   
</pre>
    </li>

    <li>Create "connect" object and connect to Oracle using the "connect_str" connect string.
      <pre>
otl_connect(const char* connect_str);
   
</pre>
    </li>

    <li>Destructor
      <pre>
~otl_connect();
   
</pre>
    </li>

    <li>
      <a name="ref007" id="ref007"></a>Concurrent logon; OCI application is allowed to have more than one concurrent logon. Returns 1 on success, 0 on failure.
      <pre>
int rlogon(const char* connect_str);
   
</pre>
    </li>

    <li>
      <a name="ref009" id="ref009"></a>Disconnect from / log off Oracle. Returns 1 on success, 0 on failure.
      <pre>
int logoff(void);
   
</pre>
    </li>

    <li>Commit current transaction. Returns 1 on success, 0 on failure.
      <pre>
int commit(void);
   
</pre>
    </li>

    <li>Roll back current transaction. Returns 1 on success, 0 on failure.
      <pre>
int rollback(void);
   
</pre>
    </li>
  </ul>
  <pre>
};
</pre>

  <h2><a name="sec22" id="sec22">2.2. otl_stream class</a></h2>

  <p><a name="sec22" id="sec22">OTL introduces the otl_stream class which is the actual implementation of the</a> <a href="#sec11">SQL Stream</a> concept. It is unified for any SQL statement or PL/SQL block which potentially may have input/output bind variables (placeholders). otl_stream provides the same interface for both straight SELECT statements and SELECT statements to be returned via a referenced cursor. Though, implementations are quite different.</p>

  <p>An OTL stream needs to have at least one <a href="#sec221">bind variable</a>. See <a href="#sec24">2.4.</a> for more information on how to execute a constant SQL statement or PL/SQL block.</p>
  <pre>
class otl_stream{
public:
</pre>

  <ul>
    <li>
      <a name="ref001" id="ref001"></a>General conctructor. SQL statement is parsed, all host input and output host variables are automatically allocated and bound. This constructor allows the user to use <a href="#sec221">extended placeholder declarations</a>.
      <pre>
otl_stream( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db, // connect object const
char* ref_cur_placeholder=0 // reference cursor placeholder, e.g.
":cur" );
   
</pre>
    </li>

    <li>Default constructor
      <pre>
otl_stream();
   
</pre>
    </li>

    <li>Destructor
      <pre>
~otl_stream();
   
</pre>
    </li>

    <li>
      <a name="ref005" id="ref005"></a>Test if all data has been already read from the stream
      <pre>
int eof(void);
   
</pre>
    </li>

    <li>
      <a name="ref010" id="ref010"></a>Flush stream's output buffer. It actually means to execute the SQL statement as many times as rows entered to the output buffer. The stream is automatically flushed when the buffer gets full.
      <pre>
void flush(void);
</pre>
    </li>

    <li>Clean up buffer without flushing it.
      <pre>
void clean(void);
   
</pre>
    </li>

    <li>Rewind stream
      <pre>
void rewind(void);
   
</pre>
    </li>

    <li>Test if NULL was fetched from the stream
      <pre>
int is_null(void);
   
</pre>
    </li>

    <li>Set "auto-commit" flag. When the buffer is flushed, current transaction is automatically commited, if the flag is set. By default, the flag is set. In order to prevent current transaction from "auto-committing", unset the flag using this function.<br>
      This auto-commit flag has nothing to do with the Oracle auto-commit mode. This auto-commit is otl_stream specific. If it is more convenient to have "auto-commit off" by default then it makes sense to derive another stream class from otl_stream and unset the flag in constructors of the derived class.
      <pre>
void set_commit(int auto_commit=0);
   
</pre>
    </li>

    <li>Open stream
      <pre>
void open( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db, // connect object const
char* ref_cur_placeholder=0 // reference cursor placeholder, e.g.
":cur" );
   
</pre>
    </li>

    <li>Close stream
      <pre>
void close(void);
   
</pre>
    </li>

    <li>Test if the stream was opened okay
      <pre>
int good(void);
   
</pre>
    </li>

    <li>
      <a name="ref004" id="ref004"></a>Read objects from stream
      <pre>
otl_stream&amp; operator&gt;&gt;(char&amp; c);
otl_stream&amp; operator&gt;&gt;(unsigned char&amp; c);
otl_stream&amp; operator&gt;&gt;(char* s);
otl_stream&amp; operator&gt;&gt;(unsigned char* s);
otl_stream&amp; operator&gt;&gt;(int&amp; n);
otl_stream&amp; operator&gt;&gt;(unsigned&amp; u);
otl_stream&amp; operator&gt;&gt;(short&amp; sh);
otl_stream&amp; operator&gt;&gt;(long int&amp; l);
otl_stream&amp; operator&gt;&gt;(float&amp; f);
otl_stream&amp; operator&gt;&gt;(double&amp; d);
   
</pre>
    </li>

    <li>
      <a name="ref003" id="ref003"></a>Write objects into stream
      <pre>
otl_stream&amp; operator&lt;&lt;(const char c);
otl_stream&amp; operator&lt;&lt;(const unsigned char c);
otl_stream&amp; operator&lt;&lt;(const char* s);
otl_stream&amp; operator&lt;&lt;(const unsigned char* s);
otl_stream&amp; operator&lt;&lt;(const int n);
otl_stream&amp; operator&lt;&lt;(const unsigned u);
otl_stream&amp; operator&lt;&lt;(const short sh);
otl_stream&amp; operator&lt;&lt;(const long int l);
otl_stream&amp; operator&lt;&lt;(const float f);
otl_stream&amp; operator&lt;&lt;(const double d);
otl_stream&amp; operator&lt;&lt;(const otl_null n); // write Oracle
NULL into stream. otl_null is a dummy class // which has only a empty
default constructor. The only purpose // of creating this class was
providing a function to write // NULL into the database
   
</pre>
    </li>

    <li>
      <a name="ref011" id="ref011"></a>C-style printf/scanf functions
      <pre>
void printf(const char* fmt,...);
void scanf(const char* fmt,...);
   
</pre>

      <p>The following format specifiers are supported:</p>

      <ul>
        <li><b>%d</b> -- int</li>

        <li><b>%u</b> -- unsigned</li>

        <li><b>%ld</b> -- long int</li>

        <li><b>%f</b> -- float</li>

        <li><b>%lf</b> -- double</li>

        <li><b>%c</b> -- char</li>

        <li><b>%s</b> -- string</li>

        <li><b>%N</b> -- specifier for writing NULL into streams</li>
      </ul>
    </li>
  </ul>
  <pre>
};
</pre>

  <h2><a name="sec221" id="sec221">2.2.1. Stream bind variables declaration</a></h2>

  <p><a name="sec221" id="sec221">This section explains in detail how to declare bind variables (or extended placeholders) in the SQL streams.</a></p>

  <p><a name="sec221" id="sec221">A SQL statement or PL/SQL block may have placeholders which are usually connected with the corresponding bind variables in the program. In Pro*C, the user needs to declare such variables directly in the program. OTL provides the same functionality in another way. There is a small parser which parses a SQL statament or PL/SQL block declaration and allocates corresponding bind variables dynamically inside the stream.</a></p>

  <p><a name="sec221" id="sec221">The following data types for extneded placeholder declarations are available:</a></p>

  <ul>
    <li><a name="sec221" id="sec221">int</a></li>

    <li><a name="sec221" id="sec221">unsigned</a></li>

    <li><a name="sec221" id="sec221">short</a></li>

    <li><a name="sec221" id="sec221">long -- (long integer)</a></li>

    <li><a name="sec221" id="sec221">float</a></li>

    <li><a name="sec221" id="sec221">double</a></li>

    <li><a name="sec221" id="sec221">char[length] (length &gt;= 3 &amp; length &lt;= 32545)</a></li>
  </ul>

  <p><a name="sec221" id="sec221">For PL/SQL blocks, special qualifiers are introduced to distinguish between input and output variables:</a></p>

  <ul>
    <li><a name="sec221" id="sec221">in -- input variable</a></li>

    <li><a name="sec221" id="sec221">out -- output variable</a></li>

    <li><a name="sec221" id="sec221">inout -- input/output variable</a></li>
  </ul>

  <h4><a name="sec221" id="sec221">Examples</a></h4>

  <p><a name="sec221" id="sec221">Here is some examples:</a></p>
  <pre>
<a name="sec221" id="sec221"> begin<br>   :rc&lt;int,out&gt; := my_func(:salary&lt;float,in&gt;,  <br>                           :ID&lt;int,inout&gt;, <br>                           :name&lt;char[32],out&gt;<br>                          );<br> end;<br></a>
</pre>

  <p><a name="sec221" id="sec221">Invoke the my_func function; return the function result into the :rc variable; the function has three parameters: salary (input), ID (iput/output), name (output)</a></p>
  <pre>
<a name="sec221" id="sec221">   select * from tab1 where f1 &gt; :f1&lt;double&gt;<br><br></a>
</pre>

  <p><a name="sec221" id="sec221">Select all columns from the tab1 table where f1 is greater than :f1</a></p>
  <pre>
<a name="sec221" id="sec221">   insert into tab1 values( :f1&lt;double&gt;, :f2;&lt;char[32]&gt;, :f3&lt;int&gt; )<br><br></a>
</pre>

  <p><a name="sec221" id="sec221">Insert row { :f1(double), :f2(string), :f3(integer) } into the tab1 table.</a></p>

  <p><a name="sec221" id="sec221">In the extended placeholder declaration, spaces in the data type section and in the access qualifier section ARE NOT allowed. The following code is invalid:</a></p>
  <pre>
<a name="sec221" id="sec221"> insert into tab1 values(:f1&lt; double &gt;,
:f2&lt; char [ 32 ] &gt; , :f3&lt; int&gt;); :rc&lt; int, out &gt; :=
...;
  </a>
</pre>

  <h2><a name="sec23" id="sec23">2.3. Exception handling</a></h2>

  <p><a name="sec23" id="sec23">In case of Oracle failure or inconsistent use of SQL streams, exceptions of the otl_exception type are raised by the library functions. The main advantage of using this exception handling mechanism is that exceptions can be processed in one catch block, instead of checking return codes from every library function call.</a></p>
  <pre>
<a name="sec23" id="sec23">
class otl_exception{
public:
  </a>
</pre>

  <ul>
    <li>
      <a name="ref008" id="ref008"></a>This <i>enum</i> defines two constants which may be used in the <a href="#sec24">direct_exec</a> function
      <pre>
enum{ disabled, enabled };<br>
</pre>
    </li>

    <li>Create exception out of Logon Descriptor Area (Oracle 7) or out of OCI error handle (Oracle 8)
      <pre>
otl_exception(Lda_Def&amp; lda,const char* sqlstm=0); or
otl_exception(OCIError* errhp,const char* sqlstm=0)
     
</pre>
    </li>

    <li>Create exception from amsg, acode and sqlstm
      <pre>
otl_exception(const char* amsg,const int acode,const char*
sqlstm=0);
     
</pre>
    </li>

    <li>Copy constructor
      <pre>
otl_exception(const otl_exception&amp; p);
     
</pre>
    </li>

    <li>Default constructor
      <pre>
otl_exception();
     
</pre><br>
      <hr size="3">
      <br>
    </li>

    <li>error message buffer
      <pre>
unsigned char msg[1000];
</pre>
    </li>

    <li>error code
      <pre>
int code;
     
</pre>
    </li>

    <li>SQL statement or PLSQL block that caused the error
      <pre>
unsigned char* stm_text;
     
</pre>
    </li>
  </ul>
  <pre>
};
 
</pre>

  <h3>Example</h3>
  <pre>
try{ otl_stream s(50, // fetch 50 rows per one fetch operation
"select state_name, state_code " "from state " "where state_name like
:v1&lt;char[33]&gt;", db // connect object ); char name[33]; int code;
s&lt;&lt;"M%"; while(!s.eof)){ s&gt;&gt;name&gt;&gt;code;
cout&lt;&lt;"State="&lt;&lt;name&lt;&lt;",
Code="&lt;&lt;code&lt;&lt;endl; } }catch(otl_exception&amp; p){ //
intercept exception cerr&lt;&lt;p.code&lt;&lt;endl; // print out error
code cerr&lt;&lt;p.msg&lt;&lt;endl; // print out error message
cerr&lt;&lt;p.stm_text&lt;&lt;endl; // print out SQL that caused the
error }
 
</pre>

  <h2><a name="sec24" id="sec24">2.4. Constant SQL statement or PL/SQL block</a></h2>

  <p><a name="sec24" id="sec24">SQL statement or PL/SQL block is considered to be constant if it does not have any bind variables. OTL has a static (in class) function to execute constant statements or blocks, e.g.</a></p>
  <pre>
<a name="sec24" id="sec24"> otl_cursor::direct_exec (db, // connect object
"create table test_tab(f1 number, f2 varchar2(30))" ); // create table
  </a>
</pre>

  <p><a name="sec24" id="sec24">otl_cursor is one of OTL internal classes. There is another format of the direct_exec function call:</a></p>
  <pre>
<a name="sec24" id="sec24"> otl_cursor::direct_exec (db, // connect object
"drop table test_tab", // SQL statement or PL/SQL block
otl_exception::disabled // disable OTL exceptions, // in other words,
ignore any // Oracle error ); // drop table
  </a>
</pre>

  <h2><a name="sec25" id="sec25">2.5. Examples</a></h2>

  <h3><a name="sec25" id="sec25">Example 1 (with otl_stream class)</a></h3>

  <h4><a name="sec25" id="sec25">Source code</a></h4>
  <pre>
<a name="sec25" id="sec25"><font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref101" id="ref101"></a>
</pre>

  <h4><font color="#0000A0">void</font> insert()</h4>
  <pre>

<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"insert into test_tab values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)"</font>, <br>                <i><font color="#804000">// SQL statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             );
 <font color="#0000A0">char</font> tmp[32];<br><br> <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);<br>  o<a href="#ref003">&lt;&lt;</a>(<font color="#0000A0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;<br> }<br>}<br><br><a name="ref102" id="ref102"></a>
</pre>

  <h4><font color="#0000A0">void</font> select()</h4>
  <pre>

{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"select * from test_tab where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2"</font>,<br>                 <i><font color="#804000">// SELECT statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;<br> <font color="#0000A0">char</font> f2[31];<br><br> i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br>
</pre>

  <h4><font color="#0000A0">int</font> main()</h4>
  <pre>

{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>
 <font color="#0000A0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref101">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref102">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;<br><br>}<br><br>
</pre>

  <h4>Output</h4>
  <pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

  
</pre>

  <h3>Example 2 (with PL/SQL block)</h3>

  <h4>Source code</h4>
  <pre>
<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref201" id="ref201"></a>
</pre>

  <h4><font color="#0000A0">void</font> plsql()</h4>
  <pre>

<i><font color="#804000">// invoking PL/SQL block</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(5, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"begin "</font>
              <font color="#008080">" :A&lt;int,inout&gt; := :A+1; "</font>
              <font color="#008080">" :B&lt;char[31],out&gt; := :C&lt;char[31],in&gt;; "</font>
              <font color="#008080">"end;"</font>,<br>              <i><font color="#804000">// PL/SQL block</font></i>
              db <i><font color="#804000">// connect object</font></i>
             );
 o<a href="#ref003">&lt;&lt;</a>1<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String1"</font>; <i><font color="#804000">// assigning :A = 1, :C = "Test String1"</font></i>
 o<a href="#ref003">&lt;&lt;</a>2<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String2"</font>; <i><font color="#804000">// assigning :A = 2, :C = "Test String2"</font></i>
 o<a href="#ref003">&lt;&lt;</a>3<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String3"</font>; <i><font color="#804000">// assigning :A = 3, :C = "Test String3"</font></i>

 o.<a href="#ref010">flush()</a>; <i><font color="#804000">// executing PL/SQL block 3 times</font></i>

 <font color="#0000A0">int</font> a;<br> <font color="#0000A0">char</font> b[32];<br><br> <font color="#0000A0">while</font>(!o.<a href="#ref005">eof()</a>){ <i><font color="#804000">// not end-of-data</font></i>
  o<a href="#ref004">&gt;&gt;</a>a<a href="#ref004">&gt;&gt;</a>b;<br>  cout&lt;&lt;<font color="#008080">"A="</font>&lt;&lt;a&lt;&lt;<font color="#008080">", B="</font>&lt;&lt;b&lt;&lt;endl;<br> }<br><br>}<br><br>
</pre>

  <h4><font color="#0000A0">int</font> main()</h4>
  <pre>

{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>
 <font color="#0000A0">try</font>{<br>  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>
  <a href="#ref201">plsql()</a>; <i><font color="#804000">// invoking PL/SQL block</font></i>
 }
 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }
 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>
 <font color="#0000A0">return</font> 0;<br>} <br><br>
</pre>

  <h4>Output</h4>
  <pre>
A=2, B=Test String1
A=3, B=Test String2
A=4, B=Test String3

  
</pre>

  <h3>Example 3 (with printf/scanf functions)</h3>

  <h4>Source code</h4>
  <pre>
<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref301" id="ref301"></a>
</pre>

  <h4><font color="#0000A0">void</font> insert()</h4>
  <pre>

<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"insert into test_tab values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)"</font>, <br>          <i><font color="#804000">// SQL statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             );
 <font color="#0000A0">char</font> tmp[32];<br><br> <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);<br>  o.<a href="#ref011">printf</a>(<font color="#008080">"%d %s"</font>,i,tmp); <i><font color="#804000">// write one row into stream</font></i>
 }
}

<a name="ref302" id="ref302"></a>
</pre>

  <h4><font color="#0000A0">void</font> select()</h4>
  <pre>

{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"select * from test_tab where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2"</font>,<br>                 <i><font color="#804000">// SELECT statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;<br> <font color="#0000A0">char</font> f2[31];<br><br> i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i.<a href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&amp;f1,f2); <i><font color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i.<a href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&amp;f1,f2); <i><font color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br>
</pre>

  <h4><font color="#0000A0">int</font> main()</h4>
  <pre>

{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref301">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref302">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;<br><br>}<br><br>
</pre>

  <h4>Output</h4>
  <pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

  
</pre>

  <h3>Example 4 (with otl_stream class and referenced cursor)</h3>

  <h4>Source code</h4>
  <pre>
<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref401" id="ref401"></a>
</pre>

  <h4><font color="#0000A0">void</font> insert()</h4>
  <pre>

<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"insert into test_tab values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)"</font>, <br>                <i><font color="#804000">// SQL statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             );
 <font color="#0000A0">char</font> tmp[32];<br><br> <font color="#0000A0">for</font>(int i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);<br>  o<a href="#ref003">&lt;&lt;</a>(<font color="#0000A0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;<br> }<br>}<br><br><a name="ref402" id="ref402"></a>
</pre>

  <h4><font color="#0000A0">void</font> select()</h4>
  <pre>

{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"begin "</font>
              <font color="#008080">" open :cur for "</font>
              <font color="#008080">"  select * "</font>
              <font color="#008080">"  from test_tab "</font>
              <font color="#008080">"  where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2; "</font>
              <font color="#008080">"end;"</font>, <br>             <i><font color="#804000">// PL/SQL block returns a referenced cursor</font></i>
              db, <i><font color="#804000">// connect object</font></i>
              <font color="#008080">":cur"</font> <i><font color="#804000">// referenced cursor placeholder name</font></i>
             ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;<br> <font color="#0000A0">char</font> f2[31];<br><br> i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br>
</pre>

  <h4><font color="#0000A0">int</font> main()</h4>
  <pre>

{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref401">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref402">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;<br><br>}<br><br>
</pre>

  <h4>Output</h4>
  <pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

  
</pre>

  <h1><a name="sec3" id="sec3">3. STL-compliant iterators for otl_stream</a></h1>

  <p><a name="sec3" id="sec3">OTL provides two</a> <a href="#sec22">otl_stream</a> based <a href="http://www.sgi.com/Technology/STL/Iterators.html">STL-compliant iterator</a> classes:</p>

  <ul>
    <li><a href="otl_it01.htm">otl_output_iterator</a></li>

    <li><a href="otl_it02.htm">otl_input_iterator</a></li>
  </ul>

  <p>These two iterator classes make it possible to combine the power of <a href="http://www.metabyte.com/%7Efbp/stl/readings.html">generic programming</a> and Oracle into compact, reliable, top performance and easy-to-maintain C++ database applications.</p>

  <p>It would be cool to develop a PL/SQL-to-C++ converter which would use STL container classes (to efficiently implement PL/SQL tables) and OTL to take advantage of straight OCI in order to efficiently implement Oracle cursor handling. Also, converting interpreted code into code compiled into native machine instructions is not such a bad idea.</p>

  <h2><a name="sec31" id="sec31">3.1. Example</a></h2>

  <h4><a name="sec31" id="sec31">Source code</a></h4>
  <pre>
<a name="sec31" id="sec31"><font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl_iter.h&gt;</font>
<font color="#FF0000">#include &lt;vector.h&gt;</font>
<font color="#FF0000">#include &lt;hash_map.h&gt;</font>
<font color="#FF0000">#include &lt;iterator.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<i><font color="#804000">// row container class</font></i>
<font color="#0000A0">class</font> row{<br><font color="#0000A0">public</font>:<br> <font color="#0000A0">int</font> f1;<br> <font color="#0000A0">char</font> f2[32];<br><br><i><font color="#804000">// default constructor</font></i>
 row(){f1=0; f2[0]=0;}

<i><font color="#804000">// destructor</font></i>
 ~row(){}

<i><font color="#804000">// copy constructor</font></i>
 row(<font color="#0000A0">const</font> row&amp; row)<br> {<br>  f1=row.f1;<br>  strcpy(f2,row.f2);<br> }<br> <br><i><font color="#804000">// assignment operator</font></i>
 row&amp; <font color="#0000A0">operator</font>=(<font color="#0000A0">const</font> row&amp; row)<br> {<br>  f1=row.f1;<br>  strcpy(f2,row.f2);<br>  <font color="#0000A0">return</font> *<font color="#0000A0">this</font>;<br> }<br><br>};<br><br><i><font color="#804000">// redefined operator&gt;&gt; for reading row&amp; from otl_stream</font></i>
<a href="#ref001">otl_stream</a>&amp; <font color="#0000A0">operator</font>&gt;&gt;(<a href="#ref001">otl_stream</a>&amp; s, row&amp; row)<br>{<br> s<a href="#ref004">&gt;&gt;</a>row.f1<a href="#ref004">&gt;&gt;</a>row.f2;<br> <font color="#0000A0">return</font> s;<br>}<br><br><i><font color="#804000">// redefined operator&lt;&lt; for writing row&amp; into otl_stream</font></i>
<a href="#ref001">otl_stream</a>&amp; <font color="#0000A0">operator</font>&lt;&lt;(<a href="#ref001">otl_stream</a>&amp; s, <font color="#0000A0">const</font> row&amp; row)<br>{<br> s<a href="#ref003">&lt;&lt;</a>row.f1<a href="#ref003">&lt;&lt;</a>row.f2;<br> <font color="#0000A0">return</font> s;<br>}<br><br><i><font color="#804000">// redefined operator&lt;&lt; writing row&amp; into ostream</font></i>
ostream&amp; <font color="#0000A0">operator</font>&lt;&lt;(ostream&amp; s, <font color="#0000A0">const</font> row&amp; row)<br>{<br> s&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;row.f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;row.f2;<br> <font color="#0000A0">return</font> s;<br>}<br><br><a name="ref501" id="ref501"></a>
</pre>

  <h4><font color="#0000A0">void</font> insert()</h4>
  <pre>

<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"insert into test_tab values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)"</font>, <br>          <i><font color="#804000">// SQL statement</font></i>
              db // connect object
             );
 row r; <i><font color="#804000">// single row buffer</font></i>
 vector&lt;row&gt; vo; <i><font color="#804000">// vector of rows</font></i>

<i><font color="#804000">// populate the vector</font></i>
 <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i&lt;=100;++i){<br>  r.f1=i;<br>  sprintf(r.f2,<font color="#008080">"Name%d"</font>,i);<br>  vo.push_back(r);<br> }<br><br> cout&lt;&lt;<font color="#008080">"vo.size="</font>&lt;&lt;vo.size()&lt;&lt;endl;<br><i><font color="#804000">// insert vector into table</font></i>
 copy(vo.begin(), 
      vo.end(), 
      <a href="otl_it01.htm#">otl_output_iterator</a>&lt;row&gt;(o)<br>     );<br><br>}<br><br><a name="ref502" id="ref502"></a>
</pre>

  <h4><font color="#0000A0">void</font> select()</h4>
  <pre>

{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
              <font color="#008080">"select * from test_tab where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2"</font>,<br>                 <i><font color="#804000">// SELECT statement</font></i>
              db <i><font color="#804000">// connect object</font></i>
             ); 
   <i><font color="#804000">// create select stream</font></i>
 
 vector&lt;int&gt; inp_par; <i><font color="#804000">// vector of 1 element to demonstrate OTL iterators</font></i>
 vector&lt;row&gt; v; <i><font color="#804000">// vector of rows</font></i>

<i><font color="#804000">// assigning :f = 8</font></i>
<i><font color="#804000">// this example demonstrates how both input</font></i>
<i><font color="#804000">// and output iterators may be attached to the</font></i>
<i><font color="#804000">// same otl_stream</font></i>

 inp_par.push_back(8); <i><font color="#804000">// populate the vector with one element</font></i>
 cout&lt;&lt;<font color="#008080">"inp_par.size="</font>&lt;&lt;inp_par.size()&lt;&lt;endl;<br><br><i><font color="#804000">// copy the vector into the input variable of the select statement</font></i>
 copy(inp_par.begin(),inp_par.end(),<a href="otl_it01.htm#">otl_output_iterator</a>&lt;int&gt;(i));<br><br><i><font color="#804000"> // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000"> // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched into the vector</font></i>

 copy(<a href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(i), <br>      <a href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(),<br>      back_inserter(v));    <br><br> cout&lt;&lt;<font color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;<br><br><i><font color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font color="#008080">"\n"</font>));<br><br><i><font color="#804000">// clean up the vector</font></i>
 v.erase(v.begin(),v.end());

<i><font color="#804000">// OTL traditional technique</font></i>
  i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
<i><font color="#804000">   // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000">   // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched to the vector</font></i>
 copy(otl_input_iterator&lt;row,ptrdiff_t&gt;(i), 
      otl_input_iterator&lt;row,ptrdiff_t&gt;(),
      back_inserter(v));    

 cout&lt;&lt;<font color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;<br><br><i><font color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font color="#008080">"\n"</font>));<br><br>}<br><br>
</pre>

  <h4><font color="#0000A0">int</font> main()</h4>
  <pre>

{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font color="#008080">"drop table test_tab"</font>,<br>    otl_exception::disabled <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
   );  <i><font color="#804000">// create table</font></i>

  <a href="#ref501">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref502">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL statement associated with the error</font></i>
 }

 db.<a href="#ref009">logoff(</a>); <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;<br><br>}<br><br>
</pre>

  <h4>Output</h4>
  <pre>
vo.size=100
inp_par.size=1
Size=9
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
Size=5
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
 
</pre>

  <h1><a name="app_a" id="app_a">Appendix A. How to download the source code</a></h1>

  <p><a name="app_a" id="app_a">In order to obtain a copy of the OTL header files, send email to</a> <a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>, <a href="mailto:skuchin@gmail.com">skuchin@gmail.comgmail</a></p>

  <p><a href="mailto:skuchin@gmail.com">Here is the list of the OTL header files:</a></p>

  <ul>
    <li><a href="mailto:skuchin@gmail.com"><i><font color="#804040">otl7.h</font></i> -- the OTL source code for Oracle 7.</a></li>

    <li><a href="mailto:skuchin@gmail.com"><i><font color="#804040">otl8.h</font></i> -- the OTL source code for Oracle 8. Save the file as otl.h.</a></li>

    <li><a href="mailto:skuchin@gmail.com"><i><font color="#804040">otl_iter.h</font></i> -- STL-compliant iterators for otl_stream</a></li>
  </ul>

  <p><a href="mailto:skuchin@gmail.com">Besides, you need to have standard OCI header files and object libraries. The location of the files and libraries is specific to the operating system. See the Oracle manuals for more details.</a></p>

  <p><a href="mailto:skuchin@gmail.com">The OCI7 standard header files are as follows:</a></p>

  <ul>
    <li><a href="mailto:skuchin@gmail.com">ociapr.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocidfn.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocikpr.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">oratypes.h</a></li>
  </ul>

  <p><a href="mailto:skuchin@gmail.com">The OCI8 standard header files are as follows:</a></p>

  <ul>
    <li><a href="mailto:skuchin@gmail.com">nzerror.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">nzt.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">oci.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ociap.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ociapr.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocidef.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocidem.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocidfn.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ociextp.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocikp.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ocikpr.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">oratypes.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ori.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">orid.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">orl.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">oro.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">ort.h</a></li>

    <li><a href="mailto:skuchin@gmail.com">tnsapi.h</a></li>
  </ul>

  <p><a href="mailto:skuchin@gmail.com">If you want to use the</a> <a href="#sec3">STL-compliant iterators</a> then you are going to need the <a href="http://www.metabyte.com/%7Efbp/stl/">Standard Template Library</a> (adaption by <a href="mailto:fbp@metabyte.com">Boris Fomitchev</a>) or <a href="http://www.sgi.com/Technology/STL/">the original STL SGI, version 3.11</a>.</p>

  <h1><a name="app_b" id="app_b">Appendix B. OTL exception list</a></h1>

  <p><a name="app_b" id="app_b">The following</a> <a href="#sec23">OTL exceptions</a> can be raised by the OTL functions:</p>

  <dl>
    <dt><b>Code=32000</b>: Incompatible data types in stream operation</dt>

    <dd><br>
    <b>Cause</b>: The data type of a variable used in the current stream operation is not compatible with the declared stream format.<br>
    <br>
    <b>Action</b>: Check placeholders and their data types declaration.</dd>

    <dt><br>
    <b>Code=32001</b>: Row must be full for flushing output stream</dt>

    <dd><br>
    <b>Cause</b>: Stream is open for output and has a format of output rows. An output row is a tuple of all output variables put together. The current output row is not filled yet but the flush function is invoked. The stream buffer cannot be flushed until the current row of the output buffer is full.<br>
    <br>
    <b>Action</b>: Fill the row first, then flush the stream.</dd>

    <dt><br>
    <b>Code=32004</b>: Not all input variables have been initialized</dt>

    <dd><br>
    <b>Cause</b>: stream has input variables but not all the variables have been initialized. An attempt to read data from the stream was made.<br>
    <br>
    <b>Action</b>: Assign all the input variables first.</dd>

    <dt><br>
    <b>Code=32004</b>: No input variables have been defined in SQL statement</dt>

    <dd><br>
    <b>Cause</b>: Stream has no input variables. An attempt to write objects to the stream via one of the &lt;&lt; operators was made.<br>
    <br>
    <b>Action</b>: Do not call the &lt;&lt; operators for streams which have no input variables defined.</dd>
  </dl><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script><script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
  pageTracker._trackPageview();
  </script>
</body>
</html>
