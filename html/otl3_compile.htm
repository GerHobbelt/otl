<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Win95; U) [Netscape]">
  <meta name="KeyWords" content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">

  <title>OTL 4.0, How to compile OTL</title>
</head>

<body>
  <br>
  <br>

  <center>
    <h1>OTL 4.0, How to compile OTL</h1>
  </center>

  <h1><a name="otl_compile" id="otl_compile"></a>How to compile OTL</h1>OTL 4.0 is an integrated library which contains a template stream framework and OTL-adapters for the OCI7, OCI8, OCI8i, OCI9i, OCI10g, ODBC 2.5, ODBC 3.x, DB2 CLI, and Informix CLI. The following macro definitions (#define's) need to be used in order to compile OTL for each type of the underlying database API from the list above:<br>
  <br>

  <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;">#define Name</span></td>

        <td style="vertical-align: top;"><span style="font-weight: bold;">Explanation<br></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_DB2_CLI" id="OTL_DB2_CLI"></a><b>OTL_DB2_CLI</b></td>

        <td style="vertical-align: top;">for <a href="http://www-4.ibm.com/software/data/db2/">DB2</a> Call Level Interface (CLI)</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_ENTERPRISEDB" id="OTL_ODBC_ENTERPRISEDB"></a>OTL_ODBC_<br>
        ENTERPRISEDB</span><br></td>

        <td style="vertical-align: top;">for <a href="http://www.enterprisedb.com">Enterprise DB</a> ODBC provider. Enterprise DB is a variant of PostreSQL that was made compatible with Oracle (up to some extent) and commecially available.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_INFORMIX_CLI" id="OTL_INFORMIX_CLI"></a>OTL_INFORMIX_CLI</span><br></td>

        <td style="vertical-align: top;">for Informix Call Level Interface for Unix (when&nbsp; <a href="#OTL_ODBC_UNIX">OTL_ODBC_UNIX</a> is enabled).<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_IODBC_BSD" id="OTL_IODBC_BSD"></a><b>OTL_IODBC_BSD</b></td>

        <td style="vertical-align: top;">for ODBC on BSD Unix, when iODBC package is used<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><b><a name="OTL_ODBC" id="OTL_ODBC"></a>OTL_ODBC</b></td>

        <td style="vertical-align: top;">for ODBC</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_MSSQL_2005" id="OTL_ODBC_MSSQL_2005"></a>OTL_ODBC_MSSQL_2005</span><br></td>

        <td style="vertical-align: top;">Microsoft SQL Server 2005 requires special treatment when VARCHAR(MAX), VARBINARY(MAX), and NVARCHAR(MAX) are used. MS SQL 2005's Native SQL Client (SNAC) handles the new XXX(MAX) data types in a different way, compared with TEXT, NTEXT, and IMAGE data types. If the XXX(MAX) types are not used, #define OTL_ODBC can be used. Otherwise, this new #define OTL_ODBC_MSSQL_2005 should be used.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ODBC_MSSQL_2008" id="OTL_ODBC_MSSQL_2008"></a><span style="font-weight: bold;">OTL_ODBC_<br>
        MSSQL_2008</span><br></td>

        <td style="vertical-align: top;">MS SQL Server 2008 has new features like datetime2, date, time, filestream based VARBINARY(MAX), etc. This #define enables OTL support for most of the new features.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ODBC_MULTI_MODE" id="OTL_ODBC_MULTI_MODE"></a><span style="font-weight: bold;">OTL_ODBC_<br>
        MULTI_MODE</span><br></td>

        <td style="vertical-align: top;">This #define should be used when there is a need to connect via ODBC to more than one database type from the same time. For more detail see otl_connect::<a href="otl3_connect_class.htm#set_connection_mode">set_connection_mode</a>(), and OTL example <a href="otl4_ex675.htm">675</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><small><small><a name="OTL_ODBC_MYSQL" id="OTL_ODBC_MYSQL"></a></small></small><b>OTL_ODBC_MYSQL</b></td>

        <td style="vertical-align: top;">for <i><a href="http://www.mysql.com/downloads/api-myodbc.html">MyODBC</a>/<a href="http://www.mysql.com/">MySQL</a></i>. The difference between OTL_ODBC_MYSQL and OTL_ODBC is that transactional ODBC function calls are turned off for OTL_ODBC_MYSQL, since MySQL does not have transactions, unless innoDB table type is used.. This #define should only used with the MyODBC 2.5, which is very old at this point in time. See MySQL based OTL code examples for more detail.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_POSTGRESQL" id="OTL_ODBC_POSTGRESQL"></a>OTL_ODBC_<br>
        POSTGRESQL</span><br></td>

        <td style="vertical-align: top;">
          PostgreSQL ODBC can be used with the standard #define <a href="#OTL_ODBC">OTL_ODBC</a>. However, PostgreSQL has at least two ODBC drivers,&nbsp; and some of them should be used with #define OTL_ODBC_POSTGRESQL. The following list specifies the differences between #define OTL_ODBC and #define OTL_ODBC_POSTGRESQL in more detail:<br>

          <ul>
            <li>Linux<br></li>

            <li style="list-style: none; display: inline">
              <ul>
                <li>psqlodbc.so,&nbsp; psqlodbcw.so should be used with #define OTL_ODBC_POSTGRESQL</li>

                <li>libodbcpsql.so should be used with #define OTL_ODBC<br></li>
              </ul>
            </li>

            <li>Solaris<br></li>

            <li style="list-style: none; display: inline">
              <ul>
                <li>libodbcpsql.so should be used with #define OTL_ODBC_POSTGRESQL<br></li>
              </ul>
            </li>

            <li>Windows</li>

            <li style="list-style: none; display: inline">
              <ul>
                <li>pgsqlodbc30a.dll, pgsqlodbc35w.dll should be used with #define OTL_ODBC_POSTGRESQL<br></li>
              </ul>
            </li>
          </ul>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ODBC_TIMESTEN_UNIX" id="OTL_ODBC_TIMESTEN_UNIX"></a><span style="font-weight: bold;">OTL_ODBC_<br>
        TIMESTEN_UNIX</span><br></td>

        <td style="vertical-align: top;">
          for TimesTen in Unix/Linux. TimesTen supports ODBC. Unlike many other database systems, where ODBC API support may be much slower than the proprietary interface, ODBC is the <span style="font-style: italic;">native</span> TimesTen interface that operates directly with the database engine. TimesTen ODBC driver has the following extensions that are available through OTL:<br>

          <ul>
            <li>the <a href="otl3_bind_variables.htm#NAMED_BV_NOTATION">named notation</a> for bind variables / placeholders</li>

            <li>TT_PRFEFETCH_COUNT ([0..128] range)<br></li>
          </ul><br>
          See "how to <a href="#TIMESTEN_ODBC_UNIX_COMPILE">compile</a> TimesTen in Linux/Unix" for more detail.
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_TIMESTEN_WIN" id="OTL_ODBC_TIMESTEN_WIN"></a>OTL_ODBC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">TIMESTEN_WIN</span><br></td>

        <td style="vertical-align: top;">
          for TimesTen in Windows. TimesTen supports ODBC. Unlike many other database systems, where ODBC API support may be much slower than the proprietary interface, ODBC is the <span style="font-style: italic;">native</span> TimesTen interface that operates directly with the database engine. ODBC driver has the following extensions that are available through OTL:<br>

          <ul>
            <li>the <a href="otl3_bind_variables.htm#NAMED_BV_NOTATION">named notation</a> for bind variables / placeholders</li>

            <li>TT_PRFEFETCH_COUNT ([1..128] range)<br></li>
          </ul>See how to <a href="#TIMESTEN_ODBC_WIN_COMPILE">compile</a> TimesTen in Windows for more detail.
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><small><a name="OTL_ODBC_UNIX" id="OTL_ODBC_UNIX"></a></small><b>OTL_ODBC_UNIX</b></td>

        <td style="vertical-align: top;">for ODBC bridges in Unix</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><b><a name="OTL_ODBC_zOS" id="OTL_ODBC_zOS"></a>OTL_ODBC_zOS</b></td>

        <td style="vertical-align: top;">for ODBC on IBM zOS.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><small><a name="INTERBASE" id="INTERBASE"></a></small><b>OTL_ODBC_XTG_IBASE6</b></td>

        <td style="vertical-align: top;">for <a href="http://www.borland.com/devsupport/interbase/opensource/">Interbase</a> 6.x via <a href="http://www.xtgsystems.com/">XTG Systems'</a>&nbsp; <a href="http://www.xtgsystems.com/ib6odbc.php3">ODBC driver</a>. The reason for introducing this #define is that the ODBC driver is the only Open Source ODBC driver for Interbase. Other drivers, like Easysoft's ODBC for Interbase, are commercial products, and it beats the purpose of using Interbase, as an Open Source.database server.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><b><a name="OTL_ORA7" id="OTL_ORA7"></a>OTL_ORA7</b></td>

        <td style="vertical-align: top;">for OCI7</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><b><a name="OTL_ORA8" id="OTL_ORA8"></a>OTL_ORA8</b></td>

        <td style="vertical-align: top;">for OCI8</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><b><a name="OTL_ORA8I" id="OTL_ORA8I"></a>OTL_ORA8I</b></td>

        <td style="vertical-align: top;">for OCI8i</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTLORA9I" id="OTLORA9I"></a><b>OTL_ORA9I<a name="OTL_ORA9I" id="OTL_ORA9I"></a></b></td>

        <td style="vertical-align: top;">for OCI9i. All code that compiles and works under #define OTL_ORA7, OTL_ORA8, and OTL_ORA8I, should work when OTL_ORA9I is used</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA10G" id="OTL_ORA10G"></a>OTL_ORA10G</span><br></td>

        <td style="vertical-align: top;">for OCI10g. All code that compiles and works&nbsp; under #define OTL_ORA7, OTL_ORA8, OTL_ORA8I, OTL_ORA9I, should work with OTL_ORA10G.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA10G_R2" id="OTL_ORA10G_R2"></a>OTL_ORA10G_R2</span></td>

        <td style="vertical-align: top;">for OCI10g, Release 2 (Oracle 10.2). All code that compiles and works&nbsp; under #define OTL_ORA7, OTL_ORA8, OTL_ORA8I, OTL_ORA9I, and OTL_ORA10G should work with OTL_ORA10G_R2 .<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA11G" id="OTL_ORA11G"></a>OTL_ORA11G</span><br></td>

        <td style="vertical-align: top;">for OCI11g Release 1 (Oracle 11.1). All code that compiles and works under #define OTL_ORA7, OTL_ORA8, OTL_ORA8I, OTL_ORA9I, OTL_ORA10G, and OTL_ORA10G_R2 should work with OTL_ORA11G..</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><small style="font-weight: bold;"><a name="OTL_ORA11G_R2" id="OTL_ORA11G_R2"></a><big>OTL_ORA11G_R2</big></small><br></td>

        <td style="vertical-align: top;">for OCI 11G Release 2 (Oracle 11.2). All code that compiles and works under #defines OTL_ORA7-11G should work with OTL_ORA11G_R2.<br></td>
      </tr>
    </tbody>
  </table><br>
  <br>
  There are several extra macro definitions which control compilation of the OTL header file:<br>
  <br>

  <table style="text-align: left; width: 992px; height: 3222px;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;">#define</span><br></td>

        <td style="vertical-align: top;"><span style="font-weight: bold;">Explanation</span><br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ACE" id="OTL_ACE"></a><b>OTL_ACE</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(the same as #define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>, only for use with Adaptive Communication Environment (<a href="http://www.cs.wustl.edu/%7Eschmidt/ACE.html">ACE</a>)). This #defines makes OTL compile with ACE. Most features of OTL, which require #define OTL_STL to be on, compile with ACE, except for <a href="otl3_output_iterator.htm">otl_output_iterator</a>, <a href="otl3_input_iterator.htm">otl_input_iterator.</a>, and the <a href="otl3_pl_tab.htm">STL vector based PL/SQL table container classes</a> (otl_XXX_vec). OTL stream iterators were not implemented for ACE since the concept of stream iterators is not present in ACE. Same with with the otl_XXX_vec: vectors are not implemented in ACE. ACE has only dynamic arrays with
        dynamically defined sizes.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ADD_NULL_TERMINATOR_TO_STRING_SIZE" id="OTL_ADD_NULL_TERMINATOR_TO_STRING_SIZE"></a><b>OTL_ADD<br>
        _NULL<br>
        _TERMINATOR<br>
        _TO_STRING<br>
        _SIZE</b>.</font></td>

        <td style="vertical-align: top;">This #define enables the addition of one byte / Unicode character to the size of a string buffer, when the buffer gets allocated on the program's heap. This alleviates the burden of remembering that an extra byte / Unicode character needs to be added to the string buffer size to accomodate the string's NULL terminator.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ANSI_CPP" id="OTL_ANSI_CPP"></a><b>OTL_ANSI_CPP&nbsp;</b></font></td>

        <td style="vertical-align: top;">for turning on ANSI C++ compliance mode: ANSI C++ typecasts (static_cast&lt;&gt;, const_cast&lt;&gt;, reinterpret_cast&lt;&gt; instead of C-style typecasts), <a href="#OTL_FUNC_THROW_SPEC_ON">optional function throw</a> clauses, <span style="font-style: italic;">typename</span> instead of <span style="font-style: italic;">class</span> keywords in class type template class parameters, etc.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_BIGINT" id="OTL_BIGINT"></a><span style="font-weight: bold;">OTL_BIGINT</span>&nbsp;</font></td>

        <td style="vertical-align: top;">
          This #define enables support for <a href="otl3_bind_variables.htm#bigint">bigint</a> (signed 64-bit integer) bind variables by specifying a 64-bit signed integer data type name, for example:<br>
          <pre>
#define OTL_BIGINT __int64 // VC++, Borland C++
</pre>or<br>
          <pre>
#define OTL_BIGINT long long // GNU C++<br><br>
</pre>ODBC and DB2-CLI support 64-bit integers natively, so does OTL. No 32-bit OCI (OCI7,OCI8, OCI8i, OCI9i, OCI10g, OCI11g) prior to OCI 11.2 supports 64-bit integers, so OTL has to emulate this type of bind variables via strings (char[XXX]). OTL allocates and&nbsp; binds a string variable with a placeholder that is defined as &lt;<a href="otl3_bind_variables.htm#bigint">bigint</a>&gt;.<br>
          <br>
          In case if OTL_BIGINT under a 32-bit C++ compiler, and one of the OTL_ORAxx #defines are defined together, the following two defines also need to be enabled: <a href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>, <a href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>.<br>
          <br>
          In 64-bit OCIs (OTL/ORAXXX) on LP64 platformts, #define <a href="otl3_compile.htm#OTL_ORA_MAP_BIGINT_TO_LONG">OTL_ORA_MAP_BIGINT_TO_LONG</a> can be used to map &lt;<a href="otl3_bind_variables.htm#bigint">bigint</a>&gt; to 64-bit longs on LP64 platforms, which is more efficient than the char[XXX] OCI binding for &lt;bigint&gt;.<br>
          <br>
          When <a href="otl3_compile.htm#OTL_ORA11G_R2">OTL_ORA11G_R2</a> is defined, OTL_BIGINT is supported natively for both 32-bit and 64-bit OCI11.2.<br>
          <br>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><span style="font-weight: bold;"><a name="OTL_BIGINT_TO_STR" id="OTL_BIGINT_TO_STR"></a>OTL_BIGINT</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">_TO_STR</span>(n,str)<br></font></td>

        <td style="vertical-align: top;">
          This #define is required when <a href="#OTL_BIGINT">OTL_BIGINT</a> is enabled and when one of OTL_ORAxx #defines is enabled, in order to support OTL internal bigint-to-string conversion. This #define is supposed to provide bigint-to-string conversion code that is most probably C++ compiler specific (because 64-bit ints are not part of the ANSI C++ standard), for example:<br>
          <pre>
#if defined(_MSC_VER) // VC++<br><br>#define <a href="#OTL_BIGINT">OTL_BIGINT</a> __int64<br><br>#define <a href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>(str,n)                \<br>{                                               \<br>  n=_atoi64(str);                               \<br>}<br><br>#define <a href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>(n,str)                \<br>{                                               \<br>  _i64toa(n,str,10);                            \<br>}<br>#endif<br>
</pre>
          <pre>
<br>
</pre>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON" id="OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON"></a><b>OTL_BIND_VAR<br>
        _STRICT_<br>
        TYPE_<br>
        CHECKING_ON</b>&nbsp;</font></td>

        <td style="vertical-align: top;">This #define enables "bind variable strict type checking", that is, typos in bind variable data type declarations get checked strictly. OTL, for performance, checks out as few characters as possible in a bind variable declaration, in order to recognize a legitimate data type declaration. Sometimes, it results in some parts of unrecognized declaration to be left as is, which, in its turn, causes a database runtime error, typically, an SQL statement parse error. In most cases, it's okay, no trouble whatsoever. In very rare cases, depending on a concrete release of a database API, on a specific platform, it causes a program core dump / crash.<br>
        <br>
        It is recommended to use this #define as part of the "Debug mode", in order to sort out errors of this kind. Then, when compiling in "Release mode", the #define could be dropped.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR" id="OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR"></a><b>OTL_DB2_CLI_<br>
        MAP_LONG_<br>
        VARCHAR_TO<br>
        _VARCHAR</b>.&nbsp;</font></td>

        <td style="vertical-align: top;">This #define works in a combination with #define <a href="otl3_compile.htm#OTL_DB2_CLI">OTL_DB2_CLI</a>. It should be used in the case of the DB2 CLI on the client side and the DB2 OS/390 on the server side, because all VARCHAR table columns that are &gt;= 255 bytes get reported by the DB2 CLI as SQL_LONG_VARCHARs (normally reserved for DB2 CLOB columns). In DB2 UDB distributed (non-OS/390 flavor), all VARCHARs get reported as DB2 CLI's SQL_VARCHARs. When #define OTL_DB2_MAP_LONG_VARCHAR_TO_VARCHAR is defined, all VARCHAR table colunms, which are shorter (&lt;=) than the value defined by the #define, get mapped to SQL_VARCHAR, even though the DB2 CLI reports the columns as SQL_LONG_VARCHARs. For example:<br>
        <br>
        <tt>#define OTL_DB2_CLI</tt><br>
        <tt>#define OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR 4000</tt><br>
        <tt>#include &lt;otlv4.h&gt;<br>
        <br></tt> In this example, all VARCHAR table columns, that are &lt;= 4000 bytes, will be mapped to SQL_VARCHAR, even though the client code connects to a DB2 OS/390 database, and the client DB2 CLI reports the columns as SQL_LONG_VARCHARs. This<br>
        kind of datatype mapping happens only on SELECT statements, or stored procedures that return a result set.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_DEFAULT_CHAR_NULL_TO_VAL" id="OTL_DEFAULT_CHAR_NULL_TO_VAL"></a><b>OTL_<br>
        DEFAULT<br>
        _CHAR_<br>
        NULL_TO_VAL</b></font></td>

        <td style="vertical-align: top;">When this #define is set to a char value, in the case of a NULL, returned from the database, OTL assigns the value to the variable that is used in operator&gt;&gt;(char&amp;), or in operator(unsigned char&amp;). At the same time, otl_stream::is_null() can be used to check for NULL. This default value is more of a convenience than necessity.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_DEFAULT_NUMERIC_NULL_TO_VAL" id="OTL_DEFAULT_NUMERIC_NULL_TO_VAL"></a><b>OTL_<br>
        DEFAULT<br>
        _NUMERIC_<br>
        NULL_TO_VAL</b></font></td>

        <td style="vertical-align: top;">When this #define is set to a numeric value, in the case of a NULL returned from the database, OTL assigns the value to the variable that is used in operator&gt;&gt;(numeric_type&amp;).&nbsp; At the same time, otl_stream::is_null() can be used to check for NULL. This default value is more of a convenience than necessity.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_DEFAULT_DATETIME_NULL_TO_VAL" id="OTL_DEFAULT_DATETIME_NULL_TO_VAL"></a><b>OTL_DEFAULT<br>
        _DATETIME<br>
        _NULL_TO_VAL&nbsp;</b></font></td>

        <td style="vertical-align: top;">When this #define is set to a value of otl_datetime datatype, in the case of a NULL, returned from the database, OTL assigns the value to to the variable that is used in operator&gt;&gt;(otl_datetime&amp;). At the same time, otl_stream::is_null() can be used to check for NULL. This default value is more of a convenience than necessity.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_DEFAULT_STRING_NULL_TO_VAL" id="OTL_DEFAULT_STRING_NULL_TO_VAL"></a><b>OTL_DEFAULT<br>
        _STRING<br>
        _NULL_TO_VAL</b><br></font></td>

        <td style="vertical-align: top;">When this #define is set to a string value, in the case of a NULL, returned from the database., OTL assigns the value to the variable that is used in operator&gt;&gt;(std::string&amp;), or in operator&gt;&gt;(ACE_TString&amp;), or in a string class, defined by #define USER_DEFINED_STRING_CLASS: opartor&gt;&gt;(USER_DEFINED_STRING_CLASS&amp;). Also, OTL assigns the value to the variable that is used in operator&gt;&gt;(char*), or in opartor&gt;&gt;(unsigned char*). At the same time, otl_stream::is_null() can be used to check for NULL. This default vaue is more of a convenience than necessity.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_DESTRUCTORS_DO_NOT_THROW" id="OTL_DESTRUCTORS_DO_NOT_THROW"></a><span style="font-weight: bold;">OTL_DESTRUCTORS_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">DO_NOT_THROW</span><br></td>

        <td style="vertical-align: top;">Top C++ experts say that "throwing destructors" are bad. OTL throws execptions from destructors by default in order to communicate database errors via otl_exceptions. OTL also makes the maximum effort (see #define <a href="#OTL_UNCAUGHT_EXCEPTION_ON">OTL_UNCAUGHT_EXCEPTION_ON</a> for more detail) to detect the stack unwinding situation and not to throw exceptions from destructors in that case, because that would result in an immediate program abort. #define OTL_DESTRUCTORS_DO_NOT_THROW enables try/catch blocks to prevent OTL destructors from throwing exceptions. See <a href="http://kolpackov.net/projects/c++/eh/dtor-1.xhtml">this</a> for more detail on the topic. It's strongly recommended, if you enable this #define, to make sure that every single
        instance of otl_connect, otl_stream, otl_lob_stream releases its underlying resources when it goes out of scope. In the worst case, information about a database error may be lost.<br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_DISABLE_OPERATOR_GT_GT_FOR_OTL_VALUE_OTL_DATETIME" id="OTL_DISABLE_OPERATOR_GT_GT_FOR_OTL_VALUE_OTL_DATETIME"></a>OTL_DISABLE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">OPERATOR_GT_GT_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">FOR_OTL_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">VALUE_OTL_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">DATETIME</span><br></td>

        <td style="vertical-align: top;">This #define disables the operator&lt;&lt;(ostream&amp;,const otl_value&lt;otl_datetime&gt;&amp;), so that the operator can be overloaded outside the OTL header file.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ENABLE_MSSQL_MARS" id="OTL_ENABLE_MSSQL_MARS"></a><span style="font-weight: bold;">OTL_ENABLE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">MSSQL_MARS</span><br></td>

        <td style="vertical-align: top;">MS SQL SQL 2005 and 2008 support the Multiple Active Result Sets (MARS), which is not enabled by default. In order for MARS to be enabled, an ODBC function call needs to be made. This #define enables the corresponding ODBC function call.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_EXCEPTION_IS_DERIVED_FROM_STD_EXCEPTION" id="OTL_EXCEPTION_IS_DERIVED_FROM_STD_EXCEPTION"></a><span style="font-weight: bold;">OTL_EXCEPTION_<br>
        IS_DERIVED_FROM_<br>
        STD_EXCEPTION</span><br></td>

        <td style="vertical-align: top;">This #define is a shortcut for the following:<br>
        <br>
        <span style="font-family: monospace;">#define <a href="#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM</a> std::exception</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#define <a href="#OTL_EXCEPTION_HAS_MEMBERS">OTL_EXCEPTION_HAS_MEMBERS</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; virtual const char* what() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reinterpret_cast&lt;const char*&gt;(msg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }<br></span><br style="font-family: monospace;">
        It means that <a href="otl3_exception_class.htm">otl_exception</a> is derived from std::exception.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_EXCEPTION_DERIVED_FROM" id="OTL_EXCEPTION_DERIVED_FROM"></a><b>OTL_EXCEPTION<br>
        _DERIVED_FROM</b>&nbsp;</font></td>

        <td style="vertical-align: top;">This #define allows the <a href="otl3_exception_class.htm">otl_exception</a> class to be included into already exsisting hierarchy of exception classes. The #define should specify a name of already existing class, which is used as part of the exception class hierarchy. The STL exception class hiararchy is a good example. otl_exception can be derived from one of the classes in the hierarchy, so that a catch block, that catches exception of the base class, will be able to catch exceptions of the otl_exception class. In the OTL header file, in case if this #define is defined, the class, defined in the #define, will be specified as a base class for the otl_exception class.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_EXCEPTION_ENABLE_ERROR_OFFSET" id="OTL_EXCEPTION_ENABLE_ERROR_OFFSET"></a>OTL_EXCEPTION_<br>
        ENABLE_<br>
        ERROR_<br>
        OFFSET</span></td>

        <td style="vertical-align: top;">This #define enables the so called SQL Statement Parse Error Offset, and it is available for OTL/OCIx only. When an otl_exception gets thrown, and it has otl_exception::stm_text field populated, the parse error offset will point to the actual position of the SQL error.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_EXCEPTION_HAS_MEMBERS" id="OTL_EXCEPTION_HAS_MEMBERS"></a><b>OTL_EXCEPTION<br>
        _HAS_MEMBERS</b></font></td>

        <td style="vertical-align: top;">This #define allows the user to define new member functions or data members in the <a href="otl3_exception_class.htm">otl_exception</a> class. The OTL header file checks out whether this #define is defined, and then the body of the #define gets included textually into the body of the otl_exception class. This simple technique allows the otl_exception class to have new members. This #define can be used in a combination with #define <a href="otl3_compile.htm#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM</a>.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_EXPLICIT_NAMESPACES" id="OTL_EXPLICIT_NAMESPACES"></a><b>OTL_EXPLICIT<br>
        _NAMESPACES</b><br></font></td>

        <td style="vertical-align: top;">(for turning on namespaces)</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_EXCEPTION_STM_TEXT_SIZE" id="OTL_EXCEPTION_STM_TEXT_SIZE"></a>OTL_EXCEPTION_<br>
        STM_TEXT_<br>
        SIZE</span><br></td>

        <td style="vertical-align: top;">This #define specifies a new size for the <a href="otl3_exception_class.htm">otl_exception</a>::<a href="otl3_exception_class.htm#stm_text">stm_text</a> buffer. By default, it's 2048 bytes, that is, the actual otl_exception will contain only 2047 first bytes of the SQL statement, associated with the exception. If more bytes of the SQL statement text is needed, the #define can come handy.This #define can be used in a combination with #define <a href="#OTL_EXCEPTION_ENABLE_ERROR_OFFSET">OTL_EXCEPTION_ENABLE_ERROR_OFFSET</a>, for example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_EXCEPTION_ENABLE_ERROR_OFFSET<br>
        #define OTL_EXCEPTION_STM_TEXT_SIZE 32767<br></span><br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_EXTENDED_EXCEPTION" id="OTL_EXTENDED_EXCEPTION"></a><b>OTL_EXTENDED<br>
        _EXCEPTION</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for enabling the otl_exception's <a href="otl3_exception_class.htm#EXTENDED">extended fields</a> for OTL/ODBC and OTL/DB2-CLI). This is for fixing problem <a href="otl3_prob.htm#prob47">47.</a></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><small><a name="OTL_TRACE_FORMAT_DATETIME" id="OTL_TRACE_FORMAT_DATETIME"></a>OTL_TRACE_FORMAT_<br>
        DATETIME<br></small><br>
        <small>OTL_TRACE_FORMAT_</small></span><small><br style="font-weight: bold;"></small> <span style="font-weight: bold;"><small>TZ_DATETIME</small><br></span></td>

        <td style="vertical-align: top;"><a href="#OTL_TRACE">OTL tracing</a> uses the US date format. In order to change the date format, say, to Year-Month-Day, the following two #defines need to be defined:<br>
        <br>
        <small><span style="font-family: monospace;">#define OTL_TRACE_FORMAT_TZ_DATETIME(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">s.year&lt;&lt;"-"&lt;&lt;s.month&lt;&lt;"-"&lt;&lt;s.day&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.hour&lt;&lt;":"&lt;&lt;s.minute&lt;&lt;":"&lt;&lt;s.second&lt;&lt;"."&lt;&lt;s.fraction&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.tz_hour&lt;&lt;":"&lt;&lt;s.tz_minute</span><br style="font-family: monospace;">
        <br style="font-family: monospace;">
        <span style="font-family: monospace;">#define OTL_TRACE_FORMAT_DATETIME(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;"></small><small><span style="font-family: monospace;">s.year&lt;&lt;"-"&lt;&lt;s.month&lt;&lt;"-"&lt;&lt;s.day</span></small><small><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.hour&lt;&lt;":"&lt;&lt;s.minute&lt;&lt;":"&lt;&lt;s.second&lt;&lt;"."&lt;&lt;s.fraction<br>
        <br></span></small> By default, OTL uses the US date format:<br>
        <br>
        <small><span style="font-family: monospace;">#define OTL_TRACE_FORMAT_TZ_DATETIME(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">s.month&lt;&lt;"/"&lt;&lt;s.day&lt;&lt;"/"&lt;&lt;s.year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.hour&lt;&lt;":"&lt;&lt;s.minute&lt;&lt;":"&lt;&lt;s.second&lt;&lt;"."&lt;&lt;s.fraction&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.tz_hour&lt;&lt;":"&lt;&lt;s.tz_minute</span><br style="font-family: monospace;">
        <br style="font-family: monospace;">
        <span style="font-family: monospace;">#define OTL_TRACE_FORMAT_DATETIME(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">s.month&lt;&lt;"/"&lt;&lt;s.day&lt;&lt;"/"&lt;&lt;s.year&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&lt;&lt;" "&lt;&lt;s.hour&lt;&lt;":"&lt;&lt;s.minute&lt;&lt;":"&lt;&lt;s.second&lt;&lt;"."&lt;&lt;s.fraction<br>
        <br></span></small> It is sufficient to overload operator&lt;&lt;(ostream&amp;, const otl_datetime&amp;) and use it in the #define's above. However,<br>
        some projects that use OTL tracing developed their own stream bridge classes, which are used with OTL tracing. In the case of such a stream bridge class, operator&lt;&lt;(stream_bridge_class&amp;, const otl_datetime&amp;) can be overloaded and used, for example:<br>
        <br>
        <small><span style="font-family: monospace;">#define OTL_TRACE_FORMAT_TZ_DATETIME(s) s</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#define OTL_TRACE_FORMAT_DATETIME(s) s</span></small><br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_ALTERNATE_RPC" id="OTL_ODBC_ALTERNATE_RPC"></a>OTL_ODBC_<br>
        ALTERNATE_<br>
        RPC</span><br></td>

        <td style="vertical-align: top;">This #define should be used with the PostgreSQL ODBC driver. The driver returns as many row counts via SQLRowCount() calls as there are rows in a batch INSERT statement. The #define enables a loop that fetches all individual row counts and sums them up (+=). As a result, otl_stream::get_rpc() returns the total, which is correct for PostgreSQL. Normally, commercially available ODBC drivers return a single row count on a batch INSERT.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ODBC_LOGOFF_FREES_HANDLES" id="OTL_ODBC_LOGOFF_FREES_HANDLES"></a><span style="font-weight: bold;">OTL_ODBC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">LOGOFF_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">FREES_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">HANDLES</span><br></td>

        <td style="vertical-align: top;">Some ODBC drivers can't reuse underlying ODBC connect related resources. In order for OTL to fully recover from a database failure, the resources need to be released and new resources need to be allocated for otl_connect objects to work. Some versions of the Oracle ODBC driver for Oracle show that type behavior. This #define forces otl_connect::logoff() to the ODBC connect resources so that the next call to otl_connect::rlogon() would allocate the resources again.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_STRING_TO_TIMESTAMP" id="OTL_ODBC_STRING_TO_TIMESTAMP"></a>OTL_ODBC_<br>
        STRING_TO_<br>
        TIMESTAMP</span><br></td>

        <td style="vertical-align: top;">
          This #define defines conversion from the string/varchar format to the timestamp format (<a href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>), for example, PostgreSQL's timestamps with time zone, or MS SQL Server 2008's datetimeoffset(7):<br>
          <br>
          for PostgreSQL:<br>
          <pre>
#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)            \<br>{                                                       \<br>  sscanf(str,                                           \<br>         "%04d-%02d-%02d %02d:%02d:%02d.%06ld%hd",      \<br>         &amp;tm.year,                                      \<br>         &amp;tm.month,                                     \<br>         &amp;tm.day,                                       \<br>         &amp;tm.hour,                                      \<br>         &amp;tm.minute,                                    \<br>         &amp;tm.second,                                    \<br>         &amp;tm.fraction,                                  \<br>         &amp;tm.tz_hour);                                  \<br>}<br><br>
</pre>for PostgreSQL and #define OTL_UNICODE:<br>
          <br>
          <pre>
#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)            \<br>{                                                       \<br>  swscanf(str,                                          \<br>         L"%04d-%02d-%02d %02d:%02d:%02d.%06ld%hd",     \<br>         &amp;tm.year,                                      \<br>         &amp;tm.month,                                     \<br>         &amp;tm.day,                                       \<br>         &amp;tm.hour,                                      \<br>         &amp;tm.minute,                                    \<br>         &amp;tm.second,                                    \<br>         &amp;tm.fraction,                                  \<br>         &amp;tm.tz_hour);                                  \<br>}<br>
</pre><br>
          <br>
          for MS SQL 2008:<br>
          <pre>
#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)              \<br>{                                                         \<br>  sscanf(str,                                             \<br>           "%04d-%02d-%02d %02d:%02d:%02d.%07ld %hd:%hd", \<br>           &amp;tm.year,                                      \<br>           &amp;tm.month,                                     \<br>           &amp;tm.day,                                       \<br>           &amp;tm.hour,                                      \<br>           &amp;tm.minute,                                    \<br>           &amp;tm.second,                                    \<br>           &amp;tm.fraction,                                  \<br>           &amp;tm.tz_hour,                                   \<br>           &amp;tm.tz_minute);                                \<br>}<br><br>
</pre>for MS SQL 2008 and #define OTL_UNICODE<br>
          <br>
          <pre>
#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)              \<br>{                                                         \<br>  swscanf(str,                                            \<br>           L"%04d-%02d-%02d %02d:%02d:%02d.%07ld %hd:%hd",\<br>           &amp;tm.year,                                      \<br>           &amp;tm.month,                                     \<br>           &amp;tm.day,                                       \<br>           &amp;tm.hour,                                      \<br>           &amp;tm.minute,                                    \<br>           &amp;tm.second,                                    \<br>           &amp;tm.fraction,                                  \<br>           &amp;tm.tz_hour,                                   \<br>           &amp;tm.tz_minute);                                \<br>}
</pre>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_SQL_STATEMENT_WITH_DIAG_REC_OUTPUT" id="OTL_ODBC_SQL_STATEMENT_WITH_DIAG_REC_OUTPUT"></a>OTL_ODBC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">SQL_STATEMENT_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">WITH_DIAG_REC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">OUTPUT</span><br></td>

        <td style="vertical-align: top;">Some MS SQL Server <a href="http://msdn.microsoft.com/en-us/library/aa216157%28SQL.80%29.aspx">commands</a> (like BACKUP, DBCC, etc.) don't use result sets to communicate their output. They use diagnostic record format instead. Microsoft recommends to use SQLExecDirect() instead of SQLPrepare + SQLExecute with such commands. Also, such commands take time to execute. However, some of the commands return control back from the SQLExecDirect() call right away. For example, BACKUP does that. For the BACKUP to successfully finish, it requires for the statement handle to be valid. Therefore the OTL <span style="font-style: italic;">direct exec</span> <a href="otl3_const_sql.htm">functions</a> can't be used. In order to work around this limitation, the
        otl_stream class was extended to execute MS SQL Server's BACKUP, DBCC, etc., commands. This #define is needed for the otl_stream class to recognize these commands. This #define specifies a function that accepts an SQL statement text, and returns true, if one of the commands is recognized, for example:<br>
        <br>
        <small><span style="font-family: monospace;">inline bool sql_statement_with_diag_rec_output(const char* stm_text)<br>
        {<br>
        &nbsp; if(strncmp(stm_text,"BACKUP",6)==0)<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp; else if(strncmp(stm_text,"DBCC",4)==0)<br>
        &nbsp;&nbsp;&nbsp; return true;<br>
        &nbsp; else<br>
        &nbsp;&nbsp;&nbsp; return false;<br>
        }<br>
        <br>
        #define OTL_ODBC_SQL_STATEMENT_WITH_DIAG_REC_OUTPUT \<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql_statement_with_diag_rec_output<br></span></small><br>
        Also, see otl_stream:::get_next_diag_rec() function, and examples <a href="otl4_ex688.htm">688</a>, <a href="otl4_ex689.htm">689</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ODBC_TIMESTAMP_TO_STRING" id="OTL_ODBC_TIMESTAMP_TO_STRING"></a>OTL_ODBC_<br>
        TIMESTAMP_<br>
        TO_STRING</span><br></td>

        <td style="vertical-align: top;">
          This #define defines conversion the timestamp format (<a href="file:///D%7C/oscl/vc/doc/otl4/otl3_stream_class.htm#otl_datetime">otl_datetime</a>) to the string/varchar format, for example, PostgreSQL's timestamp with time zone, or MS SQL Server 2008's datetimeoffset(7):<br>
          <br>
          for PostgreSQL:<br>
          <pre>
#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)            \<br>{                                                       \<br>  sprintf(str,                                          \<br>         "%04d-%02d-%02d %02d:%02d:%02d.%06ld %+hd",    \<br>          tm.year,                                      \<br>          tm.month,                                     \<br>          tm.day,                                       \<br>          tm.hour,                                      \<br>          tm.minute,                                    \<br>          tm.second,                                    \<br>          tm.fraction,                                  \<br>          tm.tz_hour);                                  \<br>}<br><br><br>
</pre>for PostgreSQL and #define OTL_UNICODE:<br>
          <pre>
#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)             \<br>{                                                        \<br>  swprintf(str,                                          \<br>           L"%04d-%02d-%02d %02d:%02d:%02d.%06ld %+hd",  \<br>           tm.year,                                      \<br>           tm.month,                                     \<br>           tm.day,                                       \<br>           tm.hour,                                      \<br>           tm.minute,                                    \<br>           tm.second,                                    \<br>           tm.fraction,                                  \<br>           tm.tz_hour);                                  \<br>}<br><br>
</pre>for MS SQL 2008:<br>
          <pre>
#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)                    \<br>{                                                               \<br>  sprintf(str,                                                  \<br>            "%04d-%02d-%02d %02d:%02d:%02d.%07ld %+hd:%hd",     \<br>            tm.year,                                            \<br>            tm.month,                                           \<br>            tm.day,                                             \<br>            tm.hour,                                            \<br>            tm.minute,                                          \<br>            tm.second,                                          \<br>            tm.fraction,                                        \<br>            tm.tz_hour,                                         \<br>            tm.tz_minute);                                      \<br>}<br><br><br>
</pre>

          <p>for MS SQL 2008 and #define OTL_UNICODE:<br></p>
          <pre>
#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)                    \<br>{                                                               \<br>  swprintf(str,                                                 \<br>           L"%04d-%02d-%02d %02d:%02d:%02d.%07ld %+hd:%hd",     \<br>           tm.year,                                             \<br>           tm.month,                                            \ <br>           tm.day,                                              \<br>           tm.hour,                                             \<br>           tm.minute,                                           \<br>           tm.second,                                           \<br>           tm.fraction,                                         \<br>           tm.tz_hour,                                          \<br>           tm.tz_minute);                                       \<br>}<br>
</pre>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top; font-weight: bold;"><a name="OTL_ODBC_TIME_ZONE" id="OTL_ODBC_TIME_ZONE"></a>OTL_ODBC_<br>
        TIME_ZONE<br></td>

        <td style="vertical-align: top;">This #define enables tz_hour, and tz_minute fields in the <a href="otl3_stream_class.htm#otl_datetime">otl_datetime</a> class. ODBC doesn't support the time zone components yet, so this #define needs to be used with #define <a href="#OTL_ODBC_STRING_TO_TIMESTAMP">OTL_ODBC_STRING_TO_TIMESTAMP</a> and #define <a href="#OTL_ODBC_TIMESTAMP_TO_STRING">OTL_ODBC_TIMESTAMP_TO_STRING</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_FREETDS_ODBC_WORKAROUNDS" id="OTL_FREETDS_ODBC_WORKAROUNDS"></a>OTL_FREETDS_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">ODBC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">WORKAROUNDS</span><br></td>

        <td style="vertical-align: top;">FreeTDS/ODBC doesn't seem to implement the database session's "auto-commit off" mode, so otl_connect's <a href="otl3_connect_class.htm#rlogon">auto_commit</a>&nbsp; has no effect. In order to work around this deficiency, this #define should be used. When the #define is enabled, OTL executes "begin transaction" statement before each transaction. otl_connect::commit() or otl_connect::rollback() can be used to commit or roll back the transaction. When FreeTDS/ODBC implements the database session's "auto-commit off" mode, the #define could be safely removed, because the otl_connect's auto-commit parameter would take effect on the database sessions. For the time being, this #define is recommended for use with FreeTDS/ODBC against MS SQL.
        otl_connect::<a href="otl3_connect_class.htm#auto_commit_on">auto_commit_on</a>() / otl_connect::<a href="otl3_connect_class.htm#auto_commit_off">auto_commit_off</a>() functions don't work for MS SQL with FreeTDS/ODBC. Until a fix becomes available, it's not recommended to use them.<br>
        <br>
        Sybase is slightly d<span style="font-weight: bold;">i</span>fferent: otl_connect::<a href="otl3_connect_class.htm#auto_commit_on">auto_commit_on</a>() / otl_connect::<a href="otl3_connect_class.htm#auto_commit_off">auto_commit_off</a>() functions seem to work even though the otl_connect::rlogon()'s auto_commit doesn't work. After rlogon() has been called, it's recommended to call auto_commit_off(). See <a href="otl4_sybsql_freetds_examples.htm">Sybase SQL Server / FreeTDS ODBC</a> examples for more detail.<br>
        <br>
        In FreeTDS/ODBC, the default for the database session's auto-commit mode is "auto-commit ON", which can't be turned off or on again. When #define OTL_FREETDS_ODBC_WORKAROUNDS is enabled, OTL emulates the database session's "auto-commit off" mode by executing "begin transaction" at the beginning of each transaction, and not executing anything when the "auto-commit" is set to ON, which is the default in FreeTDS/ODBC.<br>
        &nbsp;<br>
        Also, FreeTDS/ODBC doesn't support "transaction isolation" level, that is, otl_connect::<a href="otl3_connect_class.htm#set_transaction_isolation_level">set_transaction_isolation_level</a>() has no effect. Until the feature is implemented in FreeTDS/ODBC, it's recommended that explicit server side settings should be used instead. For example, MS SQL supports an explicit (NOLOCK) option on the FROM clause in a SELECT statement. Sybase has the "set transaction isolation level X" command to set an explicit, session-wide transaction isolation level.<span style="font-family: monospace;"><br></span><br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_MAP_SQL_GUID_TO_CHAR" id="OTL_MAP_SQL_GUID_TO_CHAR"></a>OTL_MAP_<br>
        SQL_GUID_<br>
        TO_CHAR</span><br></td>

        <td style="vertical-align: top;">Before OTL 4.0.140, MS SQL GUIDs (uniqueidentifier) were mapped to char[XXX]. OTL 4.0.140 and higher&nbsp; maps the GUIDs to <a href="otl3_bind_variables.htm#raw">raw</a>[16], This #define should be used to map GUIDs to char[XXX] by default. Of course, the new default mapping can be overridden manually Also, see example <a href="otl3_ex105.htm">105</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_MAP_SQL_BINARY_TO_CHAR" id="OTL_MAP_SQL_BINARY_TO_CHAR"></a>OTL_MAP_<br>
        SQL_BINARY_<br>
        TO_CHAR</span><br></td>

        <td style="vertical-align: top;">Before OTL 4.0.140, MS SQL TIMESTAMPs were mapped to char[XXX], which was effectively a conversion from the binary format to the hexadecimal string format. OTL 4.0.140 and higher maps MS SQL TIMESTAMPs to <a href="otl3_bind_variables.htm#raw">raw</a>[XXX]. This #define should be used to map MS SQL TIMESTAMPs to&nbsp; the hexadecimal string format by default. Of course, the new default mapping can be overridden manually.&nbsp;</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_MAP_SQL_VARBINARY_TO_RAW_LONG" id="OTL_MAP_SQL_VARBINARY_TO_RAW_LONG"></a>OTL_MAP_<br>
        SQL_VARBINARY_<br>
        TO_RAW_LONG</span><br></td>

        <td style="vertical-align: top;">Before OTL 4.0.140,, "<a href="otl3_bind_variables.htm#raw">binary</a>" database types were mapped to <a href="otl3_bind_variables.htm#raw_log">raw_long</a>. OTL 4.0.140 and higher maps the "binary" types to <a href="otl3_bind_variables.htm#raw">raw</a>[XXX]&nbsp; This #define should be used to map the binary types to raw_long by default. Of course, the new default mapping can be overridden manually.&nbsp; Also, see example <a href="otl4_ex346.htm">346</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE" id="OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE"></a>OTL_STREAM_<br>
        LEGACY_<br>
        BUFFER_<br>
        SIZE_TYPE</span><br></td>

        <td style="vertical-align: top;">OTL 4.0.115 introduces a larger data type for the OTL stream <a href="otl3_stream_class.htm#buffer_size">buffer size</a>: <span style="font-style: italic;">int</span> instead of the old <span style="font-style: italic;">short int</span>. The buffer size parameter was short int for a long time to keep all OTL based code compatible with older database APIs (like original OCI7, or restrictions on some old ODBC drivers), and portable across platforms / databases. Now is time to move on. "int" as a datatype for the buffer size provides a much wider value range. "int" is the default for the OTL stream buffer size parameter from OTL 4.0.115 and on. However, those old, legacy applications based on OTL cannot be left behind. This #define, when enabled,
        turns the old "short int" type for the buffer size back on.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_FUNC_THROW_SPEC_ON" id="OTL_FUNC_THROW_SPEC_ON"></a><b>OTL_FUNC<br>
        _THROW_SPEC_ON</b>&nbsp;</font></td>

        <td style="vertical-align: top;">This #define works in a combination with #define <a href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a> (when OTL_ANSI_CPP is defined). This #define enables the <i>function throw specification clause</i> (introduced in OTL 4.0.50) in all OTL functions, to make them explicitly declare what type C++ exceptions the function may throw. It looks like there is no consesus in the C++ community whether function throw specs are good or not, and I decided to make it up to each OTL user to whether enable or not enable this OTL feature&nbsp; by introducing this #define.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_LEGACY_NUMERIC_TYPES" id="OTL_ORA_LEGACY_NUMERIC_TYPES"></a>OTL_ORA_<br>
        LEGACY_<br>
        NUMERIC_TYPES</span><br></td>

        <td style="vertical-align: top;">This #define should be used in a combination with #define <a href="#OTL_ORA10G">OTL_ORA10G,</a> or <a href="#OTL_ORA10G_R2">OTL_ORA10G_R2,</a> or <a href="#OTL_ORA11G">OTL_ORA11G</a>. It disables the use of OCI10 native SQLT_BDOUBLE / SQLT_BFLOAT bindings, and reverts to <code>SQLT_FLT</code> bindings, which are compatible with older versions of the OCI. This define can be enabled when the Oracle Client 10g, or 11g is used against older versions of the Oracle server, say, Oracle 9.2. When the OCI10 native SQLT_BDOUBLE / SQLT_BFLOAT bindings are used via the Oracle 10 Client with, say, Oracle 9i database back end, the bindings don't work, because the Oracle 9i server doesn't support them.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ORA_MAP_BIGINT_TO_LONG" id="OTL_ORA_MAP_BIGINT_TO_LONG"></a><span style="font-weight: bold;">OTL_ORA_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">MAP_BIGINT_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">TO_LONG</span><br></td>

        <td style="vertical-align: top;">This #define enables the mapping from &lt;<a href="otl3_bind_variables.htm#bigint">bigint</a>&gt; for 64-bit OCIs for LP64 platforms to signed 64-bit longs. It's a more efficient alternative to the char[XXX] binding and bigint-string / string-bigint conversion (see also the following #define's: <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>,&nbsp; <a href="otl3_compile.htm#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR,</a>&nbsp;&nbsp; <a href="otl3_compile.htm#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>).<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_MAP_LONG_TO_SQL_C_SBIGINT" id="OTL_MAP_LONG_TO_SQL_C_SBIGINT"></a>OTL_MAP_<br>
        LONG_TO_<br>
        SQL_C_SBIGINT</span><br></td>

        <td style="vertical-align: top;">In the ODBC/DB2 CLI standard, SQL_C_SLONG contains 32 bits regardless of the size of "long int" on a given 64-bit platform. Similarly, SQL_C_SBIGINT is a signed 64-bit integer, regardless of whether the platform is 32-bit or 64-bit. ODBC drivers have different implementations of SQL_C_SLONG, meaning that some ODBC drivers deviate from the standard. OTL tries to cover all implementations of the SQL_C_SLONG. This #define maps "long" (in bind variable declarations) into SQL_C_SBIGINT in case if sizeof(long) == 8. For example, <span style="font-family: monospace;">:v1&lt;long&gt;</span> will be mapped to SQL_C_SBIGINT, which is a signed 64-bit integer.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_NO_TMPL_MEMBER_FUNC_SUPPORT" id="OTL_NO_TMPL_MEMBER_FUNC_SUPPORT"></a>OTL_NO_TMPL_<br>
        MEMBER_<br>
        FUNC_<br>
        SUPPORT</span><br></td>

        <td style="vertical-align: top;">OTL 4.0.127 or higher tries to use template member functions for implementing operator &gt;&gt;/&lt;&lt; for numeric data types (int, unsigned, short, long, float, double, signed 64-bit int) for C++ compilers that have support for the feature.&nbsp; However, even after so many years since the C++ standard was adopted back in the summer of 1998, some C++ compilers either still have bugs in their support of the feature, or are missing any support completely. If that happens, it's possible to make OTL fall back on the old proven plain nontemplate member functions. This #define can be used to do just that.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_SUBSCRIBE" id="OTL_ORA_SUBSCRIBE"></a>OTL_ORA_<br>
        SUBSCRIBE</span><br></td>

        <td style="vertical-align: top;">
          This #define enables the <a href="otl4_subscriber.htm">otl_subscriber</a> class. The class is Oracle 9/10 (or higher) specific. It uses the Oracle Change Notification OCI functions, which allow the user to get notified about changes on database tables of interest. This feature is especially useful in an Oracle RAC environment, though the interface works in a stand alone Oracle instance. When #define OTL_ORA_SUBSCRIBE is enabled, the following #define's need to enabled as well:<br>
          <pre>
#define OTL_ORA_OCI_ENV_CREATE<br>#define OTL_ORA_OCI_ENV_CREATE_MODE (OCI_THREADED|OCI_OBJECT|OCI_EVENTS)<br>
</pre>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_UTF8" id="OTL_ORA_UTF8"></a>OTL_ORA_UTF8</span><br></td>

        <td style="vertical-align: top;">This #define enables OCI9i/10g support for Oracle UTF8 character encodings (UTF8, AL32UTF8). This #define is mutually exclusive with #define <a href="#OTL_UNICODE">OTL_UNICODE</a>, which supports UTF-16. UTF-8 seems to be more popular <big>with Oracle C++ <small>developers at least in Linux/Unix. The basic difference between UTF-8 and UTF-16 is that UTF-8 is byte oriented. It's okay to use a '\0' terminated array of unsigned chars with UTF-8 as opposed to an array of unsigned 16-bit integers with UTF-16.</small></big><br></td>
      </tr>

      <tr style="font-weight: bold;">
        <td style="vertical-align: top;"><a name="OTL_ORA7_STRING_TO_TIMESTAMP" id="OTL_ORA7_STRING_TO_TIMESTAMP"></a>OTL_ORA7_<br>
        STRING_TO_<br>
        TIMESTAMP<br></td>

        <td style="vertical-align: top;"><span style="font-weight: normal;">OCI7 is still important even when used against Oracle 9i or Oracle 10g. In fact, OCI7 is supported by all Oracle Clients with no exception, and it is called the <span style="font-style: italic;">classic OCI</span>. In addition to DATE, Oracle 9i introduced TIMESTAMP as a new temporal data type which supports fractional parts of the second: milliseconds, microseconds, etc. Sometimes, there is a need to use TIMESTAMPs and OCI7 together in order to enhance legacy applications. This #define makes the use of TIMESTAMPs transparaent through OCI7. For example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_ORA7 // Compile OTL 4.0/OCI7</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#define <a href="#OTL_ORA7_TIMESTAMP_TO_STRING">OTL_ORA7_TIMESTAMP_TO_STRING</a>(tm,s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; sprintf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%02d/%02d/%04d %02d:%02d:%02d.%06ld",\</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">}</span><br style="font-family: monospace;">
        <br style="font-family: monospace;">
        <span style="font-family: monospace;">#define <a href="#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>(s,tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; sscanf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%02d/%02d/%04d %02d:%02d:%02d.%06ld", \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">}</span><br style="font-family: monospace;">
        <br>
        #define</span> <big><big><span style="font-weight: normal;"><small><small>OTL_ORA7_STRING_TO_TIMESTAMP and #define</small></small></span> <span style="font-weight: normal;"><small><small>OTL_ORA7_TIMESTAMP_TO_STRING should be used together as shown in the example above. These #defines define string-to-timestamp and timestamp-to-string conversion so that operator&lt;&lt;/&gt;&gt;(otl_datetime&amp;) can be used transparently with :var&lt;char[XXX]&gt; bind variables. Also, see example <a href="otl4_ex473.htm">473</a>.<br>
        <br>
        Oracle 10g seems to have a bug that when #define <a href="#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> is enabled, it takes much more time than usual to retrieve timestamp values from a table. The same bug was reported with the Oracle 10g JDBC driver, so it may be a deficiency in the Oracle network protocol. #define OTL_ORA7_TIMESTAMP_TO_STRING and #define OTL_ORA7_STRING_TO_TIMESTAMP are supported for OTL/ORA8,8i,9i,10g,11g, and can be used as a workaround for the Oracle network protocol deficiency. Under #define <a href="#OTL_UNICODE">OTL_UNICODE</a>,</small></small></span></big></big> <span style="font-weight: normal;">the following</span> <big><big><span style=
        "font-weight: normal;"><small><small>OTL_ORA7_STRING_TO_TIMESTAMP/</small></small></span></big></big><big><big><span style="font-weight: normal;"><small><small>OTL_ORA7_TIMESTAMP</small></small></span></big></big><span style="font-weight: normal;">_TO_STRING can be used:<br>
        <br></span> <span style="font-weight: normal;"><span style="font-family: monospace;">#define <a href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA7_TIMESTAMP_TO_STRING">OTL_ORA7_TIMESTAMP_TO_STRING</a>(tm,s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; swprintf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"%02d/%02d/%04d %02d:%02d:%02d.%06ld",\</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">}</span><br style="font-family: monospace;">
        <br style="font-family: monospace;">
        <span style="font-family: monospace;">#define <a href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>(s,tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; swscanf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"%02d/%02d/%04d %02d:%02d:%02d.%06ld", \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">}</span><br style="font-family: monospace;"></span><br>
        <a style="font-weight: normal;" href="#OTL_UNICODE"></a><big><big><span style="font-weight: normal;"><small><small><br></small></small></span></big></big> <span style="font-weight: normal;"><br></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a style="font-weight: bold;" name="OTL_ORA7_TIMESTAMP_TO_STRING" id="OTL_ORA7_TIMESTAMP_TO_STRING"></a><span style="font-weight: bold;">OTL_ORA7_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">TIMESTAMP_TO_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">STRING</span><br></td>

        <td style="vertical-align: top;">This #define should be used together with #define <span style="font-weight: normal;"><small><small><a href="#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>.</small></small></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_MAP_STRINGS_TO_CHARZ" id="OTL_ORA_MAP_STRINGS_TO_CHARZ"></a>OTL_ORA_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">MAP_STRINGS_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">TO_CHARZ</span><br></td>

        <td style="vertical-align: top;">OTL normally binds a variable size string buffer (host variable) with both VARCHAR() and CHAR() columns. ODBC and DB2 CLI handle variable size vs padded string comparison semantic correctly for both types of string columns. OCIx do that a little bit differently. So, when OTL/OCIx is used with CHAR() columns, if, say, a WHERE clause has a char[XXX] bind variable, the actual strings for the WHERE clause need to be padded to the full length of the CHAR() columns. #define OTL_ORA_MAP_STRINGS_TO_CHARZ changes the OTL default binding of string host variables. When the #define is enabled, OTL makes "CHARZ" type string bindings, which behaves exactly the same as ODBC / DB2 CLI. However, this type of string binding has a slightly higher runtime overhead.
        It's up to the database developer to make the right decision on balancing out performance vs protability / readability of the source code.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top; font-weight: bold;"><a name="OTL_ORA_MAX_UNICODE_VARCHAR_SIZE" id="OTL_ORA_MAX_UNICODE_VARCHAR_SIZE"></a>OTL_ORA_<br>
        MAX_UNICODE_<br>
        VARCHAR_<br>
        SIZE</td>

        <td style="vertical-align: top;">When <a href="#OTL_UNICODE">OTL_UNICODE</a>, <a href="#OTL_ORA8I">OTL_ORA8I</a> / <a href="#OTL_ORA9I">OTL_ORA9I</a> are enabled, and the stream is instantiated with a SELECT statement that has two (or more) large VARCHAR2(4000), or NVARCHAR2(2000), Oracle may generate the following error: ORA-01461 (Invalid length...). The error has to do with the fact that Oracle (8i/9i) treats large VARCHAR2s / NVARCHAR2s as LONGs, which means that there may be only one large VARCHAR2 / NVARCHAR2 in a SELECT statement. The only workaround that Oracle Corporation recommends for Oracle 8i/9i is that the size of&nbsp; large VARCHAR2s/NVARCHAR2s on a SELECT statement needs to be limited to 4000 bytes. For PL/SQL block that have large VARCHAR2/NVARCHAR2 the
        workaround doesn't apply, that is, there is no such error, simply because PL/SQL treats large strings differently. #define OTL_ORA_MAX_UNICODE_VARCHAR_SIZE implements the workaround:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNICODE<br>
        #define OTL_ORA8I<br>
        //#define OTL_ORA9I<br>
        int my_max_unicode_varchar_string_size=32000;<br>
        &nbsp; // in bytes, the number is not precise,<br>
        &nbsp; // the actual maximum may be higher<br>
        #define OTL_ORA_MAX_UNICODE_VARCHAR_SIZE (</span><span style="font-family: monospace;">my_max_unicode_varchar_string_size)</span><br>
        <span style="font-family: monospace;">#include &lt;otlv4.h&gt;<br>
        ...<br></span> <span style="font-family: monospace;">&nbsp; my_max_unicode_varchar_string_size=32000; // in bytes<br>
        &nbsp; otl_stream o(...); // PL/SQL block that has large VARCHAR/NVARCHAR strings<br>
        ...<br></span> <span style="font-family: monospace;">&nbsp; my_max_unicode_varchar_string_size=4000; // in bytes<br>
        &nbsp; otl_stream s(...); // SELECT statement that has two or more large VARCHAR2/NVARCHAR2 strings<br></span> <span style="font-family: monospace;">&nbsp; my_max_unicode_varchar_string_size=32000; // in bytes<br>
        ...<br>
        <br></span> All of the above is NOT needed under #define OTL_ORA10G / OTL_ORA10G_R2, or when there is no more than one large VARCHAR2/NVARCHAR2 in the same SELECT. Sorry for this complicated stuff: a compliacted bug requires a kludgy fix. The workaround is not needed for Oracle 10g because Oracle 10g changed the architecture, compared with Oracle 9i in how large Unicode VARCHAR2 / NVARCHAR2 are handled inside the Oracle Client / Server.<br>
        <br>
        <br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_OCI_ENV_CREATE" id="OTL_ORA_OCI_ENV_CREATE"></a>OTL_ORA_<br>
        OCI_ENV_<br>
        CREATE</span><br></td>

        <td style="vertical-align: top;">This #define can only be used when one of the following is defined: <a href="#OTL_ORA8I">OTL_ORA8I</a>, <a href="#OTL_ORA9I">OTL_ORA9I</a>, <a href="#OTL_ORA10G">OTL_ORA10G</a>, <a href="#OTL_ORA10G_R2">OTL_ORA10G_R2</a>. The #define enables OCI Environment Handle initialization via OCIEnvCreate() instead of the older OCIInitialize() + OCIEnvInit() scheme. I don't want to go too deep into the discussion of what works, and what doesn't work. Those who want to use OCIEnvCreate(), be my guests.<br>
        <br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_OCI_ENV_CREATE_MODE" id="OTL_ORA_OCI_ENV_CREATE_MODE"></a>OTL_ORA_<br>
        OCI_ENV_<br>
        CREATE_<br>
        MODE</span><br></td>

        <td style="vertical-align: top;">This define should be used in a combination with #define <a href="#OTL_ORA_OCI_ENV_CREATE">OTL_ORA_OCI_ENV_CREATE</a>. When OTL_ORA_OCI_ENV_CREATE_MODE is defined, it overrides the mode (OCI_DEFAULT/OCI_THREADED) in which OCI environment handles will be created. For example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_ORA_OCI_ENV_CREATE</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#define OTL_ORA_OCI_ENV_CREATE_MODE OCI_THREADED</span><br style="font-family: monospace;">
        <br>
        The problem that this #define is trying to address is that the "default/threaded" mode was passed into otl_connect::otl_initialize() once in the whole program, instead of having to pass the same parameter into all calls to otl_connect::<a href="otl3_connect_class.htm#rlogon_xa">rlogon</a>() or <a href="otl3_connect_class.htm#server_attach">server_attach(</a>). When this #define is enabled, it overrides everything else, so that the custom code wouldn't have to be changed.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_STREAM_NO_PRIVATE_BOOL_OPERATORS" id="OTL_STREAM_NO_PRIVATE_BOOL_OPERATORS"></a>OTL_STREAM_<br>
        NO_PRIVATE_<br>
        BOOL_<br>
        OPERATORS</span><br></td>

        <td style="vertical-align: top;">By default, OTL makes otl_stream::operator&gt;&gt;(bool&amp;) and operator&lt;&lt;(const bool) private because they are not implemented, and in some cases it is very confusing when the C++ compiler use a different operator, say, instead of operator&gt;&gt;(bool&amp;) . It makes it harder to track down bugs in the code at runtime.&nbsp; By making the operators private,&nbsp; the runtime bugs of that sort become more obvious at compile time. However, there may be legitimate use cases when there is a need to overload operator&gt;&gt;(bool&amp;) and operator&lt;&lt;(const bool). This #define, when enabled, prevents OTL from declaring private operator&gt;&gt;(bool&amp;) and operator&lt;&lt;(const bool) in the otl_stream class.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_STREAM_NO_PRIVATE_UNSIGNED_LONG_OPERATORS" id="OTL_STREAM_NO_PRIVATE_UNSIGNED_LONG_OPERATORS"></a>OTL_STREAM_<br>
        NO_PRIVATE_<br>
        UNSIGNED_<br>
        LONG_<br>
        OPERATORS</span><br></td>

        <td style="vertical-align: top;">By default, OTL makes otl_stream::operator&gt;&gt;(unsigned long&amp;) and operator&lt;&lt;(const unsigned long) private because they are not implemented, and in some cases it is very confusing when the C++ compiler use a different operator, say, instead of operator&gt;&gt;(unsigned long&amp;). It makes it harder to track down bugs in the code at runtime.&nbsp; By making the operators private,&nbsp; the runtime bugs of that sort become more obvious at compile time. However, there may be legitimate use cases when there is a need to overload operator&gt;&gt;(unsigned long&amp;) and operator&lt;&lt;(const unsigned long). This #define, when enabled, prevents OTL from declaring private operator&gt;&gt;(unsigned long&amp;) and operator&lt;&lt;(const
        unsigned long) in the otl_stream class.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT" id="OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT"></a>OTL_STRICT_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">NUMERIC_TYPE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">CHECK_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">ON_SELECT</span><br></td>

        <td style="vertical-align: top;">By default on an SELECT statement, or a stored procedure that returns an implcit result set (ODBC, DB2 CLI) / a reference cursor (PL/SQL), OTL tries to describe the [SELECT] output columns, and map internal datatypes to external C++ datatypes.&nbsp; In the case of internal numeric datatypes, the corresponding external C++ datatypes may not have exactly the same domain as the internal datatypes. And, say, the values are being read into a variable of a third numeric datatype. In this case OTL has to convert the values from one numeric datatype to another. This #define (OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT) enforces the exact match between the output variable's datatype that's the internal numeric value is being read into, and the datatype of the
        internal value itself.<br>
        <br>
        In some cases, as it was mentioned in the previous paragraph, the internal-to-external numeric datatype mapping is not exact. In those case, the numeric [SELECT] column's datatype may be explicitly <a href="otl3_bind_variables.htm#SELECT_OVERRIDE">overriden</a> to ensure the exact match between the internal and the external datatypes. Also, if the external and internal datatypes match exactly, OTL provides a small performance boost by avoiding any numeric datatype conversion.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ODBC_SQL_EXTENDED_FETCH_ON" id="OTL_ODBC_SQL_EXTENDED_FETCH_ON"></a><b>OTL_ODBC_SQL<br>
        _EXTENDED<br>
        _FETCH_ON</b><br></font></td>

        <td style="vertical-align: top;">(for ODBC and DB2-CLI). Forces OTL to generate calls to SQLExtendedFetch (buffer size &gt; 1), or SQLFetch (buffer size ==1), instead of SQLFetchScroll, in case if the ODBC level is greater of equal to ODBC 3.0. This #define is introduced to mainly fix a bug in DB2-CLI in Linux, and some ODBC drivers, when CLOBs/BLOBs are being fetched with SQLFetchScroll().</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE" id="OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE"></a><span style="font-weight: bold;">OTL_ODBC_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">SELECT_STM_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">EXECUTE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">BEFORE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">DESCRIBE</span><br></td>

        <td style="vertical-align: top;">This #define (#define OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE) should be used in a combination with #define OTL_ODBC, and it changes the OTL stream's default sequence of ODBC functions in the case of SELECT statement. The default from sequence is as follows: SQLPrepare(), SQLDescribeCol(),..., SQLBindParameter(),..., SQLExecute(), SQLFetch(). New ODBC drivers tend to do more optmization of database round-trips, and they return the SELECT column descriptions along with the first batch of rows. The ODBC specifation calls this kind of optimization an implementaion detail, and leaves it up to the implometors of ODBC driver. In the case of such optimization, the sequence of ODBC function becomes this: SQPrepare(), SQLBindParameter(),...,
        SQLExecute(), SQLDescribeCol(), ..., SQLFetch().<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE" id="OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE"></a>OTL_ORA_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">DECLARE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">COMMON_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">READ_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">STREAM_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">INTERFACE</span><br></td>

        <td style="vertical-align: top;">(for OCI8/8i/9i/10g only). Whe this #define is enabled, OTL declares the following abstract / interface class which both <a href="otl4_refcur_stream.htm">otl_refcur_stream</a> and <a href="otl3_stream_class.htm">otl_stream</a> get derived from:<br>
        <br>
        <span style="font-family: monospace;">class otl_read_stream_interface{</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">public:</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp;</span> <big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual int is_null(void) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual void rewind(void) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual int eof(void) = 0;</span><big><big><big><big><big><br></big></big></big></big></big>
        <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(otl_datetime&amp; s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(char&amp; c) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(unsigned char&amp; c) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(OTL_STRING_CONTAINER&amp; s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style=
        "font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(char* s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(unsigned char* s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp; operator&gt;&gt;(int&amp; n) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(unsigned&amp; u) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style=
        "font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(short&amp; sh) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(long int&amp; l) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(float&amp; f) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style=
        "font-family: monospace;">operator&gt;&gt;(double&amp; d) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(otl_long_string&amp; s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_read_stream_interface&amp;</span> <span style="font-family: monospace;">operator&gt;&gt;(otl_lob_stream&amp; s) = 0;</span><big><big><big><big><big><br></big></big></big></big></big> <span style="font-family: monospace;">&nbsp; virtual otl_column_desc*</span> <span style="font-family: monospace;">describe_select(int&amp; desc_len) = 0;<br>
        <br>
        &nbsp; <a name="describe_out_vars" id="describe_out_vars"></a>virtual otl_var_desc* describe_out_vars(int&amp; desc_len);<br></span> &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;"><a name="describe_next_out_var" id="describe_next_out_var"></a>virtual otl_var_desc* describe_next_out_var(void);<br></span><br>
        <big><big><big><big>&nbsp;&nbsp;</big></big></big></big> <small><span style="font-family: monospace;">virtual ~otl_read_stream_interface(){}</span></small><big><big><big><big><br></big></big></big></big> <big><big><big><big><br></big></big></big></big> <small><span style="font-family: monospace;">};<br>
        <br></span></small> This interface is useful when there is a lot of common code for fetching rows either via otrl_stream or via otl_refcur_stream.<br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ORA_DOES_NOT_UNDEF_MIN_MAX" id="OTL_ORA_DOES_NOT_UNDEF_MIN_MAX"></a><b>OTL_ORA_<br>
        DOES_NOT_<br>
        UNDEF_<br>
        MIN_MAX</b></font></td>

        <td style="vertical-align: top;">OTL/OCI8/8i/9i/10g #undef's #define min and #define max that are defined in one of the OCI header files. This was done because in some cases min() and max() were declared as functions in C++ standard header files. However, when ATL is used, min() and max() are defined as #define's in "windef.h". If the OTL header file is included after the windef.h file, the min() and max() #defines get #undef''ined by OTL, so the symbols become unavailable. When #define OTL_ORA_DOES_NOT_UNDEF_MIN_MAX) is enabled, it makes OTL keep #define min and #define max as they were defined (if they were defined).<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ORA_TEXT_ON" id="OTL_ORA_TEXT_ON"></a><b>OTL_ORA<br>
        _TEXT_ON</b>.<br></font></td>

        <td style="vertical-align: top;">When fstream.h gets included before the OTL header file, fstream.h declares object "text", which is part of the C++ stream environment. Oracle OCI header files use symbol "text" as well. Depending on the platform and the C++ compiler, symbol "text" is defined in OCI either as a typedef or a #define. In any case, it interferes with the C++ "text", defined in fstream.h. #define OTL_ORA_TEXT_ON is introduced to fix the problem. So, all the user needs to do in order to make fstream.h and the OTL header compile together is to put #define OTL_ORA_TEXT_ON before including the OTL header file, and after #include &lt;fstream.h&gt;. In the case of fstream.h being include after the OTL header file, #define OTL_ORA_TEXT_ON also needs to be defined before the
        inclusion of the OTL header file.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_ORA_TIMESTAMP" id="OTL_ORA_TIMESTAMP"></a><b>OTL_ORA<br>
        _TIMESTAMP</b></font></td>

        <td style="vertical-align: top;">This #define enables support for Oracle 9i's timestamps, timestamps with time zones, and timestamps with local time zones. The #define forces OTL to use the OCI "OCIDateTime*" resource instead of the OCI 7-byte date structure. OCIDateTime allows the timestamp values (down to microseconds and time zone hours/minutes) to be written and read. OCI 8.1.7 has support for OCIDateTime's when they are used with Oracle 9i on the back end, meaning that Oracle Client 8.1.7 can be connected to Oracle 9i, and OTL_ORA_TIMESTAMP can be enabled at the same time. In other words, #define OTL_ORA8I, or #define OTL_ORA9I can be used&nbsp; in a combination with OTL_ORA_TIMESTAMP, if the underlynig Oracle Client (OCI) libraries have the corresponding functionality.<br>
        <br>
        PL/SQL (index-by) tables of otl_datetime's, that are bound with "tables of timestamps" are not supported this time around, due to some bugs in the OCI code (I just could not track down the problem: no info on metalink.oracle.com, no references on dejanews either, no code samples). TIMESTAMPs, as parametrs in stored procedures, can be used with otl_datetime's. PL/SQL (index-by) table can be boud with "tables of DATEs", as usual.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><span style="font-weight: bold;"><a name="OTL_STR_TO_BIGINT" id="OTL_STR_TO_BIGINT"></a>OTL_STR_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">_TO_BIGINT</span>(str,n)</font></td>

        <td style="vertical-align: top;">
          This #define is required when <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> is enabled and when one of OTL_ORAxx #defines is enabled, in order to support OTL internal string-to-bigint conversion. This #define is supposed to provide string-to-bigint conversion code that is most probably C++ compiler specific (because 64-bit ints are not part of the ANSI C++ standard), for example:<br>
          <br>
          <pre>
#if defined(__GNUC__) // GNU C++<br><br>#include &lt;stdlib.h&gt;<br><br>#define <a href="#OTL_BIGINT">OTL_BIGINT</a> long long<br><br>#define <a href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>(str,n)                \<br>{                                               \<br>  n=strtoll(str,0,10);                          \<br>}<br><br>#define <a href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>(n,str)                \<br>{                                               \<br>  sprintf(str,"%lld",n);                        \<br>}<br><br><br>#endif<br>
</pre><br>
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top; font-weight: bold;"><a name="OTL_STREAM_READ_ITERATOR_ON" id="OTL_STREAM_READ_ITERATOR_ON"></a>OTL_STREAM_<br>
        READ_<br>
        ITERATOR_ON<br></td>

        <td style="vertical-align: top;">This #define enables the&nbsp; <a href="otl4_stream_read_iterator.htm">OTL stream read iterator</a>, which provides a JDBC-like <span style="font-style: italic;">getter</span> interface.<br>
        Typically, OTL stream read iterators can be used with SELECT statements, stored prcoredures that return implicit result sets (ODBC, DB2-CLI), or stored procedures that return referenced cursors (Oracle).<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO" id="OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO"></a><small>OTL_THROWS_</small></span><small><br style="font-weight: bold;">
        <span style="font-weight: bold;">ON_SQL_SUCCESS_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">WITH_INFO</span></small><br></td>

        <td style="vertical-align: top;">OTL/ODBC, OTL/DB2-CLI only. This #define enables the following function: otl_connect::<a href="otl3_connect_class.htm#set_throw_on_sql_success_with_info">set_throw_on_sql_success_with_info</a>().&nbsp; When the function sets the "throw flag", OTL&nbsp; throws an otl_exceptioin if SQLExecute() / SQLExecDirect() returns SQL_SUCCESS_WITH_INFO. By raising an exception on SQL_SUCCESS_WITH_INFO, OTL makes it possible to communicate messages that would normally get retrieved via SQLGetDiagRec() calls right after SQLExecute() / SQLExecDirect() returns. In order to get the maximum amount of diagnostic information from the ODBC driver, this #define should be used in a combination with #define <a href=
        "#OTL_EXTENDED_EXCEPTION">OTL_EXTENDED_EXCEPTION</a>.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><span style="font-weight: bold;"><a name="OTL_TRACE" id="OTL_TRACE"></a></span><span style="font-weight: bold;">OTL_TRACE_LEVEL</span><br>
        <br>
        <span style="font-weight: bold;">OTL_TRACE_<br>
        STREAM<br>
        <br>
        OTL_TRACE<br>
        _LINE_PREFIX<br>
        <br>
        OTL_TRACE_<br>
        LINE_SUFFIX<br>
        <br>
        <a name="OTL_TRACE_ENABLE_STREAM_LABELS" id="OTL_TRACE_ENABLE_STREAM_LABELS"></a>OTL_TRACE_ENABLE_<br>
        STREAM_LABELS<br></span></font></td>

        <td style="vertical-align: top;">
          These #defines enable OTL <span style="font-style: italic;">function call tracing</span>. OTL tracing uses the C++ stream interface (ostream, fstream) to log OTL function calls with arguments, "<span style="font-style: italic;">this"</span> addresses of class instances, etc.<br>

          <ul>
            <li>#define OTL_TRACE_LEVEL specifies a level of OTL tracing. Each type of tracing is represented by its own bit in the whole trace level unsigned&nbsp; int value:<br>
            <br></li>

            <li style="list-style: none; display: inline">
              <ol>
                <li>0x1 -- traces the following functions of the otl_connect class (1st level of tracing): rlogon(), logoff(), commit(), rollback(), auto_commit_on(), auto_commit_off()<br></li>

                <li>0x2 -- traces otl_cursor::direct_exec(), direct execution of static SQL statements, no otl_streams (2nd level of tracing).<br></li>

                <li>0x4 -- traces the following functions of the otl_stream class: open(), close()</li>

                <li>0x8 -- traces internal "execute SQL statement" function, internal "fetch the first bacth of rows" function, internal "fetch the next batch of rows" function (3rd level of tracing).</li>

                <li>0x10 -- traces the operator &gt;&gt; and &lt;&lt; functions of the otl_stream class (4th level of tracing)</li>

                <li><a name="level_x20" id="level_x20"></a>0x20 -- traces all <a href="otl3_exception_class.htm">otl_exception'</a>s raised by OTL.</li>
              </ol><br>
              <br>
            </li>

            <li>#define OTL_TRACE_STREAM specifies a log stream variable, or a function call that returns a file stream reference. What is defined by this #define is used as an output file stream variable inside OTL.<br>
            <br></li>

            <li>#define OTL_TRACE_LINE_PREFIX can be used to override the default OTL trace line prefix: "OTL TRACE ==&gt;". If it is more convenient to have something different from the default, say, for running a Perl script on an OTL log file to mine for patterns.<br>
            <br></li>

            <li>#define OTL_TRACE_LINE_SUFFIX can be used to override the default OTL trace line suffix: "<span style="font-family: monospace;">\n</span>". If it is more convenient to have something different from the default, say, for running a Perl script on an OTL log file to mine for patterns.<br>
            <br></li>

            <li>#define OTL_TRACE_ENABLE_STREAM_LABELS can be used to enable logging of otl_stream labels instead of SQL statement bodies. See The Oracle, DB2-CLI, and ODBC specific <a href="otl3_stream_class.htm#otl_stream_otl_stream">otl_stream</a> descriptions for more detail.<br></li>
          </ul>#define OTL_TRACE_LEVEL may be either a constant, or a variable, or a function call that returns the trace level dynamically. If OTL_TRACE_LEVEL is not defined then tracing calls are not generated, and therefore there is not any runtime performance penalty. Even if #define OTL_TRACE_LEVEL is defined, performance degradation is very small, if the level of tracing is set relatively low.<br>
          <br>
          Example:<br>
          <pre>
      unsigned int my_trace_level=<br>        0x1 | // 1st level of tracing<br>        0x2 | // 2nd level of tracing<br>        0x4 | // 3rd level of tracing<br>        0x8 | // 4th level of tracing<br>        0x10| // 5th level of tracing<br>        0x20; // 6th level of tracing<br>     // each level of tracing is represented by its own bit, <br>     // so levels of tracing can be combined in an arbitrary order.<br><br>     #define OTL_TRACE_LEVEL my_trace_level <br>        // enables OTL tracing, and use my_trace_level <br>        // as a trace control variable.<br><br>     #define OTL_TRACE_STREAM cerr <br>        // directs all OTL tracing to cerr<br><br>     #define OTL_TRACE_LINE_PREFIX "MY OTL TRACE ==&gt; " <br>        // redefines the default OTL trace line prefix. <br>        // This #define is optional<br><br>     #define OTL_TRACE_LINE_SUFFIX std::endl <br>        // redefines the default OTL trace line suffix. <br>        // This #define is optional<br><br>
</pre>Also,&nbsp; see OTL examples for more detail.
        </td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_STL" id="OTL_STL"></a><b>OTL_STL</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for turning on <i>std::strings</i>, and STL-compliant OTL stream iterators: otl_input_iterator, otl_output_iterator)</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_STL_NOSTD_NAMESPACE" id="OTL_STL_NOSTD_NAMESPACE"></a><b>OTL_STL_NOSTD<br>
        _NAMESPACE</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for excluding namespace std, when #define OTL_STL is on). This is mainly for fixing problem <a href="otl3_prob.htm#prob42">42.</a></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_STLPORT" id="OTL_STLPORT"></a><b>OTL_STLPORT</b></font></td>

        <td style="vertical-align: top;">(the same as #define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>, only for use with STLPort 4.x). This #define makes OTL compile with STLPort 4.x.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_STREAM_POOLING_ON" id="OTL_STREAM_POOLING_ON"></a><b>OTL_STREAM<br>
        _POOLING_ON</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for enabling <a href="otl3_stream_pooling.htm">otl_stream pooling</a>). This #define requires #define OTL_STL to be defined first because STL containers were used in the implementation of the otl_stream pooling. For more detail, see examples <a href="otl3_ex113.htm">113</a>, <a href="otl3_ex114.htm">114</a>, <a href="otl3_ex115.htm">115</a>.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_UNCAUGHT_EXCEPTION_ON" id="OTL_UNCAUGHT_EXCEPTION_ON"></a><b>OTL_UNCAUGHT<br>
        _EXCEPTION_ON</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for enabling a safer exception handling and error recovery). This is for fixing problem <a href="otl3_prob.htm#prob46">46.</a><br>
        <br>
        From OTL 4.0.162 and on, the #define becomes the default in order to address user complaints. The rationale for making it the default at this point in time is that thr C++ compilers support the stardard C++ uncaught_exception() function more or less. OTL 4.0.167 and higher do not enable this #define by default for Visual C++ 6.0.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top; font-weight: bold;"><a name="OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR" id="OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR"></a>OTL_UNICODE_<br>
        STRING_TYPE_<br>
        CAST_FROM_<br>
        CHAR<br></td>

        <td style="vertical-align: top;">When #define <a href="#OTL_UNICODE">OTL_UNICODE</a>, #define <a href="##OTL_ORA8I">OTL_ORA8I</a>/<a href="#OTL_ORA9I">9I</a>/<a href="#OTL_ORA10G">10G</a>/<a href="#OTL_ORA10G_R2">10G_R2</a>, and #define <a href="#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a> are enabled, a string class that is different from std::wstring may be used, for example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_ORA10G</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#defined OTL_UNICODE<br></span> ...<span style="font-family: monospace;"><br style="font-family: monospace;"></span> <span style="font-family: monospace;">#define OTL_UNICODE_STRING_TYPE my_wide_char_string</span><br style="font-family: monospace;">
        <br>
        Let's also assume that my_wide_char_string is not 100% compatible with std::wstring and doesn't have the following function<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp; <tt>assign(const charT* s, size_type n)<br>
        <br></tt> In order for OTL to handle wide character strings of my_wide_char_string type, it needs to know how to efficiently make a string out of a raw buffer + the string length. #define OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR can be used for passing into the OTL layer a piece of code that does the conversion. For example, say, ACE_TString is used:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_ORA10G_R2</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#defined OTL_UNICODE<br>
        #define OTL_UNICODE_CHAR_TYPE wchar_t<br style="font-family: monospace;"></span> <span style="font-family: monospace;">#define OTL_UNICODE_STRING_TYPE ACE_TString</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#define OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR(s, c_ptr, len) {</span><span style="font-family: monospace;">s.set(c_ptr,len,1);}<br>
        <br></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_USER_DEFINED_STRING_CLASS_ON" id="OTL_USER_DEFINED_STRING_CLASS_ON"></a><b>OTL_USER_DEFINED<br>
        _STRING_CLASS_ON</b></font></td>

        <td style="vertical-align: top;"><small><small><big><big>(for defining a string class, other than STL's <i>std::string,</i> for reading from/writing to the otl_stream). This #define goes in pair with #define <b>USER_DEFINED_STRING_CLASS</b>, which is used to define the actual string class name.Fore more detail, see examples <a href="otl3_ex119.htm">119</a>, <a href="otl3_ex120.htm">120</a>, <a href="otl3_ex121.htm">121</a></big></big></small></small></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL" id="OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL"></a>OTL_USER_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">DEFINED_STRING_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">CLASS_DEFAULT_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">NULL_TO_VAL</span><br></td>

        <td style="vertical-align: top;">This #define OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) can be used in the case if a C++ string class is used with OTL in order to read string values tothe database., and to default string NULLs to a predefined value. If string NULLs need to be defaulted to an empty string, some C++ string classes have more efficient ways than assigning an empty string to an actual string variable. Especially, when the variable is used a reusable buffer.<br>
        <br>
        For example, ACE_TString has fast_clear(), which keeps the string internal buffer. It just assigns '\0' to the first element of the internal buffer, and sets the length indicator to 0. Here's what the #define should look like in the case of ACE_TString and the desired default value for string NULLs is an empty string:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) {s.fast_clear();}<br>
        <br></span> std::string can be cleared via std::string::clear(), for example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) { s.clear();}</span><br>
        <br>
        This feature becomes more important if your OTL based C++ code starts relying of defaulting string NULLs to a value, especially in a multi-threaded environment, and an&nbsp; inefficient dynamic heap manager.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a style="font-weight: bold;" name="OTL_UNICODE" id="OTL_UNICODE"></a><span style="font-weight: bold;">OTL_UNICODE</span><br></font></td>

        <td style="vertical-align: top;">This #define enables Unicode string support in OTL for Oracle8i (UCS-2), and for Oracle 9i/10g (UTF-16). Character string lengths change from byte semantic to character semantic, meaning that sizes are given in characters rather than in bytes. For more detail, refer to the corresponding Oracle manuals on nationalization / globalization. For example, in Oracle 8i, if a string column is, say, VARCHAR2(60), 60 is the size of the column in bytes. In Oracle 9i, the size will be characters. In Oracle 10g, it maybe specified in bytes or characters. The OTL manual is not a substitute for the Oracle manuals.<br>
        <br>
        Starting with version 4.0.108, OTL supports Unicode strings for OTL/ODBC, and OTL/DB2-CLI. Unicode string data can be accessed in Oracle via ODBC, MS SQL via ODBC, and DB2 via DB2-CLI/ODBC.<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><b><a name="OTL_UNICODE_CHAR_TYPE" id="OTL_UNICODE_CHAR_TYPE"></a>OTL_UNICODE_<br>
        CHAR_TYPE</b></font><br></td>

        <td style="vertical-align: top;">This #define is used in a combinatiuon with <a href="#OTL_UNICODE">OTL_UNICODE</a>. The #define specifies a compiler specific, 2-byte Unicode character type.:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
        <span style="font-family: monospace;">#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
        <br></span> When your C++ compiler doesn't have any appropriate Unicode compatible character type, <span style="font-family: monospace;">unsigned short</span> can be used instead:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNICODE<br></span> <span style="font-family: monospace;">#define OTL_UNICODE_CHAR_TYPE unsigned short</span><br>
        <br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_UNICODE_EXCEPTION_AND_RLOGON" id="OTL_UNICODE_EXCEPTION_AND_RLOGON"></a>OTL_UNICODE_<br>
        EXCEPTION_AND_<br>
        RLOGON</span><br></td>

        <td style="vertical-align: top;">This #define enables support for Unicode <a href="otl3_exception_class.htm">otl_exception</a>'s <a href="otl3_exception_class.htm#unicode_msg"><span style="font-style: italic;">msg</span></a>, <a href="otl3_exception_class.htm#unicode_sqlstate"><span style="font-style: italic;">sqlstate</span></a> data members, and an otl_connect::<a href="otl3_connect_class.htm#logon_odbc_unicode">rlogon</a>() function that accepts Unicode user id, password, and DSN. This #define should be enabled only when #define UNICODE / _UNICODE is enabled for ODBC / DB2 CLI, In other words, when Unicode ODBC driver functions are enabled. Also, it's recommened that this #define be used in a conbination with <a href="#OTL_UNICODE">OTL_UNICODE,</a> and <a href=
        "#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a>, for example:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNICODE<br>
        #define OTL_UNICODE_CHAR_TYPE wchar_t<br>
        #define OTL_UNICODE_EXCEPTION_AND_RLOGON<br>
        <br></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_UNICODE_STRING_TYPE" id="OTL_UNICODE_STRING_TYPE"></a>OTL_UNICODE_<br>
        STRING_TYPE</span><br></td>

        <td style="vertical-align: top;">This #define enables <span style="font-family: monospace;">std::wstring</span> as 2-byte Unicode strings in OTL. It can be used when <span style="font-family: monospace;">wstring</span> is based on a <span style="font-family: monospace;">wchar_t</span> that corresponds to 2-byte Unicode:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
        <span style="font-family: monospace;">#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
        #define OTL_UNICODE_STRING_TYPE wstring<br>
        <br></span> If your C++ compiler doesn't have <span style="font-family: monospace;">std::wstring</span> class defined (say, only <span style="font-family: monospace;">std::string</span> is defined), it is possible to instantiate <span style="font-family: monospace;">std::basic_string&lt;XXX&gt;</span>, where XXX is your 2-byte Unicode type, for example, your 2-byte Unicode is <span style="font-family: monospace;">unsigned short</span>:<br>
        <br>
        <span style="font-family: monospace;">#include &lt;string&gt;</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">namespace std{<br>
        &nbsp;&nbsp;&nbsp; typedef unsigned short my_unicode_char;<br>
        &nbsp;&nbsp;&nbsp; typedef basic_string&lt;my_unicode_type&gt; my_unicode_string;<br style="font-family: monospace;"></span> <span style="font-family: monospace;">}</span><br>
        <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
        <span style="font-family: monospace;">#define OTL_UNICODE_CHAR_TYPE my_unicode_char<br>
        #define OTL_UNICODE_STRING_TYPE my_unicode_string<br></span><br>
        More specifically, GNU C++ doesn't implement std::wstring, so the example above should be useful for GNU C++ at least.<br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT" id="OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT"></a>OTL_UNICODE_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">USE_ANSI_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">ODBC_FUNCS_</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">FOR_DATA_DICT</span><br></td>

        <td style="vertical-align: top;">This #define should be used as a workaround for an MS SQL Server ODBC driver bug. It's not possible to say for sure what the scope of the bug (or may be it's a an undocumented feature!) is. OTL provides access to the <a href="otl4_append_b.htm">data dictionary</a> ODBC / DB2 CLI functions. When Unicode ODBC function prototypes are enabled via #define UNICODE / _UNICODE, the corresponding Unicode ODBC data dictionary functions are enabled. However, some of the Unicode ODBC data dictionary functions don't work correctly when the MS SQL Server Unicode ODBC driver is used. As a workaround, ANSI ODBC data dictionary functions can be used instead, even if the output string bind variables are Unicode. #define OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT
        makes OTL generate ANSI ODBC data dictionary function calls instead of the Unicode ODBC data dictionary function calls.<br>
        <br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_VALUE_TEMPLATE_ON" id="OTL_VALUE_TEMPLATE_ON"></a><b>OTL_VALUE<br>
        _TEMPLATE_ON</b>&nbsp;</font></td>

        <td style="vertical-align: top;">(for enabling <a href="otl3_value.htm">otl_value&lt;T&gt;</a>). The otl_value&lt;T&gt; template class can be also enabled with #define OTL_STL. #define OTL_VALUE_TEMPLATE_ON allows the template class to be enabled without turning on STL compliance. Not all C++ compilers compile OTL under #define OTL_STL. #define OTL_VALUE_TEMPLATE_ON was introduced In order to relax that limitation. Fore more detail, see examples <a href="otl3_ex119.htm">119</a>, <a href="otl3_ex120.htm">120</a>, <a href="otl3_ex121.htm">121</a></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><font size="-1"><a name="OTL_VERSION_NUMBER" id="OTL_VERSION_NUMBER"></a><b>OTL_VERSION<br>
        _NUMBER</b><br></font></td>

        <td style="vertical-align: top;">This #define holds the version number of the OTL header file, in which the #define is defined. For example, OTL 4.0.17 is defined as (0x040011L). This #define allows the user to keep track of OTL version numbers, e.g. the #define makes it possible to do more complex conditional compilation.</td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;"><a name="OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE" id="OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE"></a>OTL_UNCAUGHT_<br>
        EXCEPTION_OWN_<br>
        NAMESPACE</span><br></td>

        <td style="vertical-align: top;">When OTL is used with <a href="http://stlport.org">STL Port</a> (#define <a href="#OTL_STLPORT">OTL_STLPORT</a>), STL Port library may be configured not to expose some <span style="font-style: italic;">std::</span> functions like uncaught_exception() in its namespace _STL. In order to work around the problem, #define OTL OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE is introduced:<br>
        <br>
        <span style="font-family: monospace;">#define OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE __std_alias::</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">...</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">#include &lt;otlv4.h&gt;<br>
        <br></span> This #define tells OTL what namespace to prefix the uncaught_exception() function with. In OTL 4.0.167 or higher, this #define is obsolete, and has no effect.<br></td>
      </tr>
    </tbody>
  </table>&nbsp;<br>
  <br>
  The macro definitions may be defined directly in the program's code, or turned on via C++ compiler command line<br>
  option, e.g.: -DOTL_ODBC, -DOTL_ORA7, -DOTL_ORA8, -DOTL_ORA8I, -DOTL_ORA9I,, -DOTL_ODBC_UNIX, -DOTL_ODBC_MYSQL, -DOTL_DB2_CLI, -DOTL_ODBC_TIMESTEN_WIN, -DOTL_ODBC_TIMESTEN_UNIX<br>

  <p>In order to compile and link OTL with an underlying database API, the following header files and libraries of the database API are needed (&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;,&nbsp; &lt;<span style="font-style: italic;">DB2_HOME</span>&gt;,&nbsp; &lt;TimesTen_HOME&gt;, and &lt;INFORMIX_HOME&gt; are home directories for installations of Oracle, DB2, TimesTen, and Informix):<br></p>

  <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><span style="font-weight: bold;">API</span><br></td>

        <td style="vertical-align: top;"><span style="font-weight: bold;">API header files for&nbsp; Win</span>dows<br></td>

        <td style="vertical-align: top;"><span style="font-weight: bold;">API libraries for Windows<br></span></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI7<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include<br></td>

        <td style="vertical-align: top;">&nbsp;&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\ociw32.lib<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI8<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>

        <td style="vertical-align: top;">&nbsp;&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI8i<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>

        <td style="vertical-align: top;">&nbsp;&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI9i<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>

        <td style="vertical-align: top;">&nbsp;&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI10g<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>

        <td style="vertical-align: top;">&nbsp;&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">ODBC<br></td>

        <td style="vertical-align: top;">Normally, in one of the C++ compiler system directories, no need to include explicitly.<br></td>

        <td style="vertical-align: top;">Normally, in one of the C++ compiler system directories: odbc32.lib<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">DB2 CLI<br></td>

        <td style="vertical-align: top;">In &lt;<span style="font-style: italic;">DB2_HOME</span>&gt;\include<br></td>

        <td style="vertical-align: top;">&lt;DB2_HOME&gt;\lib\db2api.lib<br>
        &lt;DB2_HOME&gt;\lib\db2cli.lib<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="TIMESTEN_ODBC_WIN_COMPILE" id="TIMESTEN_ODBC_WIN_COMPILE"></a>TimesTen&nbsp; ODBC<br></td>

        <td style="vertical-align: top;">&bull; Directly with the TimesTen ODBC driver<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp; in &lt;TimesTen_HOME&gt;\include<br>
        <br>
        <br>
        &bull; Directly with the TimesTen Client ODBC driver<br>
        <br>
        &nbsp;&nbsp; &nbsp;&nbsp; in &lt;TimesTen_HOME&gt;\include<br>
        <br>
        &bull; With an ODBC driver manager (to be used with #define <a href="#OTL_ODBC">OTL_ODBC</a>, no TimeSten ODBC extensions are available)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normally, in one of the C++ compiler system directories, no need to include explicitly.<br>
        <br></td>

        <td style="vertical-align: top;">&bull; Directly with the TimesTen ODBC driver<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTEN70.LIB<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTDV70.LIB<br>
        <br>
        &bull; Directly with the TimesTen Client ODBC driver<br>
        <br>
        &nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTCL70.LIB<br>
        <br>
        &bull; With an ODBC driver manager<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normally, in one of the C++ compiler system directories: odbc32.lib</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">Informix CLI<br></td>

        <td style="vertical-align: top;">Default ODBC header files for the C++ compiler.<br></td>

        <td style="vertical-align: top;">odbc32.lib<br></td>
      </tr>
    </tbody>
  </table><br>
  <br>

  <table style="text-align: left; width: 987px; height: 238px;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><small><small><small><small><small><small><small><span style="font-weight: bold;">API</span><br></small></small></small></small></small></small></small></td>

        <td style="vertical-align: top;"><small><small><small><small><small><small><small><span style="font-weight: bold;">API header files for Unix</span><br></small></small></small></small></small></small></small></td>

        <td style="vertical-align: top;"><small><small><small><small><small><small><small><span style="font-weight: bold;">API libraries for Unix</span><br></small></small></small></small></small></small></small></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI7<br></td>

        <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp; -I$(ORACLE_HOME)/rdbms/public<br></td>

        <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/ -lclntsh<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI8<br></td>

        <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp; -I$(ORACLE_HOME)/rdbms/public</td>

        <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/ -lclntsh<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI8i<br></td>

        <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp; -I$(ORACLE_HOME)/rdbms/public</td>

        <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/ -lclntsh<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI9i<br></td>

        <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp; -I$(ORACLE_HOME)/rdbms/public</td>

        <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/ -lclntsh<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">OCI10g<br></td>

        <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp; -I$(ORACLE_HOME)/rdbms/public</td>

        <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/ -lclntsh</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">ODBC<br></td>

        <td style="vertical-align: top;">ODBC bridge specific. If you're using unixodbc, see its manuals for more detail.<br></td>

        <td style="vertical-align: top;">ODBC bridge specific. If you're using unixodbc, see its manuals for more detail</td>
      </tr>

      <tr>
        <td style="vertical-align: top;">DB2 CLI<br></td>

        <td style="vertical-align: top;">-I/&lt;<span style="font-style: italic;">DB2_HOME</span>&gt;/sqllib/include<br></td>

        <td style="vertical-align: top;">-L/&lt;<span style="font-style: italic;">DB2_HOME</span>&gt;/sqllib/lib -ldb2<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;"><a name="TIMESTEN_ODBC_UNIX_COMPILE" id="TIMESTEN_ODBC_UNIX_COMPILE"></a>TimesTen ODBC<br></td>

        <td style="vertical-align: top;">-I&lt;TimesTen_HOME&gt;/include<br></td>

        <td style="vertical-align: top;">To link with the TimesTen Data Manager ODBC Driver<br>
        <br>
        &nbsp;&nbsp;&nbsp; -L &lt;TimesTen_HOME&gt;/lib -ltten<br>
        <br>
        To link with the TimesTen Client ODBC Driver:<br>
        <br>
        &nbsp;&nbsp;&nbsp; -L&lt;TimesTen_HOME&gt;/lib -lttclient<br></td>
      </tr>

      <tr>
        <td style="vertical-align: top;">Informix CLI<br></td>

        <td style="vertical-align: top;">-I&lt;INFORMIX_HOME&gt;/incl/cli<br></td>

        <td style="vertical-align: top;">-L&lt;INFORMIX_HOME&gt;/lib -lifdmr -lthcli<br></td>
      </tr>
    </tbody>
  </table><br>
  <br>
  For more detail, see the manul of your C++ compiler and the database API manuals.<br>
  <hr width="100%">

  <center>
    <p><a href="otl3_examples.htm">Prev</a> <a href="otl3_namespaces.htm">Next</a><a href="otl3.htm">Contents</a><a href="home.htm">Go Home</a></p>
  </center>Copyright &copy; 1996-2009, Sergei Kuchin, email: <a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>, <a href="mailto:skuchin@gmail.com">skuchin@gmail.com&nbsp;&nbsp;</a> <script language="JavaScript" type="text/javascript">
<!-- hide from old browsers
  var modDate = new Date(document.lastModified)
  document.write("<i> Last Updated:<\/i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
  //-->
  </script>

  <p><i>Permission to use, copy, modify and redistribute this document for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</i></p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script><script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
  pageTracker._trackPageview();
  </script>
</body>
</html>
