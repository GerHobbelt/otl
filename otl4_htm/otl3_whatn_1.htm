<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta content="text/html; charset=iso-8859-1"
 http-equiv="Content-Type">
  <meta content="Sergei Kuchin" name="Author">
  <meta content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]"
 name="GENERATOR">
  <meta
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library"
 name="KeyWords">
  <title>Oracle, Odbc and DB2-CLITemplate Library, Version 4.0, What's
New</title>
</head>
<body>
<ul>
  <center>
  <h1>Oracle, Odbc and DB2-CLI Template Library, Version 4.0</h1>
  </center>
  <center>
  <h1>What's New</h1>
  </center>
  <table border="1">
    <caption><br>
    </caption><tbody>
      <tr>
        <td><b><font size="+1">Feature</font></b></td>
        <td><b><font size="+1">Comment</font></b></td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.143):<br>
        <br>
        <ul>
          <li>When OTL steram reads a Binary Large Object value (LONG
RAW, BLOB, IMAGE, etc.) into an <a href="otl3_long_string.htm">otl_long_string,</a>
the long string gets NULL terminated (0-byte terminated), which is not
correct. It didn't matter when the otl_long_string's buffer size is
greater or equal to the BLOB size + 1. In the case if the buffer size
equals the BLOB size, the program crashes. The bug has been fixed in
this release.<br>
            <br>
Character Large Objects (LONG, CLOB, TEXT, etc.) do get NULL terminated
for backward compatibility with NULL terminated C strings / character
arrays. <br>
            <br>
          </li>
          <li>The following bind variable declaration caused some
confusion: <span style="font-family: monospace;">:f1&lt;char&gt;</span>.
The problem was that such a declaration <a
 href="otl3_bind_variables.htm#INVALID_CHAR">invalid,</a> but OTL
didn't enforce it. From this realeas on, OTL is going to throw an
otl_exception.<br>
            <br>
          </li>
          <li>OTL 4.0.140 introduced support for <a
 href="otl3_bind_variables.htm#raw">raw</a>[XXX]. A problem was
reported that when&nbsp; raw[XXX] is used to bind a variable to a
stored procedure output parameter, OTL doesn't return values into the
bind variable correctly.&nbsp; The problem was fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.142):<br>
        <br>
        <ul>
          <li>A potential problem in OTL was found with a code analysis
tool (<a href="http://www.coverity.com">Coverity</a>). The problem has
been
fixed in this release.&nbsp; The problem was in the following code:<br>
            <br>
            <span style="font-family: monospace;">&nbsp;
otl_column_desc&amp; operator=(const otl_column_desc&amp; desc)</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp; {</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ...</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
}else if(name_len_&lt;desc.name_len_){</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(name,desc.name);</span><br
 style="font-family: monospace;">
&nbsp; &nbsp; &nbsp; &nbsp; <span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
            <br>
The code analysis tool found that desc.name can be NULL, so that the
strcpy() would crash the program. In reality, if desc.name_len_ &gt; <span
 style="font-family: monospace;">name_len_ &gt;= </span>0<span
 style="font-family: monospace;">, </span>desc.name_ will always be
defined. So, it's a false positive. I added a check for NULL for
desc.name_ anyway in order to make the tool happy:<br>
            <br>
            <span style="font-family: monospace;">&nbsp;
otl_column_desc&amp; operator=(const otl_column_desc&amp; desc)</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp; {</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ...</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
}else if(name_len_&lt;desc.name_len_ <span
 style="font-weight: bold; font-style: italic;">&amp;&amp; desc.name_!=0</span>){</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ...</span><br
 style="font-family: monospace;">
            <br>
          </li>
          <li>The problem was reported that when a CHAR() column is
used in Oracle in a combination with OTL/OCIx, a string that doesn't
have space characters at the end, can't be found by a WHERE clause in a
SELECT statement. For example:<br>
            <br>
&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">SELECT
f2 FROM test_tab WHERE f2=:f2&lt;char[31]&gt;</span><br>
            <br>
where f2 is CHAR(30). When OTL/OCIx is being used, either the string
has to be padded with space characters to the full length of the
column, or the following #define needs to be enabled (accidentally, it
wasn't documented, a.k.a. a bug in the manual): #define <a
 href="otl3_compile.htm#OTL_ORA_MAP_STRINGS_TO_CHARZ">OTL_ORA_MAP_STRINGS_TO_CHARZ</a>.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.141):<br>
        <br>
        <ul>
          <li>When an empty PL/SQL table gets returned via STL vector
based, OTL PL/SQL table <a href="otl3_pl_tab.htm">containers</a>,
Visual C++ 2005 throws an "out-of-range" exception. Error is fixed in
this release.<br>
            <br>
          </li>
          <li>New #define is introduced: #define <a
 href="otl3_compile.htm#OTL_DESTRUCTORS_DO_NOT_THROW">OTL_DESTRUCTORS_DO_NOT_THROW</a>.
            <br>
            <br>
            <a name="HIT_IN_HEAD"></a>Here's some prehistory: "<span
 style="font-style: italic;">Personally
I'd vote for beating every person who will write throwing destructor,
one hit in the head for every such destructor. I wonder why this
question always raised along with database-related code? Maybe because
people who write such libraries "came" from DB world and are not
competent enough to understand? I remember OTL (C++ DB access library)
has issues with throwing destructors...Michael...</span>".<br>
            <br>
&nbsp;People who want OTL destructors not "to
throw", from now on can enable the new #define, and happily code away
all manual database resource management.<br>
            <br>
My opinion is that for C++ compilers that support uncaught_exception()
correctly, throwing destructors are acceptable, if it results in
writing less code. Let the C++ gurus rest on the laurels of their
superior C++ knowledege.<br>
            <br>
Question for everybody: can anybody point me to a common C++ technique
/ idiom / pattern that combines RAII idiom, non-throwing destructors,
and error communication / handling via exceptions? I'd appreciate any
useful info on the topic very much.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.140):<br>
        <br>
        <ul>
          <li>A few more of&nbsp; "<a href="#type_punned">type-punned</a>"
g++ warnings have been fixed in this release. Besides the type-punned
warnings, other warning have been fixed. OTL compiles clean
with the following g++ warnings on (g++ 4.1.1):<br>
            <br>
            <span style="font-family: monospace;">&nbsp; -W<br>
&nbsp; -Wall<br>
&nbsp; -Wcast-align<br>
&nbsp; -Wcast-qual<br>
&nbsp; -Wcomments<br>
&nbsp; -Wconversion<br>
&nbsp; -Wctor-dtor-privacy<br>
&nbsp; -Werror<br>
&nbsp; -Wextra<br>
&nbsp; -Wformat<br>
&nbsp; -Wno-uninitialized<br>
&nbsp; -Wnon-virtual-dtor<br>
&nbsp; -Wold-style-cast<br>
&nbsp; -Woverloaded-virtual<br>
&nbsp; -Wparentheses<br>
&nbsp; -Wpointer-arith<br>
&nbsp; -Wreorder<br>
&nbsp; -Wshadow<br>
&nbsp; -Wsign-compare<br>
&nbsp; -Wsign-promo <br>
&nbsp; -Wstrict-aliasing=2<br>
&nbsp; -Wstrict-null-sentinel<br>
&nbsp; -Wundef<br>
&nbsp; -Wunused<br>
&nbsp; -Wunused-variable<br>
&nbsp; -Wwrite-strings<br>
            <br>
            </span></li>
          <li>OTL stream was allocating more memory than necessary for
internal buffers in the PL/SQL block:<br>
            <span style="font-family: monospace;"><br>
&nbsp;&nbsp;&nbsp; "begin "<br>
&nbsp;&nbsp;&nbsp; "&nbsp; PKG_TEST.my_prc(:p_arr&lt;char[2000],<span
 style="font-weight: bold; font-style: italic;">in[2000]</span>&gt;); "<br>
&nbsp;&nbsp;&nbsp; "&nbsp; PKG_TEST.proc_1(<span
 style="font-style: italic;">:PAR1</span>&lt;CHAR[32000],IN&gt;); "<br>
&nbsp;&nbsp;&nbsp; "&nbsp; PKG_TEST.proc_2(<span
 style="font-style: italic;">:PAR2</span>&lt;CHAR[32000],IN&gt;); "<br>
&nbsp;&nbsp;&nbsp; "end; "<br>
            <br>
            </span>The problem was that the <span
 style="font-style: italic;">in[2000]</span> clause was setting the
internal buffer size of the corresponding PL/SQL table to 2000, and <span
 style="font-style: italic;">:PAR1</span>, <span
 style="font-style: italic;">:PAR2</span> bind variables were treated
as PL/SQL tables of 2000 elements each. The program didn't crash, and
it even wroked correctly,&nbsp; but it allocated way too much memory.
The bug has been fixed in this release.<br>
            <span style="font-family: monospace;"><br>
            </span></li>
          <li><span style="font-family: monospace;"></span>A new bind
variable / placeholder data type has been introduced: <a
 href="otl3_bind_variables.htm#raw">raw</a>[XXX]. The new data type is
for supporting database "binary" types (Oracle RAW, MS SQL / Sybase /
MySQLVARBINARY/BINARY, PostgreSQL BYTEA, etc) natively. "Raw" values
can be read from / written to the database via <a
 href="otl3_long_string.htm">otl_long_string</a>'s. Also,&nbsp; a new
OTL type code contstant has been added in identify bind variable of the
raw[XXX] type:<br>
            <br>
&nbsp;&nbsp; &nbsp;&nbsp; <span style="font-family: monospace;">const
int <a href="otl3_stream_class.htm#otl_var_raw">otl_var_raw</a>=23;<br>
            <br>
            </span></li>
          <li>A new OTL defined exception:<br>
            <br>
            <font size="+1"><b>Code=<a href="otl3_exc_list.htm#raw1">32029</a>:</b>
RAW value cannot be read with otl_lob_stream, use otl_long_string
instead<br>
            <br>
            </font><span style="font-family: monospace;"></span></li>
          <li>Three new #defines in order to provide proper backward
compatibility in the context of the new data type raw[XXX]:<br>
            <br>
#define <a href="otl3_compile.htm#OTL_MAP_SQL_VARBINARY_TO_RAW_LONG">OTL_MAP_SQL_VARBINARY_TO_RAW_LONG</a>,
            <br>
#define <a href="otl3_compile.htm#OTL_MAP_SQL_GUID_TO_CHAR">OTL_MAP_SQL_GUID_TO_CHAR</a>,
            <br>
#define <a href="otl3_compile.htm#OTL_MAP_SQL_BINARY_TO_CHAR">OTL_MAP_SQL_BINARY_TO_CHAR
(MS SQL TIMESTAMPs)</a><br>
            <span style="font-family: monospace;"></span><span
 style="font-family: monospace;"> </span><br>
For more detail on how to use raw[XXX], see the following code examples:<br>
&nbsp;<span style="font-family: monospace;"></span></li>
          <ul>
            <li>Oracle (<a href="otl4_ex446.htm">446</a>, <a
 href="otl4_ex447.htm">447</a>, <a href="otl4_ex457.htm">457</a>, <a
 href="otl4_ex458.htm">458</a>)<br>
            </li>
            <li>MS SQL (<a href="otl4_ex448.htm">448</a>, <a
 href="otl4_ex449.htm">449</a>, <a href="otl4_ex459.htm">459</a>, <a
 href="otl4_ex460.htm">460</a>)<br>
            </li>
            <li>Sybase (<a href="otl4_ex450.htm">450</a>, <a
 href="otl4_ex451.htm">451</a>, <a href="otl4_ex461.htm">461</a>, <a
 href="otl4_ex462.htm">462</a>)<br>
            </li>
            <li>MySQL (<a href="otl4_ex452.htm">452</a>, <a
 href="otl4_ex453.htm">453</a>, <a href="otl4_ex463.htm">463</a>, <a
 href="otl4_ex464.htm">464</a>)<br>
            </li>
            <li>PostgreSQL (<a href="otl4_ex454.htm">454</a>, <a
 href="otl4_ex465.htm">465</a>) <br>
            </li>
            <li>MAX-DB / SAP-DB (<a href="otl4_ex455.htm">455</a>, <a
 href="otl4_ex456.htm">456</a>, <a href="otl4_ex466.htm">466</a>, <a
 href="otl4_ex467.htm">467</a>)<br>
            </li>
          </ul>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.139):<br>
        <br>
        <ul>
          <li><a name="type_punned"></a>The following g++ 4.1.0
compilation warnings have been
fixed in this release:<br>
            <br>
            <span style="font-family: monospace;">../include/otlv4.h:
In member function 'void otl_conn::error(otl_exc&amp;)':</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">../include/otlv4.h:9126:
warning: dereferencing type-punned pointer will break</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">strict-aliasing rules</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">../include/otlv4.h:
In member function 'void otl_cur::error(otl_exc&amp;)':</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">../include/otlv4.h:10835:
warning: dereferencing type-punned pointer will break</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">strict-aliasing rules</span><br
 style="font-family: monospace;">
            <br>
          </li>
          <li>A set of new <a href="otl4_sybsql_examples.htm">code
examples</a> for Sybase.</li>
        </ul>
        <br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;"><a name="40138"></a>New (in
OTL 4.0.138):<br>
        <br>
        <ul>
          <li>A missing dependency of #define <a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a>
on #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a> has
been added to this release.<br>
            <br>
          </li>
          <li><a href="otl3_lob_stream.htm">otl_lob_stream</a> required
the total length of a LOB to be <a href="otl3_lob_stream.htm#set_len">set</a>
before the first chunk of the LOB
gets written to the LOB stream. This release has relaxed the
requirement:
OTL/ODBC/DB2-CLI eliminates the requirement completely, and
OTL/OCI8i/9i/10g can be used with otl_long_string::<a
 href="otl3_long_string.htm#set_last_piece">set_last_piece</a>()
instead. For more detail, see examples <a href="otl4_ex385.htm">385 </a>(Oracle),
            <a href="otl4_ex386.htm">386</a> (Oracle) <a
 href="otl4_ex387.htm">387</a> (DB2),&nbsp; <a href="otl4_ex388.htm">388</a>
(DB2), <a href="otl4_ex389.htm">389</a> (MS SQL), <a
 href="otl4_ex390.htm">390</a> (MS SQL), <a href="otl4_ex391.htm">391</a>
(MySQL), <a href="otl4_ex392.htm">392</a> (MySQL), <a
 href="otl4_ex393.htm">393</a> (PostgreSQL), <a href="otl4_ex394.htm">394</a>
(MAX/DB), <a href="otl4_ex395.htm">395</a> (MAX/DB), </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.137):<br>
        <br>
        <ul>
          <li>The following comment was incorrect (turns out people
read comments :-) )<br>
            <br>
            <span style="font-family: monospace;">// in case if it's
ODBC for Windows, include windows.h file<br>
            <br>
            </span>and was changed to<br>
            <br>
            <small><small><small><small><small><small><small><small><small><small><small><small><small><small><span
 style="font-family: monospace;">// in case if it's ODBC for Windows
(!OTL_ODBC_UNIX), and windows.h is </span><span
 style="font-family: monospace;">not included yet (_WINDOWS_ not
defined yet), then include the file</span><span
 style="font-family: monospace;"> explicitly<br>
            </span><br style="font-family: monospace;">
            </small></small></small></small></small></small></small></small></small></small></small></small></small></small></li>
          <li>The following minor warning for Borland C++ 6.0 was fixed:<br>
            <pre wrap="">"[C++ Warning] otlv4.h(19678): W8071 Conversion may cause loss of significant digits"<br><br></pre>
          </li>
          <li>OTL/ODBC/DB2-CLI, otlv4.h, line 13285, an OTL trace macro
call was incorrect:<br>
            <br>
            <span style="font-family: monospace;">&nbsp;&nbsp;
OTL_TRACE_WRITE(n,"operator &gt;&gt;","BIGINT");<br>
            <br>
            </span>and was replaced with<br>
            <br>
            <span style="font-family: monospace;">&nbsp;&nbsp;
OTL_TRACE_READ(n,"operator &gt;&gt;","BIGINT");<br>
            <br>
            </span>The incorrect OTL trace macro call caused a program
crash on AIX with DB2 CLI.<br>
            <br>
          </li>
          <li>OTL introduces two new operators <a
 href="otl3_lob_stream.htm#read_string">&gt;&gt;</a>(string&amp;) and <a
 href="otl3_lob_stream.htm#write_string">&lt;&lt;</a>(string&amp;) to
the <a href="otl3_lob_stream.htm">OTL LOB Stream</a> for reading and
writing std::strings (STL), or ACE_TStrings (ACE). For more detail. see
also examples <a href="otl4_ex379.htm">379</a>, <a
 href="otl4_ex380.htm">380</a>, <a href="otl4_ex381.htm">381</a>, <a
 href="otl4_ex382.htm">382</a>, <a href="otl4_ex383.htm">383</a>, <a
 href="otl4_ex384.htm">384</a>.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.136), updated:<br>
        <br>
        <ul>
          <li>I got the same question from a few developers about
whether OTL officially supported MS SQL 2005 or not. Now the answer is
Yes. I downloaded MS SQL 2005 XE, which can be freely used, installed
it,
and extended the OTL internal test suite to run against MS SQL 2005.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.136):<br>
        <br>
        <ul>
          <li>This release fixes a bug similar to <a
 href="OTL_UNICODE_ERROR">this old bug</a>. The difference between the
new bug and the old bug is that the new bug happens when an output
parameter in a stored procedure is used.<br>
            <br>
          </li>
          <li>New code example has been added for OTL/OCI8i/9i/10g to
show how to use CLOB/BLOBs with PL/SQL stored procedures and the LOB
stream mode. See example <a href="otl4_ex378.htm">378.</a><br>
            <br>
          </li>
          <li>Several type cast related compilation warnings have been
fixed in OCIBindByName() calls.<br>
            <br>
          </li>
          <li>When an OTL stream is being opened with a SELECT
statement that contains a column of an unsupported data type, the
program may crash. For example, the following SELECT crashes the
program (OTL/OCI8i/OCI9i/OCI10g):<br>
            <br>
&nbsp;&nbsp;&nbsp;<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
select * from sys.ku$_library_view</span><br>
            <br>
This SELECT actually contains an Oracle Object column, which OTL does
not support. The problem has been fixed in this release. Instead of
crashing the program, OTL will throw the following <a
 href="otl3_exc_list.htm">OTL defined</a> exception:<br>
            <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <span style="font-family: monospace;">Unsupported column
data type, code <a href="otl3_exc_list.htm#32028">32028</a><br>
            </span><span style="font-family: monospace;"><br>
            </span></li>
          <li>The following new functions have been added to the <a
 href="otl3_compile.htm#OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE">otl_read_stream_interface</a>,
and to the <a href="otl4_refcur_stream.htm">otl_refcur_stream</a> (the
functions do the same thing as the corresponding functions in the <a
 href="otl3_stream_class.htm">otl_stream</a> class):<br>
            <br>
          </li>
          <ul>
            <li><small><small><small><small><small><span
 style="font-family: monospace;">otl_var_desc*
describe_out_vars(int&amp; desc_len);</span></small></small></small></small></small></li>
            <li><span style="font-family: monospace;">otl_var_desc*
describe_next_out_var(void);</span><br>
              <span style="font-family: monospace;"><br>
              </span></li>
          </ul>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.135):<br>
        <br>
OTL had limits on how many bind variables / SELECT output columns it
could handle. The limits were as
follows:<br>
        <br>
        <ul>
          <li>512 for OTL/ODBC, OTL/DB2 CLI, OTL/OCI7</li>
          <li>1024 for OTL / OCI8/8i/9i/10g<br>
            <br>
          </li>
        </ul>
The OTL limits were supposed to match the actual limits of the
underlying database APIs. As more versions of databases come out, the
limits change.&nbsp; This release eliminates any&nbsp; practical limits
on the maximum number of bind variables / SELECT output columns. The
limits on the underlying database APIs still exist.When the limit on,
say, database type A, is reached, OTL would throw an otl_exception. The
actual error code and error message is database specific, and it's not
defined by OTL.<br>
        <br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.134):<br>
        <br>
        <ul>
          <li>When <a href="otl3_compile.htm#OTL_ODBC">OTL_ODBC </a>/
            <a href="otl3_compile.htm#OTL_DB2_CLI">OTL_DB2_CLI</a>
and&nbsp; <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> are
defined, OTL doesn't compile with older C++ compilers that don't have
support for template member functions. The error is fixed in this
release.</li>
          <br>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.133):<br>
        <br>
        <ul>
          <li>When a DB2 BLOB table column has a smaller maximum size
in its definition than the actual BLOB value being written to the BLOB
column in the <a href="otl3_stream_class.htm#set_lob_stream_mode">LOB
stream mode</a>, OTL throws an exception with no error message, and a
random error code. The error is fixed in this release.<br>
            <br>
          </li>
          <li>When compiled with GNU C++ 4.1.0, OTL generates the
following compilation warning: <br>
            <br>
&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;"><small><small><small><small><small><small><small><small><small><small><small><small><small><small><small>dereferencing
type-punned pointer will <br>
&nbsp; break strict-aliasing rules</small></small></small></small></small></small></small></small></small></small></small></small></small></small></small></span>
            <p><span style="font-family: monospace;"></span></p>
            <br>
The warning was actually fixed in OTL 4.0.132.<br>
            <br>
          </li>
          <li>When OTL is used with <a href="http://boost.org">boost</a>'s
date_time, VC++ generates
the following error message:&nbsp; error
C2668: 'isspace' : ambiguous call to overloaded function. The error is
fixed in this release.<em><br>
            </em><br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.132):<br>
        <br>
        <ul>
          <li>OTL doesn't compile with Visual C++ 7.1 when the
following #define's are enabled:<br>
            <br>
            <span style="font-family: monospace;">#define OTL_ORA8I or
ORA9I ORA10G or ORA10G_R2</span><br>
            <span style="font-family: monospace;">#define OTL_UNICODE<br>
#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
#define OTL_UNICODE_STRING_TYPE std::wstring</span><br>
            <span style="font-family: monospace;">#define
OTL_TRACE_LEVEL my_trace_level </span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">#define
OTL_TRACE_STREAM wcerr </span><br style="font-family: monospace;">
            <span style="font-family: monospace;">#define
OTL_TRACE_LINE_PREFIX "MY OTL TRACE ==&gt; " <br>
            <br>
            </span>Error is fixed in this release<br>
            <br>
          </li>
          <li>When Unicode is enabled for Oracle 8i/9i/10g, and the <a
 href="otl3_stream_class.htm#set_lob_stream_mode">LOB stream mode</a>
is used, <a href="otl3_lob_stream.htm">otl_lob_stream</a> doesn't
return a CLOB/NCLOB correctly. More specifically, if the length of a
CLOB/NCLOB is at least 2-3 times larger than the buffer size which the
CLOB/NCLOB is being fetched through. The error is due to the fact that
the OCI returns the size of the second chunk of the CLOB/NCLOB to be
fetched that is equal in size to the buffer in bytes instead of Unicode
characters. The error is fixed in
this release.<br>
            <br>
          </li>
          <li><a name="OTL_UNICODE_ERROR"></a>When the following
#define's are enabled:<br>
            <br>
            <span style="font-family: monospace;">#define OTL_ORA8I or
ORA9I ORA10G or ORA10G_R2</span><br>
            <span style="font-family: monospace;">#define OTL_UNICODE<br>
#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
#define OTL_UNICODE_STRING_TYPE std::wstring</span><br>
            <span style="font-family: monospace;"><br>
            </span>otl_stream::operator&gt;&gt;(OTL_UNICODE_STRING_TYPE&amp;)
returns incorrect values of Unicode strings in the following scenario:<br>
            <br>
            <span style="font-family: monospace;">ABCD</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">ABC</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">AB</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">A</span><br
 style="font-family: monospace;">
            <br>
The actual output is:<br>
            <br>
            <span style="font-family: monospace;">ABCD</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">ABCD</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">ABCD</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">ABCD</span><br
 style="font-family: monospace;">
            <br>
This happens because the OCI doesn't guarantee in some very special
cases Unicode strings to be null terminated. The error is fixed in this
release.<br>
            <br>
          </li>
          <li>When these #defines are enabled:<br>
            <br>
            <span style="font-family: monospace;">#define OTL_UNICODE<br>
#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
#define OTL_UNICODE_STRING_TYPE my_wide_char_string<br>
            <br>
            </span>In case if <span style="font-family: monospace;">my_wide_char_string
            </span>is not<span style="font-family: monospace;"> 1</span>00%
compatible with std::wstring, OTL doesn't compile because it uses
strng::assing(charT* c,size_t len) function to make a string value out
of a raw chararcter buffer + the string length. In order to wortk
around the problem, this release introduces the following new #define:<br>
            <br>
            <span style="font-family: monospace;">#define <a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR">OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR</a></span><br>
            <span style="font-family: monospace;"></span><br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.131):<br>
        <br>
        <ul>
          <li>In this release, Oracle 9i / 10g's INTERVAL data types
get mapped to char[XXX] on SELECT statements by default when #define <a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> is
enabled<br>
            <br>
          </li>
          <li>OCI 8i / 9i may generate ORA-01461 error when <a
 href="otl3_compile.htm#OTL_UNICODE">Unicode</a>
is enabled, and when the SQL statement is a SELECT with two (or more)
VARCHAR2(4000), or NVARCHAR2(2000) columns. The error was fixed in OTL <a
 href="#40111">4.0.111</a>. However, the fix prevented big
VARCHAR2(4000&lt;X&lt;32000) / NVARCHAR2(2000&lt;X,&lt;16000) bindings
in the case of PL/SQL blocks. As a workaround, this release introduces
the following new <span style="font-family: monospace;">#define <a
 href="otl3_compile.htm#OTL_ORA_MAX_UNICODE_VARCHAR_SIZE">OTL_ORA_MAX_UNICODE_VARCHAR_SIZE</a></span>.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.130):<br>
        <br>
        <ul>
          <li>When #define OTL_ORA9I, #define
OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE, and #define OTL_DEFINE
are enabled at the same time, the OTL header doesn't compile / has
compilation error about "otl_stream being an abstract class". The error
is fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.129):<br>
        <br>
        <ul>
          <li>Two new functions for <a href="otl3_connect_class.htm">otl_connect</a>:<br>
            <br>
          </li>
          <ul>
            <li><a href="otl3_connect_class.htm#direct_exec">direct_exec</a>(),
by common sense<br>
            </li>
            <li><a href="otl3_connect_class.htm#syntax_check">syntax_check</a>(),
by the request from the <a href="http://tora.sf.net">TORA</a> project
people<br>
              <br>
            </li>
          </ul>
          <li>Updated the <a href="links.htm">Links</a> page with
"Instructions
on how to use OTL with PostgreSQL in <a
 href="http://www.geocities.com/ccrosetti/otlw/">Windows</a> and <a
 href="http://www.geocities.com/ccrosetti/otl/index.html"><span
 style="text-decoration: underline;">Solaris</span></a>
from <a href="http://www.geocities.com/ccrosetti/">Carlos Crosetti</a>.<br>
            <br>
          </li>
          <li>Updated my <a href="skuchin_resume.htm">resume</a> to
better reflect reality.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.128):<br>
        <br>
        <ul>
          <li><span style="font-family: monospace;">otl_connect&amp;
operator&gt;&gt;(otl_connect&amp; connect, otl_stream&amp; s)</span>
should have been declared as <span style="font-style: italic;">inline</span>,
but it wasn't, which caused a "duplicate symbol" linker error. The bug
is fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;"><a name="OTL40127"></a>New (in
OTL 4.0.127):<br>
        <br>
        <ul>
          <li>Code cleanup: From now on, OTL uses template member
functions by default for C++ compilers that support the feature.
However, some C++ compilers have no support for the feature, or have
bugs in supporting the feature. The following new #define can be used
to make OTL fall back on
the old proven nontemplate member functions in case if OTL compiles
with errors: #define <a
 href="otl3_compile.htm#OTL_NO_TMPL_MEMBER_FUNC_SUPPORT">OTL_NO_TMPL_MEMBER_FUNC_SUPPORT.<br>
            <br>
            </a></li>
          <li>OTL for OCI8/8i/9i/10g didn't map Oracle ROWID / UROWID
type to a char[XXX] correctly. The bug is fixed in this release. The
problem was that the OCI internal data type code for ROWID was
different
from what was described in the OCI reference guide.<br>
            <br>
          </li>
          <li>OTL tries to follow the latest / modern trends in C++ in
cases when it makes sense. Some C++ libraries try to overload operator
&gt;&gt; / &lt;&lt;, operator comma, operator parens, etc.,&nbsp; and
provide more syntax rich
context for developers. <a href="http://boost.org">Boost</a>.org is
one good example of that. Another, though a much smaller example, is <a
 href="http://soci.sf.net">soci</a>. I've been asked a few times to
introduce something similar in OTL. This release introduces several new
operators in <a href="otl3_connect_class.htm">otl_connect:</a>
operator <a href="otl3_connect_class.htm#operator_gg">&gt;&gt;</a>(<a
 href="otl3_stream_class.htm">otl_stream</a>&amp;), <a
 href="otl3_connect_class.htm#operator_ll">&lt;&lt;</a>(const char*), <a
 href="otl3_connect_class.htm#operator_lle">&lt;&lt;=</a>(const char*).
For more detail, see example <a href="otl4_ex371.htm">371</a>, <a
 href="otl4_ex372.htm">372</a>, <a href="otl4_ex373.htm">373</a>, <a
 href="otl4_ex374.htm">374</a>, <a href="otl4_ex375.htm">375</a>, <a
 href="otl4_ex376.htm">376</a>, <a href="otl4_ex377.htm">377</a>. <br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.126):<br>
        <br>
        <ul>
          <li>#define <a href="otl3_compile.htm#OTL_ORA_OCI_ENV_CREATE">OTL</a><a
 href="otl3_compile.htm#OTL_ORA_OCI_ENV_CREATE">_ORA_OCI_ENV_CREATE</a>,
            <a href="otl3_compile.htm#OTL_ORA_OCI_ENV_CREATE_MODE">OTL_ORA_OCI_ENV_CREATE_MODE</a>.
A discussion has been going on for years about whether the old scheme
of OCIInialize()+OCIEnvInit() for initializing OCI environment handles
doesn't work any more, and should be replaced with the new scheme of
OCIEnvCreate(). Oracle documentaion says that the old scheme should be
eliminated. The old scheme seems to work fine, and the discussion has
gone nowhere. In the future, when more extensive support for Unicode in
OTL/OCIx gets implemented (Unicode user id, password, etc.), only then
OCIEnvCreate() will become indispensible. For more detail, see
otl_connect::<a href="otl3_connect_class.htm#rlogon_xa">rlogon</a>(), <a
 href="otl3_connect_class.htm#server_attach">server_attach</a>().<br>
            <br>
          </li>
          <li>Following new #defines: <a
 href="otl3_compile.htm#OTL_EXCEPTION_ENABLE_ERROR_OFFSET"><span
 style="font-family: monospace;">OTL_EXCEPTION_ENABLE_ERROR_OFFSET</span></a>,
            <span style="font-family: monospace;"><a
 href="otl3_compile.htm#OTL_EXCEPTION_STM_TEXT_SIZE">OTL_EXCEPTION_STM_TEXT_SIZE</a>.</span><br>
            <br>
          </li>
          <li>Support for Large Unicode Objects (NTEXT, NCLOB, etc.)
was overlooked for otl_stream::operators &gt;&gt;/&lt;&lt;(<a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a>&amp;).
This release fixes the problem. For more detail, see example <a
 href="otl4_ex366.htm">366</a>,&nbsp; <a href="otl4_ex367.htm">367</a>,
            <a href="otl4_ex368.htm">368,</a> <a href="otl4_ex369.htm">369</a>,
            <a href="otl4_ex370.htm">370</a>.<br>
            <br>
          </li>
          <li>A memory leak was reported when OTL stream <a
 href="otl3_stream_pooling.htm">pooling</a> is on (#define <a
 href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>),
and there are SELECT output column <a
 href="otl3_bind_variables.htm#SELECT_OVERRIDE">overrides</a>.<br>
The bug is fixed in this release.<br>
            <br>
          </li>
          <li>otl_sconnect::<a
 href="otl3_connect_class.htm#set_stream_pool_size">set_stream_pool_size</a>()
needs to check for the stream pool size. When the stream size is 1 then
the program crashes. The bug is fixed in this release.<br>
            <br>
          </li>
          <li>When <a href="otl3_compile.htm#OTL_ACE">OTL_ACE</a> is
enabled, OTL defines otl_stream::operator &gt;&gt;/&lt;&lt; for
ACE_TString. In order to assign a NULL terminated string value from the
otl_stream internal buffer to the output string in
operator&gt;&gt;(ACE_TString&amp; s), OTL used the following assignment:<br>
            <br>
&nbsp; &nbsp;&nbsp; <span style="font-family: monospace;">s=&lt;pointer
to internal char* buffer&gt;;</span><br>
            <br>
It turns out that ACE_TString doesn't have <span
 style="font-family: monospace;">operator=(const char*)</span>. So, the
assignment generates a temporary variable plus 2 extra calls to the
heap
manager. This release fixes the inefficiency by using
ACE_TString::set() instead:<br>
            <br>
&nbsp; &nbsp;&nbsp; <span style="font-family: monospace;">s.set(&lt;pointer&gt;,1);</span><br>
            <br>
          </li>
          <li>VC++ 8.0 (Visual Studio 2005) compiles clean now.<span
 style="font-family: monospace;"></span><br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.125):<br>
        <br>
        <ul>
          <li>Support for Unicode ODBC drivers was inadvertently tied
up to #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>.
From this release
and on, when Unicode ODBC driver support is enabled in general in the
ODBC header files (via #define UNICODE / _UNICODE), OTL also generates
SQLxxxW calls, regardless of whether OTL_UNICODE is defined or not.<br>
            <br>
          </li>
          <li>#define <a
 href="otl3_compile.htm#OTL_DEFAULT_STRING_NULL_TO_VAL">OTL_DEFAULT_STRING_NULL_TO_VAL</a>
serves its purpose reasonably well. It covers operations with both
char* (one-byte, Unicode) and C++ string classes (the use of which can
be enabled via&nbsp; <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>, <a
 href="otl3_compile.htm#OTL_ACE">OTL_ACE,</a> <a
 href="otl3_compile.htm#OTL_STLPORT">OTL_STLPORT</a>, <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">OTL_USER_DEFINED_STRING_CLASS</a><a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">_ON</a>, <a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a>).
Normally, string NULLs get defaulted to an empty string. In the case of
C++ string classes, an actual string variable can be reinitialized more
efficiently than assigning an empty string to it. This release
introduces the following #define to do just that: <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL">OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL</a><br>
            <br>
          </li>
          <li><a
 href="otl3_compile.htm#OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT">#define
OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT</a>. A workaround for an
MS SQL Server bug when Unicode is enabled.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.124):<br>
        <br>
        <ul>
          <li><a href="otl4_stream_read_iterator.htm">otl_stream_read_iterator</a>::is_null()
returns results that are the opposite to what they are supposed to be.
The bug
is fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.123):<br>
        <br>
        <ul>
          <li>OTL 4.0.122 introduced support for the MS SQL <a
 href="#TIMESTAMP_40122">TIMESTAMP</a> / RowVersion data type. This
release introduces support for the same data type when #define <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a> is enabled.
TIMESTAMP / RowVersion values get converted into char[17]. Only in this
case the characters are 2-byte Unicode characters. <br>
            <br>
          </li>
          <li>When the same otl_stream variable gets reused multiple
times, and <a href="otl3_stream_class.htm#describe_select">describe_select</a>()
is used, <a href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>
may return an incorrect <span style="font-style: italic;">name</span>
(column name). It happens when names for, say, column 1, from two
consecutive calls to describe_select() had the same length. The bug is
fixed in this release.<br>
            <br>
          </li>
          <li>OTL had only basic support for Unicode string data, and
it didn't support Unicode userid/password@DSN,&nbsp; Unicode error
messages, Unicode ODBC drivers, and Unicode SQL. This release
takes a few steps further and implements the following features:<br>
            <br>
          </li>
          <ul>
            <li><span style="font-style: italic;">Support for Unicode
ODBC drivers</span>. Unicode may be enabled for ODBC / DB2 CLI by
defining <span style="font-family: monospace;">#define UNICODE</span>
and/or <span style="font-family: monospace;">#define _UNICODE</span>.
The <span style="font-family: monospace;">#define</span>s enable the
Unicode ODBC function prototypes. Starting with this release and
on,&nbsp; OTL uses Unicode ODBC functions when&nbsp; the <span
 style="font-family: monospace;">#define UNICODE </span>/<span
 style="font-family: monospace;"> _UNICODE</span> is enabled / defined
(for example, when a project in Visual C++ Studio enables Unicode).<br>
              <br>
            </li>
            <li><span style="font-style: italic;">Support for Unicode
userid/password@DSN. </span>A new otl_connect::<a
 href="otl3_connect_class.htm#logon_odbc_unicode">rlogon</a>()
implements the feature when #define<br>
              <a
 href="otl3_compile.htm#OTL_UNICODE_EXCEPTION_AND_RLOGON">OTL_UNICODE_EXCEPTION_AND_RLOGON
              </a>is enabled. <br>
              <br>
For more detail, see example <a href="otl4_ex365.htm">365</a>.<br>
              <br>
            </li>
            <li><span style="font-style: italic;"> Unicode error
messages, </span>when #define <a
 href="otl3_compile.htm#OTL_UNICODE_EXCEPTION_AND_RLOGON">OTL_UNICODE_EXCEPTION_AND_RLOGON
              </a>is enabled.<br>
              <br>
For more detail, see example <a href="otl4_ex365.htm">365</a>.<br>
              <br>
            </li>
          </ul>
          <li>This release introduces two new #defines:<br>
            <br>
          </li>
          <ul>
            <li><a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE
(support for operators &gt;&gt;/&lt;&lt; for&nbsp; Unicode characters)<br>
              </a></li>
            <li><a href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE
(support for operators &gt;&gt;/&lt;&lt; for Unicode std::wstrings)</a><br>
              <br>
            </li>
          </ul>
        </ul>
        <div style="margin-left: 40px;">For more detail, see the
following examples:<br>
        <br>
        <ul>
          <li>For Oracle: <a href="otl4_ex351.htm">351</a>, <a
 href="otl4_ex352.htm">352</a>, <a href="otl4_ex353.htm">353</a>, <a
 href="otl4_ex354.htm">354</a>.</li>
          <li>For DB2: <a href="otl4_ex355.htm">355</a>, <a
 href="otl4_ex356.htm">356</a>, <a href="otl4_ex357.htm">357</a>, <a
 href="otl4_ex358.htm">358</a>.</li>
          <li>For MS SQL: <a href="otl4_ex359.htm">359</a>, <a
 href="otl4_ex360.htm">360</a>.</li>
          <li>PostgreSQL: <a href="otl4_ex361.htm">361</a>, <a
 href="otl4_ex362.htm">362</a>.</li>
          <li>SAP/MAX DB: <a href="otl4_ex363.htm">363</a>, <a
 href="otl4_ex364.htm">364</a>.<br>
          </li>
        </ul>
        <br>
        </div>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (int OTL 4.0.122):<br>
        <br>
        <ul>
          <li>There was a typo in "<span style="font-family: monospace;">otl_output_iterator&lt;T&gt;<big>&amp;</big>
operator++(int)</span>". It should be: "<span
 style="font-family: monospace;">otl_output_iterator&lt;T&gt;
operator++(int)". </span>The typo / bug is fixed in this release. The
scope of this bug is not quite clear. It depends on the actual
implementation of the STL library for different C++ compilers. So far,
I have not seen any of my tests to crash, or deliver incorrect data
sets.<br>
            <br>
          </li>
          <li><a name="TIMESTAMP_40122"></a>MS SQL has a rarely used
data type: TIMESTAMP. It has
nothing to do with calendar date/time.&nbsp; The TIMESTAMP type could
be used to implement the optimistic locking scheme. Say, a table has a
TIMESTAMP column, and a row in the table is being changed. The
TIMESTAMP gets changed by the database server itself as any column in
the row changes its value. The rest in the implementation of the
optimistic locking scheme is clear: the row gets read once at the very
beginning, then the TIMESTAMP of the row needs to be read one more time
right before the change gets made in order to make sure that nobody
else (no other user) has already changed the row. OTL didn't have any
default support for such a data type. In this release and on, all
TIMESTAMP table columns will be mapped to char[17], which will make the
MS SQL ODBC driver convert the TIMESTAMP value to a 16 character, null
terminated hexadecimal string. For pre-4.0.122 releases of OTL, the OTL
data type&nbsp; for TIMESTAMP table columns could be explicitly
overriden either via <a href="otl3_bind_variables.htm#SELECT_OVERRIDE">:#N&lt;char[17]&gt;</a>
notation, where N is 1,2,3..., or via otl_stream::<a
 href="otl3_stream_class.htm#set_column_type">set_column_type</a>().<br>
            <br>
          </li>
          <li>This release introduces new "<a
 href="otl4_stream_read_iterator.htm#get_by_name">get by name</a>" <span
 style="font-style: italic;">getter</span> functions in the <a
 href="otl4_stream_read_iterator.htm">OTL stream read iterator template
class</a>.&nbsp; For more detail, see examples <a href="otl4_ex339.htm">339</a>,
            <a href="otl4_ex340.htm">340</a>, <a href="otl4_ex341.htm">341</a>,
            <a href="otl4_ex342.htm">342</a>.<br>
            <br>
          </li>
          <li>In OTL 4.0.119 the third OTLLobStream class type
parameter was <a href="#OTL40119">added</a> to the<a
 href="otl4_stream_read_iterator.htm"> OTL stream read iterator
template
class</a>. <a href="otl3_lob_stream.htm">otl_lob_stream</a> is not
supported under #define <a href="otl3_compilr.htm#OTL_ORA7">OTL_ORA7</a>,
so the stream read template class&nbsp; was corrected and now has only
two class type parameters as before OTL 4.0.119.<br>
            <br>
          </li>
          <li><span style="text-decoration: underline;"></span>PostgreSQL
8.1 was recently released. PostgreSQL 8.1 ODBC driver seems to support
the bulk interface (otl_stream buffer sizes can be &gt; 1). ODBC
Unicode driver seems to work. A few new code examples have been added
in this release:&nbsp; <a href="otl4_postgresql_examples.htm">342,
345-350</a>.<br>
            <br>
          </li>
          <li><a href="otl4_stream_read_iterator.htm">OTL stream read
iterator
template
class</a>, when compiled with GNU C++ 2.95-96, or GNU C++ 4.0 on
Solaris, may cause a runtime "bus error". A similar bug was fixed in <a
 href="#OTL40114">OTL 4.0.114</a>. It looks like the recent "bus error"
bug is specific to GNU C++, because the exact same code runs
successfully when compiled with Forte C++. The problem is in memory
address alignment,. Definitely. GNU C++ does something different from
Forte C++. Internal memory allocation was rewritten in the stream read
iterator class in order to avoid further memory address alignment
problems.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New ( in OTL 4.0.121):<br>
        <br>
        <ul>
          <li>OTl 4.0.120 stopped compiling with VC++ 6.0. By popular
demand, the feature is back. I didn't actually realize that until
several people pointed that out.<br>
            <br>
          </li>
          <li>Under certain circumstanes, OTL/OCI8i/9i/10g in the LOB
stream mode, when a CLOB/BLOB value is being updated from a bigger to a
smaller size, may trim the old CLOB/BLOB value incorrectly, or not trim
the value at all. The bug is fixed in this release. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.120):<br>
        <br>
        <ul>
          <li>OTL now compiles clean under 64-bit VC++ (_WIN64).<br>
            <br>
          </li>
          <li>OTL introduces the following new function: otl_connect::<a
 href="otl3_connect_class.htm#commit_nowait">commit_nowait</a>(). The
function calls the corresponding OCI 10g Release 2 (Oracle 10.2)
function to perform an asynchronous commit, which is a new feature of
Oracle 10.2. Also, see example <a href="otl4_ex321.htm">321</a>. <br>
            <br>
          </li>
          <li>OTL introduces general support for <a
 href="http://www.mysql.com/products/maxdb/">MAX-DB / SAP-DB</a>. See
examples <a href="otl4_sap_db_examples.htm">322-338</a> for more
detail.<br>
            <br>
          </li>
          <li>SQL statement parser in OTL stream didn't parse the
following correctly:&nbsp; <br>
            <br>
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
...'foo/*'...:A&lt;int,in&gt; := ...</span><br>
            <br>
What happens is that when a comment beginning character sequence "<span
 style="font-family: monospace;">/*</span>" is present inside a string
literal, the parser misinterprepts it and skips the bind variable,
which is part of the SQL statement. <br>
            <br>
The bug is fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.119):<br>
        <br>
        <ul>
          <li><a href="otl4_stream_read_iterator.htm">otl_stream_read_iterator</a>
now supports <a href="otl3_lob_stream.htm">otl_lob_stream</a>'s via
the following get function: void <a
 href="otl4_stream_read_iterator.htm#get_lob_stream_ptr">get</a>(otl_lob_stream*&amp;).
For more detail, see examples <a href="otl4_ex315.htm">315</a>, <a
 href="otl4_ex316.htm">316</a>, <a href="otl4_ex317.htm">317</a>, <a
 href="otl4_ex318.htm">318</a>, <a href="otl4_ex319.htm">319</a>, <a
 href="otl4_ex320.htm">320</a>. <br>
            <br>
            <span style="font-style: italic;"><a name="OTL40119"></a>NOTE:</span>
otl_stream_read_iterator has one more class parameter: OTLLobStream. It
needs to be added to the actual parameter list.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.118):<br>
        <br>
        <ul>
          <li>When a char/string bind variable is declared as
:var&lt;char(XXX)&gt; instead of :var&lt;char[XXX]&gt;, the program
crashes with "Memory Access Violation" / "Segmentation Violation". What
happens is that OTL tries to access memory beyond an allocated memory
block. The bug is fixed in this release.<br>
            <br>
          </li>
          <li>This release of OTL and higher support <a
 href="otl3_bind_variables.htm#char">char</a>(XXX) as equivalent to
char[XXX] in bind variable declarations.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.117):<br>
        <br>
        <ul>
          <li>When #define <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>
is enabled along with #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
and #define <a href="otl3_compile.htm#OTL_ORA8I">OTL_ORA8I</a>/<a
 href="otl3_compile.htm#OTL_ORA9I">9I</a>/<a
 href="otl3_compile.htm#OTL_ORA10G">10G</a>, OTL throws the folowing
exception / error:<br>
            <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-family: monospace;">ORA-01458: invalid length inside
variable character string <br>
            <br>
            </span>The bug is fixed in this release.<br>
            <span style="font-family: monospace;"><br>
            </span></li>
          <li>Explicit bind variables in output column definitions can
be <a href="otl3_bind_variables.htm#SP_COL_OVERRIDE">defined</a> for
implicit result sets (ODBC/DB2-CLI), or reference cursors (Oracle) the
same way as in <a href="otl3_bind_variables.htm#SELECT_OVERRIDE">SELECT</a>
statements.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.116):<br>
        <br>
        <ul>
          <li>A typo in otlv4.h in OTL 4.0.115 (line 3072) has been
fixed in this release.<br>
            <br>
          </li>
          <li><a href="otl3_stream_class.htm#create_stored_proc_call">otl_stream::create_stored_proc_call(</a>)
has been enhanced to do the following, which actually corresponds the
Oracle standard name resolution::<br>
            <br>
          </li>
          <ul>
            <li>sp in current schema</li>
            <li>private synonym for sp</li>
            <li>public synonym for sp</li>
          </ul>
        </ul>
        <br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.115):<br>
        <br>
        <ul>
          <li>OTL stream <a href="otl3_stream_class.htm#buffer_size">buffer
size</a>'s datatype was changed in this release from <span
 style="font-style: italic;">short int</span> to <span
 style="font-style: italic;">int</span>. See examples <a
 href="otl4_ex307.htm">307</a>, <a href="otl4_ex308.htm">308</a>, <a
 href="otl4_ex309.htm">309</a>, <a href="otl4_ex310.htm">310 </a>for
more detail.<br>
            <br>
          </li>
          <li>New #define <a
 href="otl3_compile.htm#OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE">OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE</a>
is introduced. It can be used to turn the stream old <span
 style="font-style: italic;">short int</span> buffer size back on. <br>
            <br>
          </li>
          <li><a href="otl3_bind_variables.htm#PLSQL_table_size">Maximum
size</a> of PL/SQL tables is no longer limited to 32767. See example <a
 href="otl4_ex311.htm">311</a>, <a href="otl4_ex312.htm">312 </a>for
more detail. #define <a
 href="otl3_compile.htm#OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE">OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE</a>
can also be used to turn the maximum size of PL/SQL tables back on. <br>
            <br>
          </li>
          <li>new <a href="otl3_bind_variables.htm#charz">charz</a>[]
datatype for PL/SQL tables of CHAR(XXX). See example <a
 href="otl4_ex313.htm">313</a>, <a href="otl4_ex314.htm">314 </a>for
more
detail.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.114):<br>
        <br>
        <ul>
          <li>Visual Age C++ (AIX) issues a warning when <a
 href="otl3_compile.htm#OTL_ORA7">OTL_ORA7</a> is enabled. The warning
has been fixed in this release.<br>
            <br>
          </li>
          <li>New #define <a href="otl3_compile.htm#OTL_INFORMIX_CLI">OTL_INFORMIX_CLI</a>
(Informix CLI for Unix) is introduced. It should be used in a
combination with #define <a href="otl3_compile.htm#OTL_ODBC_UNIX">OTL_ODBC_UNIX</a>.
            <br>
            <br>
          </li>
          <li>Basic support for <a href="http://www.timesten.com">TimeTen</a>
via ODBC (#define <a href="otl3_compile.htm#OTL_ODBC">OTL_ODBC</a>).
See examples <a href="otl4_t10_examples.htm">293-299</a> for more
detail.<br>
            <br>
          </li>
          <li>Basic support for Microoft ACCESS <span
 style="text-decoration: underline;"></span>via ODBC (#define <a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ODBC">OTL_ODBC</a>).
See examples <a href="otl4_msaccess_examples.htm">300-306</a> for more
detail.<br>
            <br>
          </li>
          <li><a name="OTL40114"></a>When <a
 href="otl4_stream_read_iterator.htm">OTL
stream read iterator</a> is used with Forte C++ on Solaris, the program
may crash with a "bus error". The problem is that the iterator's
internal buffers need to be aligned to the machine word (requirement on
Solaris). The bug has been fixed in this release. <br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.113):<br>
        <br>
        <ul>
          <li>The following new #define: <span
 style="font-family: monospace;"><a
 href="otl3_compile.htm#OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE">OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE</a>.
            </span>It changes the OTL stream's default behavior for
SELECT statements: SELECT gets prepared, executed, and only then the
SELECT statement columns get described. New versions (PostgreSQL 8.0,
MySQL 5.0 (still in beta)) of some databases require this change.<br>
            <br>
          </li>
          <li>Some fragments of redundant, conditionally compiled code
were cleaned up.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL4.0.112):<br>
        <br>
        <ul>
          <li>Following new #define is introduced in this release:
#define <a
 href="otl3_compile.htm#OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE">OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE</a>.
It enables a common interface class, which both <a
 href="otl3_stream_class.htm">otl_stream</a> and <a
 href="otl4_refcur_stream.htm">otl_refcur_stream</a> derive from. See
also example <a href="otl4_ex292.htm">292</a>.<br>
            <br>
          </li>
          <li>When OTL stream <a href="otl3_stream_pooling.htm">pooling</a>
is enabled (#define <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>),
in the case of a database error, if otl_stream::<a
 href="otl3_stream_class.htm#clean">clean</a>() gets called, it does
not reset some internal flags correctly, so that the stream cannot be
reused without being closed and reopened.&nbsp; The bug is fixed in
this release.<br>
            <br>
          </li>
          <li><a href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>
class was extended in OTL 4.0.110 with the following <a
 href="otl3_stream_class.htm#charset_form">fields</a>: charset_form,
char_size. The fields are enabled with <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a> and&nbsp; #defines
OTL_ORA8i/9i/10g. A mistake
was made for OCI8i: OCI8i does not provide the "char size" information.
The char_size field will be set to 0 instead. If anybody has a
different opinion on this, let me know.</li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.111):<br>
        <br>
        <ul>
          <li>Following new #define is introduced in this release:
#define <a
 href="otl3_compile.htm#OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT">OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT.</a>
See also examples <a href="otl4_ex288.htm">288 (OCI7)</a>, <a
 href="otl4_ex289.htm">289 (OCI8i/9i/10g)</a>, <a href="otl4_ex290.htm">290</a><a
 href="otl4_ex290.htm"> (DB2 CLI)</a>, <a href="otl4_ex291.htm">291</a><a
 href="otl4_ex291.htm"> (MSSQL)</a>.<br>
            <br>
          </li>
          <li><a name="40111"></a>When #define <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
is enabled&nbsp; for OTL/OCI8i/9i/10g, maxmium string size char[XXX]
bind variables (char[4001] for VARCHAR2, and char[2001] for NVARCHAR2
data types) may cause the "Invalid length" Oracle error. The bug is
fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.110):<br>
        <br>
        <ul>
          <li>When&nbsp; #define <a href="otl3_compile.htm#OTL_ODBC">OTL_ODBC</a>
is enabled, and when the OTL header file is being compiled in the <a
 href="http://www.unixodbc.org">unixODBC</a> driver manager
environment, the C++ compiler reports the following wide character
related #defines as missing: SQL_WVARCHAR, SQL_WCHAR, SQL_WLONGVARCHAR,
SQL_C_WCHAR.&nbsp; The compilation errors are fixed is this release.<br>
            <br>
          </li>
          <li><a href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>
class has been extended with the following <a
 href="otl3_stream_class.htm#charset_form">fields</a>: charset_form,
char_size. The fields are enabled when&nbsp; <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a> and <a
 href="otl3_compile.htm#OTLORA9I">OTL_ORA9I</a> / <a
 href="otl3_compile.htm#OTL_ORA10G">OTL_ORA10G</a> are defined. See
also example <a href="otl4_ex287.htm">287</a><br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.109):<br>
        <br>
        <ul>
          <li>OTL/OCI8i/9i/10g introduces the following new bind
variable datatypes: <a href="otl3_bind_variables.htm#nchar">nchar</a>[],
            <a href="otl3_bind_variables.htm#nclob">nclob</a>. nchar[]
is intended for special cases when, say, both VARCHAR2 and NVARCHAR2
need to be declared inthe SQL statement. nclob is useful for cases when
both CLOB and NCLOB need to be declared in the same SQL statement. <br>
            <br>
For
more detail, see examples <a href="otl4_ex285.htm">285</a>, <a
 href="otl4_ex286.htm">286</a>.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;"><a name="otl40108"></a>New (in
OTL 4.0.108):<br>
        <br>
        <ul>
          <li>Basic support for <a href="otl3_compile.htm#OTL_UNICODE">Unicode</a>
data strings in OTL/ODBC and OTL/DB2-CLI. See the following examples
for
more detail:<br>
            <br>
          </li>
          <ul>
            <li><a href="otl4_db2_unicode_examples.htm">DB2 Unicode /
CLI</a></li>
            <li><a href="otl4_mssql_unicode_examples.htm">MS SQL Server
Unicode / ODBC</a></li>
            <li><a href="otl4_ora_odbc_unicode_examples.htm">Oracle
8/8i/9i/10g Unicode / ODBC<br>
              <br>
              </a></li>
          </ul>
          <li>Support for <a href="http://sqlite.org">SQLite</a> via
ODBC. See the <a href="otl4_sqlite_examples.htm">examples</a> for
SQLite for more detail.<br>
            <br>
          </li>
          <li>OTL <a href="otl3_faq.htm">FAQ</a> was updated.<br>
          </li>
        </ul>
        <br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.0.107):<br>
        <br>
        <ul>
          <li>This release is a quick fix for a compilation bug that
was introduced in OTL 4.0.106 along with the support for iODBC for BSD
Unix.</li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.106):<br>
        <br>
        <ul>
          <li>New #define is introduced: #define <a
 href="otl3_compile.htm#OTL_IODBC_BSD">OTL_IODBC_BSD</a>. This #define
should be enabled when the iODBC ODBC driver manager is used in BSD
Unix.<br>
            <br>
          </li>
          <li>OTL/ODBC now supports&nbsp; <a
 href="http://firebird.sourceforge.net/">Firebird Database</a>. See
also the Firebird / ODBC code <a href="otl4_interbase_examples.htm">examples</a>.<br>
            <br>
          </li>
          <li>New <a href="otl3_exception_class.htm">otl_exception</a>
is introduced: <small><font style="font-style: italic;" size="+1"><small>otl_stream::<a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_stream_class.htm#operator_int">operator
int</a>() is not supported in the <a
 href="otl3_stream_class.htm#set_lob_stream_mode">LOB stream mode</a> </small></font><font
 size="+1"><small>(code <a href="otl3_exc_list.htm#32025">32025)</a>.
This exception enforces the </small></font><font
 style="font-style: italic;" size="+1"><small><a
 href="otl3_stream_class.htm#operator_int">operator int()</a></small></font><font
 size="+1"><small> limits.</small></font></small><font
 style="font-style: italic;" size="+1"><a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_stream_class.htm#operator_int"><small><br>
            </small><br>
            </a></font></li>
          <li>otl_stream::<a
 href="otl3_stream_class.htm#stl_string_read">operator&gt;&gt;</a>(std::string)
can read CLOB / LONG / TEXT table columns.When the actual column value
is larger than the stream internal buffer size, and when the value is
being read into an std::string buffer, the program crashes because it
tries to read beyond the stream internal buffer. The bug is fixed in
this release.<br>
            <br>
          </li>
          <li>When #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
is enabled, otl_connect::<a
 href="otl3_connect_class.htm#set_character_set">set_character_set</a>(SQLCS_NCHAR)
is called, and the Oracle database main / default character set is set
to a one-byte chartacter set, double-byte characters with codes greater
than 255 were converted incorretly between the database and the C++
client side. The bug is fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.105):<br>
        <br>
        <ul>
          <li>"static char*" was generating compilation warnings&nbsp;
in a few places. It was replaced with "const char*". <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.104):<br>
        <br>
        <ul>
          <li>When <a href="otl3_bind_variables.htm#db2date">db2date</a>
and <a href="otl3_bind_variables.htm#db2time">db2time</a> bind
variable types are used on a WHERE clause of a SELECT statement / a
stored procedure that returns an implicit result set in a combination
with OTL/ODBC,DB2-CLI, the otl_stream::operator&lt;&lt;(const
otl_datetime&amp;) operator throws the <a
 href="otl3_exc_list.htm#32000">"Incompatible data types in stream
operation"</a> exception. The problem is fixed in this release.<br>
            <br>
          </li>
          <li>When throwing the "Incompatible data types in stream
operation" exception under the condition described above, OTL shows the
actual data type label as an empty string (""). instead of showing
"DB2DATE", or "DB2TIME" as data type labels. The problem is fixed in
this release.<br>
          </li>
        </ul>
        <br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.103):<br>
        <br>
        <ul>
          <li>When the following set of #defines is enabled before
including the OTL header file:<br>
            <br>
            <span style="font-family: monospace;">#define OTL_STL</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">#define OTL_ANSI_CPP</span><br
 style="font-family: monospace;">
            <span style="font-family: monospace;">#define
OTL_FUNC_THROW_SPEC_ON<br>
            </span>
            <p>there is a compilation error in<br>
            <br>
            <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
ostream&amp; operator&lt;&lt;(ostream&amp;, const
otl_value&lt;T&gt;&amp;)<br>
            </span></p>
The problem is fixed in this release.<br>
            <br>
          </li>
          <li>Several duplicate pieces of code were found in the OTL
header file and reported as a bug. It does not have immediate impact on
anything. Conventional wisdom says that duplication is bad, so the
problem is fixed in this release.<br>
            <br>
          </li>
          <li>OTL/ODBC supports MS SQL varbinary data type via
&lt;raw_long&gt; binding and <a href="otl3_long_string.htm">otl_long_string</a>
containers. However, it is not possible to write a varbinary value to a
SELECT...WHERE f2=:f2&lt;raw_long&gt;, because <span
 style="font-family: monospace;">operator&lt;&lt;(otl_stream&amp;,
const otl_long_string&amp;) </span>in OTL does not support SELECT
statements. Historically,, the reason for that was that search
operations on Large Obects were not supported by relational databases.
Then, OTL started supporting varbinary data type via &lt;raw_long&gt;
bindings at some point in time. From this release on, OTL/ODBC supports
writing of &lt;raw_long&gt;'s into a stream for SELECT
statement's&nbsp; WHERE&nbsp; clauses. MS SQL requires an explicit type
cast / conversiuon from "raw long" / image to a varbinary, for example:<br>
          </li>
          <br>
          <span style="font-family: monospace;">&nbsp;&nbsp; SELECT ...</span><br
 style="font-family: monospace;">
          <span style="font-family: monospace;">&nbsp;&nbsp; FROM
test_tab</span><br style="font-family: monospace;">
          <span style="font-family: monospace;">&nbsp;&nbsp; WHERE
f2=cast(:f2&lt;raw_long&gt; as varbinary)</span><br>
or<br>
          <span style="font-family: monospace;">&nbsp;&nbsp; SELECT ...</span><br
 style="font-family: monospace;">
          <span style="font-family: monospace;">&nbsp;&nbsp; FROM
test_tab</span><br style="font-family: monospace;">
          <span style="font-family: monospace;">&nbsp;&nbsp; WHERE
f2=convert(</span><span style="font-family: monospace;">varbinary(256),:f2&lt;raw_long&gt;</span>)<br>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.102):<br>
        <br>
        <ul>
          <li>New #define is introduced: #define <a
 href="otl3_compile.htm#OTL_ODBC_POSTGRESQL">OTL_ODBC_POSTGRESQL</a>.
When PostgreSQL ODBC driver version 3.5 is connected to PostgreSQL 7.4
/ 8.0 and higher, the following sequence of ODBC function calls does
not work any more: SQLPrepare(), SQLDescribeCol. The SELECT statement
needs to be executed before the output columns can be described:
SQLPrepare(), SQLExecute(), SQLDescribeCol(). It is exactly the same
sequence as in handling a stored procedure call that returns a result
set.&nbsp; As a workaround, otl_stream(...,otl_implicit_select) can be
used. The new #define does the same thing. See also PostgreSQL <a
 href="otl4_postgresql_examples.htm">examples</a>.<br>
            <br>
          </li>
          <li>When a password in the OTL connect string is longer than
255 bytes, the program crashes (a.k.a. buffer overflow). The bug has
been fixed in this release.<br>
            <br>
          </li>
          <li>When #define <a
 href="otl3_compile.htm#OTL_EXPLICIT_NAMESPACES">OTL_EXPLICIT_NAMESPACES
            </a>is enabled, ostream&amp; operator&lt;&lt;(ostream&amp;
s, otl_value&lt;T&gt;) gets defined under each namespace, even though <a
 href="otl3_value.htm">otl_value</a>&lt;T&gt; is defined in the default
namespace. The bug has been fixed in this release.<br>
            <br>
          </li>
          <li>When #define <a
 href="otl3_compile.htm#OTL_EXPLICIT_NAMESPACES">OTL_EXPLICIT_NAMESPACES
            </a>is enabled, <a href="otl4_stream_read_iterator.htm">OTL
stream read iterator</a> does not compile. The bug has been fixed in
this release. See also examples&nbsp; <a href="otl3_examples.htm#ex260">260-264</a>.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.101):<br>
        <br>
        <ul>
          <li>The following new #define is defined for OTL <a
 href="otl3_compile.htm#OTL_TRACE">tracing</a>: OTL_TRACE_LINE_SUFFIX.<br>
            <br>
          </li>
          <li>OTL provides the option of deriving the <a
 href="otl3_exception_class.htm">otl_exception</a> class from another
class (#define <a href="otl3_compile.htm#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM)</a>,
which could be the base for a bigger exception class hierarchy.
Sometimes, it is more convenient to attach the otl_exception class to
another existing <span style="font-style: italic;">exception base </span>class,
and catch exceptions of the base class, instead of having multiple
catch blocks for all types of exceptions, including otl_exception.
However, when&nbsp; <span style="font-family: monospace;">std::exception</span>
is used as a base class for otl_exception in the context of g++ 3.x,
OTL compilation fails because of a "looser defined throw()" clause in
otl_exception's constructors / destructor / other member functions. <span
 style="font-family: monospace;">std::exception </span>is defined with
            <span style="font-style: italic;">no-throw. </span>This
release fixes the problem for g++ 3.x and higher.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.100):<br>
        <br>
        <ul>
          <li>The following things have been done to OTL <a
 href="otl3_compile.htm#OTL_TRACE">tracing</a>:<br>
            <br>
          </li>
          <ul>
            <li>Prior to this release, when a database connect string
got logged, its password was logged as is, in plain text. Obviously, it
was a security breach. This release logs the password part of database
connect strings as "****".<br>
              <br>
            </li>
            <li>New tracing level is introduced: <a
 href="otl3_compile.htm#level_x20">0x20</a>. It traces all <a
 href="otl3_exception_class.htm">otl_exception</a>'s raised by OTL. <br>
              <br>
            </li>
            <li>Some inconsistencies in trace formatting were reported,
which made it difficult to&nbsp; <span style="font-style: italic;">grep</span>
for individual OTL trace/log entries. For example, number of spaces in
some cases was inconsistent: "<span style="font-family: monospace;">operator
&gt;&gt; (</span>", "<span style="font-family: monospace;">operator
&lt;&lt; (</span>", "<span style="font-family: monospace;">operator
&gt;&gt;(</span>", "<span style="font-family: monospace;">operator
&lt;&lt;(</span>".&nbsp; In this release, the formatting should always
be as follows: "<span style="font-family: monospace;">operator &gt;&gt;(</span>",
"<span style="font-family: monospace;">operator &lt;&lt;(</span>".<br>
            </li>
          </ul>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.99):<br>
        <br>
        <ul>
          <li>This release introduces the <a
 href="otl4_stream_read_iterator.htm">OTL stream read iterator template
class</a>. It provides JDBC-like position&nbsp; based <span
 style="font-style: italic;">getter </span>functions. In some cases,
there is no need to read all SELECT output columns. The new iterator
class addresses the issue. For more detail, see examples <a
 href="otl3_examples.htm#ex260">260-264<br>
            <br>
            </a></li>
          <li>In OTL/OCI8i/9i,10g <span style="font-style: italic;">, <a
 href="otl3_compile.htm#OTL_TRACE">tracing</a> </span>of<span
 style="font-style: italic;"> </span>operator&gt;&gt;(otl_datetime&amp;)
was missing.The bug is fixed in this release.<br>
            <br>
          </li>
          <li>OTL 4.0.98 had a fix OTL/ODBC/DB2-CLI for database
passwords that contain <a href="AT_FIX">@</a>. Oracle user passwords
may also contain @ characters. This release <a
 href="otl3_connect_class.htm#AT_IN_CONNECT_STR">fixes</a> the problem
for OTL/OCI8/8i/9i/10g.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.98):<br>
        <br>
        <ul>
          <li>OTL 4.0.97 introduced a new <a href="#NEW_FORMAT">format
            </a>for <a href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>.
In some cases, the name of a SELECT output column does not have a null
terminator character. The problem is fixed in this release.<br>
            <br>
          </li>
          <li>OTL 4.0.97 <a href="#BOOL_OP">made</a> otl_stream
operator&gt;&gt;(bool&amp;), operator&lt;&lt;(const bool),
operator&gt;&gt;(unsigned long&amp;), and operator&lt;&lt;(const
unsigned long) private. The rationale was that since OTL did not
support the operators, it would make sense to prevent them from being
(mis)used. However, the private operators make it impossible to
overload similar global operator, even though there may be legitimate
use cases for doing that. This release makes it possible to overload
the global operators &gt;&gt;/&lt;&lt; for bool and unsigned long by
introducing the following #defines:<br>
            <br>
          </li>
          <ul>
            <li><a
 href="otl3_compile.htm#OTL_STREAM_NO_PRIVATE_BOOL_OPERATORS">OTL_STREAM_NO_PRIVATE_BOOL_OPERATORS</a></li>
            <li><a
 href="otl3_compile.htm#OTL_STREAM_NO_PRIVATE_UNSIGNED_LONG_OPERATORS">OTL_STREAM_NO_PRIVATE_UNSIGNED_LONG_OPERATORS</a><br>
              <br>
            </li>
          </ul>
          <li>OTL 4.0.72 introduced <span style="font-style: italic;">OTL
tracing</span><span style="font-style: italic;">, </span>which enables
OTL function call tracing via #define <a
 href="otl3_compile.htm#OTL_TRACE">OTL_TRACE_LEVEL</a>, and other
#defines. There were complaints about the fact that level 0x4 logs too
much information and that it would make more sense to split it into at
least two levels. In OTL 4.0.98, trace level 0x4 has been split into
two: 0x4 and 0x8. Former level 0x8 has become level 0x10. For more
detail, see&nbsp; examples <a href="otl3_examples.htm#EX_249">249-252</a>.<br>
            <br>
          </li>
          <li><a name="AT_FIX"></a>In theory, it was possible that
passwords in database
connect strings could have "@" characters. OTL used "@" as a separator
character between the password and the DSN/TNS, for example:
"scott/tiger@my_db". The problem was reported when a database user
defined a new password and the password had "@" in it. OTL 4.0.98
/ODBC/DB2-CLI can <a href="otl3_connect_class.htm#AT_IN_CONNECT_STR">handle</a>
passwords that have "@" in them. I am not quite sure if Oracle user
passwords can have "@". <br>
            <br>
If anybody knows that it is possible, could you send the info, so that
I could implement the same feature for OTL/OCIx?<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.97):<br>
        <br>
        <ul>
          <li>OTL was cleaned up / optimized:<br>
            <br>
          </li>
          <ul>
            <li><a name="BOOL_OP"></a>otl_stream::operator&gt;&gt;(unsigned
long int&amp;),
otl_stream::operator&lt;&lt;(const unsigned long int) were made private
because they are not supported by OTL, and it is difficult to debug
code when the operators are used.<br>
              <br>
            </li>
            <li>Internal int otl_tmpl_cursor::eof() was changed from
virtual to a normal function, which reduces the overhead of a virtual
function call. This eof() function is called all over the place, and
performance gain may be a few percentage points, depending on the C++
compiler.<br>
              <br>
            </li>
            <li><a name="NEW_FORMAT"></a>In class <a
 href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>,
field "name" was changed from char[512] to char* in order to reduce the
memory footprint. Memory for column names gets allocated dynamically
instead of preallocating 512 bytes. In case if OTL streams are used
properly (opened once and used and as many times as possible as opposed
opened and used once, then closed)., the overhead of dynamic memory
allocatioins should be minimal.<br>
            </li>
          </ul>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (int OTL 4.0.96):<br>
        <br>
        <ul>
          <li>OTL code was cleaned up / optimized a little bit.
Performance gains, depending on the C++ compiler and its level of
optimization, type of SQL statement being used, vary from 0.5% to
2%.&nbsp; In many cases, if-else logic was replaced with a switch(),
which can be optimized more when a higher level of C++ compiler
optimization is enabled.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.95):<br>
        <br>
        <ul>
          <li>In OTL/ODBC/DB2-CLI,&nbsp; "SQLFreeStmt(cda,SQL_DROP);",
which is a deprecated call, was replaced with a call to SQLFreeHandle()
for ODBC/DB2-CLI, version 3.x.<br>
            <br>
          </li>
          <li>otl_stream::<a href="otl3_stream_class.htm#close">close</a>()
function was slightly modified&nbsp; in order to work around a bug /
feature of the DB2 CLI in AIX. The problem was that under some
circumstances a DB2 CLI function call returned SQL_ERROR, when there
was not any error, and because of that the OTL stream closing logic
caused database API resource leaks and program crashes. The
modification is internal only, and it should not cause any changes in
the behavior of the function. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.94):<br>
        <br>
        <ul>
          <li>OTL code was cleaned up / optimized a little bit.
Performance gains, depending on the C++ compiler and its level of
optimization, type of SQL statement being used, vary from 0.5% to 4.5%.
What was done in the OTL code is that internal otl_stream dispatching
of operations to the underlying "In/Out" / "Select"/ "Reference Cursor"
streams was optimized. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.93):<br>
        <br>
        <ul>
          <li>OTL/OCI8/8i/9i/10g #undef's min() and max() that are
defined in one of OCI header files. In some cases min() and max() are
functions, defined in C++ standard header files. It worked well until
now. The problem was reported that OTL does not work well with ATL
because of the fact that OTL #undef's min() and max(). When the #undef
min/max&nbsp; statements in OTL are commented out, the problem goes
away. So, in order to make things a little bit more flexible, a new
#define is introduced in this release: #define <a
 href="otl3_compile.htm#OTL_ORA_DOES_NOT_UNDEF_MIN_MAX">OTL_ORA_DOES_NOT_UNDEF_MIN_MAX</a>.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.92):<br>
        <br>
        <ul>
          <li>When UTF-8 is enabled on both the database and the client
side, OTL/OCI8/8i/9i/10g does not handle reading CLOBs correctly, if
#define OTL_UNICODE is not enabled. The problem is fixed in this
release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.91):<br>
        <br>
        <ul>
          <li>A memory leak in <a href="otl3_long_string.htm">otl_long_unicode_string</a>.
Memory leak occurs when #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
is defined and an external buffer is used.. Anybody who uses OTL with
Orale 8i/9i/10g with Unicode, and
experiences unexplained increases in memory usage, may want to consider
to upgrade to this release.<br>
            <br>
          </li>
          <li>The fix for <a
 href="otl3_stream_class.htm#describe_next_in_var">describe_next_in_var</a>()
that was introduced in OTL 4.0.90 (see below) is misplaced in the code
(is put in OTL/OCI7 instead of OTL/OCI9i/10g). This release fixes it.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.90):<br>
        <br>
        <ul>
          <li>In OTL/OCI9i/OCI10g, when #define <a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> is
defined, otl_stream::<a
 href="otl3_stream_class.htm#describe_next_in_var">describe_next_in_var</a>()
does not return correct information (does not correctly increment the
"stream's next output variable") after&nbsp;
otl_stream::operator&lt;&lt;(const <a
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>&amp;) is
called.&nbsp; The problem is fixed in this release.<br>
            <br>
          </li>
          <li>Some databases&nbsp; servers support a "boolean"
datatype, for example, PostgreSQL. However, ODBC does not support
booleans, so there is no way to get database boolean values directly.
OTL does not support booleans either. In order to make the matter less
confusing, and avoid obscure runtime errors,
otl_stream::operator&gt;&gt;(bool&amp;) and
otl_stream::operator&lt;&lt;(const bool) were made private in this
release. When programmers try to use the operators, they would get a
compilation error&nbsp; message saying that private functions could not
be accessed. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.89):<br>
        <br>
        <ul>
          <li>A few global operators &gt;&gt;/&lt;&lt; for
reading/writing signed 64-bit integers in were introduce in
OTL/OCI7/8/8i/9i/10g some time ago. Keyword "inline" was not put in
place at that time, which caused linker's "duplicate symbol" errors.
The bug has been fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.88):<br>
        <br>
        <ul>
          <li>In OTL/OCI9i/OCI10g, when #define <a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> is
defined, otl_stream::<a
 href="otl3_stream_class.htm#describe_next_out_var">describe_next_out_var</a>()
does not return correct information (does not correctly increment the
"stream's next output variable") after&nbsp;
otl_stream::operator&gt;&gt;(<a
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>&amp;) is
called.&nbsp; The problem is fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.87):<br>
        <br>
        <ul>
          <li>Parts of the OTL code have been internally restructured /
rewritten in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.86):<br>
        <br>
        <ul>
          <li>otl_connect::~otl_connect() in OTL/OCI8/8i/9i/10g may
leak OCI / database server side resources, when the otl_connect object
is connected to the database and no call to otl_connect::logoff() has
been made. The bug is fixed is this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.85):<br>
        <br>
        <ul>
          <li>OTL/OCI8/8i/9i/10g introduces the following new
parameters in otl_connect::<a href="otl3_connect_class.htm#rlogon_xa">rlogon</a>()
and otl_connect::<a href="otl3_connect_class.htm#server_attach">server_attach</a>:
server external name, server internal name. There are OCI + XA based
programs that implement transaction monitors. OTL could be used in such
program if the OCI enviroment handle (<i>envhp) </i>and the OCI
service context handle (<i>svchp</i>) get passed into otl_connect::<a
 href="otl3_connect_class.htm#attach8">rlogon</a>() as input
parameters. In other words, OTL can accept an external connection and
work with it correctly. Database connections that are required for
transaction monitors need to set the same attributes that OTL sets,
plus the server extrenal and internal name attributes. If the same
parameters get passed into OTL's new flavors of rlogon() and
server_attach(), OTL sets the required connection attributes., so that
the database connection is XA compliant. Direct code in OCI that is
external to OTL can be also written on top of the XA compilant database
connection made by OTL. In order to write such code, the OCI
environment handle (envhp) , the server handle (srvhp), the service
context handle (svchp), the session handle (authp), and the error
handle (errhp) can be directly accessed in the <span
 style="font-style: italic;">otl_connect::connect_struct</span>
structure.</li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.84):<br>
        <br>
        <ul>
          <li>When OTL/OCI8/8i/9i/10g raises the "<strong
 style="font-weight: normal;">ORA-28002 the password will expire within
            <em class="Italic">string</em> days" error on a database
connection request, the corresponding otl_connect object is not fully
initialized (otl_connect::connected == 0), even though it could be
initialized and used. Oracle server allows accounts that are about to
expire to be used, if the user chooses to do so. This release fixes the
behavior of the otl_connect object in this situation. That is, the
otl_connect::connected flag will be set to 1, and the otl_connect
object will be fully initialized and usable.<br>
            </strong></li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.83):<br>
        <br>
        <ul>
          <li>Some older versions of Oracle (Oracle 8.0.x, even Oracle
8.1.x) have a bug (or an undocumented / ambiguously documented feature)
in the OCILObRead() function. The problem is that the OCI should not
remember the address of the OCILObRead()'s "amt" paremeter, meaning
that the parameter should be a transient parameter that could be
allocated on stack. It is not so in some older versions of the OCI.
OCILobRead() is used by the <a href="otl3_lob_stream.htm">otl_lob_stream</a>
class in OTL/OCI, and this OCI "feature" results in the program's
runtime crash. The trick here is that, say, if the actual "amt"
variable gets allocated on stack, and if the variable's address on the
stack still exists, then the OCI can use it.. If the address (on the
stack) goes away because of the stack allocations / deallocations, the
program may crash. The OCI manual does not indicate that the actual
memory block that gets passed as the "amt" parameter into the
OCILobRead() function should stay the same.&nbsp; So, the introduced
workaround is that the actual "amt" variable that gets passed into the
OCILobRead() function was made a data member of a class instead of a
stack variable.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (OTL 4.0.82):<br>
        <br>
        <ul>
          <li>#define <a
 href="otl3_compile.htm#OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO">OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO</a>
has been reworked in this release. Instead of a "throw flag" that the
#define was supposed to pass into the OTL&nbsp; header file (release
4.0.81) , the #define enables the following function: otl_connect::<a
 href="otl3_connect_class.htm#set_throw_on_sql_success_with_info">set_throw_on_sql_success_with_info</a>().
The function sets a database connection specific "throw flag", which
makes development of multi-threaded programs that could potentially use
this feature easier. See also example <a href="otl4_ex259.htm">259</a>
for more detail. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL: 4.0.81):<br>
        <br>
        <ul>
          <li><a name="OTL4081"></a>OTL/ODBC, OTL/DB2-CLI: new #define <a
 href="otl3_compile.htm#OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO">OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO</a>.
This #define forces OTL to throw an <a href="otl3_exception_class.htm">otl_exception</a>
when SQLExecute() / SQLDirectExec() returns SQL_SUCCESS_WITH_INFO. This
kind of technique allows all diagnostic information (that would
normally be retrieved via a series of calls to SQLGetDiagRec() in ODBC)
to be passed back to the caller. Also, see example <a
 href="otl4_ex259.htm">259</a>.<br>
            <br>
          </li>
          <li>OTL/OCI8,8i,9i,10g: new <a href="otl4_refcur_stream.htm">otl_refcur_stream</a>::operator<a
 href="otl4_refcur_stream.htm#OTL_BIGINT">&gt;&gt;</a>(OTL_BIGINT&amp;)<br>
            <br>
          </li>
          <li>OTL/ODBC: otl_stream::operator<a
 href="otl3_stream_class.htm#64_bit_integer_write">&gt;&gt;</a>(OTL_BIGINT&amp;)
and
otl_stream::operator<a href="otl3_stream_class.htm#64_bit_integer_read">&lt;&lt;</a>(const
OTL_BIGINT) for OTL/ODBC automatically convert numeric string values to
signed 64-bit integer values when the corresponding bind variable is a
string (char[XXX]). This is useful when, say, the underlying database
supports numeric datatypes that are larger than the "double" container
can hold,
for example, DECIMAL(19,0), and yet the ODBC driver does not natively
support the "bigint" binding because it is an optional feature in the
ODBC
specification. Sybase would be an example of such database. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.80):<br>
        <br>
        <ul>
          <li>OTL compiles clean with GNU C++ 3.x when&nbsp; -Wshadow
is enabled. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.79):<br>
        <br>
        <ul>
          <li>This release introduces general support for ODBC on IBM
zOS via the following new #define <a
 href="otl3_compile.htm#OTL_ODBC_zOS">OTL_ODBC_zOS</a>. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.78):<br>
        <br>
        <ul>
          <li>OTL has compilation errors when&nbsp; #define <a
 href="otl3_compile.htm#OTL_ACE">OTL_ACE</a> is used. The problem is
fixed in this release.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.77):<br>
        <br>
        <ul>
          <li>This release introduces a new default: #define <a
 href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a>. The new default
makes sense since most of the available C++ compilers that OTL compiles
with are ANSI C++ compliant, or at least ANSI C++ friendly. The default
allows OTL to be compiled cleaner (fewer compilation warnings) when
higher warning levels are used in C++ compilers. Those who still use
older C++ compilers can disable the #define right in the OTL header
file (otlv4.h)<br>
            <br>
          </li>
          <li>As a result of a code cleanup, this release should
compile clean with&nbsp; VC++ 7.1 .NET, when /W4 /WX /Wp64 options are
used. /Wp64 gives warnings when there may be any compatiblity issues
with the VC++ 64-bit compiler.<br>
            <br>
          </li>
          <li>As a result of a code cleanup, this release should
compile clean with g++ 3.3 when the following warning options are used:</li>
          <ul>
            <li>-W <br>
            </li>
            <li>-Wall <br>
            </li>
            <li>-Wundef&nbsp; <br>
            </li>
            <li>-Wpointer-arith</li>
            <li>-Wunused</li>
            <li>-ansi <br>
            </li>
            <li>-Wreorder</li>
            <li>-Wcast-qual <br>
            </li>
            <li>-Wcast-align <br>
            </li>
            <li>-Wconversion <br>
            </li>
            <li>-Wsign-compare <br>
            </li>
            <li>-Wstrict-prototypes</li>
            <li>-Wmissing-prototypes<br>
              <br>
            </li>
          </ul>
          <li>A memory leak in <a href="otl3_long_string.htm">otl_long_unicode_string</a>.
Memory leaks occurs under certain circumstances under #define <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>. Therefore,
anybody who uses OTL with Oracle 8i/9i/10g with Unicode, and
experiences unexplained increases in memory usage may want to consider
to upgrade to this release. By the way, this problem has not been
reported yet by anybody. The problem was uncovered during a routine
test suite build / execution cycle by a memory leak detector.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.76):<br>
        <br>
        <ul>
          <li>This release introduces general support for Oracle 10g
(OCI10g) via&nbsp; #define <a href="otl3_compile.htm#OTL_ORA10G">OTL_ORA10G</a>.
Oracle 10g introduced the following two new numeric datatypes:
BINARY_FLOAT (4-byte native floating point), BINARY_DOUBLE (8-byte
native floating point). With OTL_ORA10G, OTL maps those two datatypes
to "float", and "double", respectively. For now OTL_ORA10G is almost
synonymous to OTL_ORA9I. In the future there may be some differences
when OCI19g specific features get used.<br>
            <br>
          </li>
          <li>OTL implicitly disallowed multi-line string literals in
SQL statements, for example: '12345<span
 style="font-weight: bold; font-style: italic;">\n</span> 67<span
 style="font-weight: bold; font-style: italic;">\n</span> 89<span
 style="font-weight: bold; font-style: italic;">\n</span>'. In general,
SQL allows multi-line string literals. Some old database servers, at
this point it is hard to say exactly what versions of what database
types, did not support multi-line string literals correctly, so the
assumption was made in OTL that string literals of that sort were not
allowed. This release of OTL handles multi-line string literals
correctly.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.75):<br>
        <br>
        <ul>
          <li>A few compilation warnings have been fixed in this
release for VC++&nbsp; 7.1 (.NET) , when OTL gets compiled with the -W4
command line option. <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.74):<br>
        <br>
        <ul>
          <li>This release introduces support for 64-bit signed
integers (<a href="otl3_bind_variables.htm#bigint">bigint</a>)&nbsp;
for OTL/OCIx: <a href="otl3_compile.htm#OTL_ORA7">OTL_ORA7</a>, <a
 href="otl3_compile.htm#OTL_ORA8">OTL_ORA8</a>, <a
 href="otl3_compile.htm#OTL_ORA8I">OTL_ORA8I</a>, <a
 href="otl3_compile.htm#OTL_ORA7">OTL_ORA9I</a>. OCis do not have any
native support for 64-bit inetegers (even in the newly released Oracle
10g), so OTL has to emulate it, which is done via string (char[XXX])
bind variables internally. On the outside, <a
 href="otl3_stream_class.htm#64_bit_integer_write">otl_stream::operator
&gt;&gt;</a>(<a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>&amp;
n) and <a href="otl3_stream_class.htm#64_bit_integer_read">otl_stream::operator&lt;&lt;</a>(const
OTL_BIGINT n) work the same way for OTL/OCIx as for OTL/ODBC, or
OTL/DB2-CLI, which provides portability between different databases. In
order to enable this new feature for OTL/OCIx, the following #defines
have to be enabled: <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>,
            <a href="otl3_compile.htm#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>,
            <a href="otl3_compile.htm#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>.<br>
            <br>
See also examples <a href="otl3_examples.htm#EX257">257, 258</a>.<br>
            <br>
          </li>
          <li>A new list of <a
 href="otl3_examples.htm#examples_by_db_type">examples</a> by database
type was added to the OTL examples, which should make it easier to look
up database type and vesrion specific OTL examples. <br>
            <br>
          </li>
          <li>Several compilation warnings have been fixed for g++: <br>
            <br>
          </li>
          <ul>
            <li>unused function parameters / local variables<br>
            </li>
            <li>base class should be explicitly initialized in the copy
constructor <br>
            </li>
          </ul>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.73):<br>
        <ul>
          <li>
            <p>otl_stream::<a href="otl3_stream_class.htm#operator_int">operator
int</a>() behaves incorrectly when it is called right after a call to
an otl_stream::operator&lt;&lt;(), that is, when a value gets written
to the stream, operator int() returns an incorrect value, which may
result in obscure bugs that could be very difficult to track down. In
theory, operator int() in the context of OTL streams is defined / makes
sense only for streams that
have some output: SELECT statements, stored procedures that
return&nbsp; result sets, etc. From the very beginning, operator int()
was intended for reporting the end-of-file status of the stream, and
could be typically used with SELECT statements as the following C++
idiom, similar to the <span style="font-style: italic;">while(!s.eof())</span>
construct: <span style="font-style: italic;">while(s&gt;&gt;f1)</span>.
A concern was raised that partially defined behavior of the
operator int() is potentially dangerous and may cause nontrivial bugs.
The
idea was that the operator should either behave correctly, or its use
should be blocked in the situations when correct behavior of the
operator is not guaranted. This release does the latter: it introduces
the following new OTL defined <a href="otl3_exc_list.htm#32020">exception</a>:
            <small style="font-style: italic;"><font size="+1"><small>otl_stream::operator&gt;&gt;()
should have been called before
otl_stream::operator int(). </small></font></small><small><font
 size="+1"><small>The exception blocks any use of the operator when
correctness of its behavior is not guaranteed. When the exception gets
thrown, it would normally mean that the logic of the program should be
changed. In other words, operator int() should be used only after calls
to otl_stream::operators &gt;&gt;().<br>
            </small></font></small></p>
          </li>
          <li><small><font size="+1"><small>This release introduces <a
 href="otl3_bind_variables.htm#SELECT_OVERRIDE">explicit bind variables</a>
in definitions of SELECT output columns. It is an alternative, inline
(right in the text of SELECT statements) mechanism for overriding the
OTL default internal-database-datatype-to-external-datatype mapping in
SELECT statements. The mapping works okay for the most part, except for
rare cases, when it would make more sense to ovveride a default column
datatype with something more specific, and in the case when the use of
the otl_stream::<a href="otl3_stream_class.htm#set_column_type">set_column_type</a>
function is not very convenient. Also, see examples <a
 href="otl3_examples.htm#EX_253">253-256</a>.<br>
            </small></font></small></li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.72):<br>
        <br>
        <ul>
          <li>This release introduces <span style="font-style: italic;">OTL
tracing, </span>which enables OTL function call tracing via #define <a
 href="otl3_compile.htm#OTL_TRACE">OTL_TRACE_LEVEL</a>, and other
#defines. See also examples <a href="otl3_examples.htm#EX_249">249-252</a>.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OT 4.0..71):<br>
        <br>
        <ul>
          <li>In OTL <a href="#OTL4028">4.0.28</a>,
OTL stream operator &gt;&gt;/&lt;&lt;(std::string/ACE_String) were
extended to work with Large String Objects (Oracle LONG, Oracle/DB2
CLOB, MS SQL/Sybase TEXT, etc). In this release, when #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">OTL_USER_DEFINED_STRING_CLASS_ON</a>
is used, the OTL stream string operators &gt;&gt;/&lt;&lt; can
read/write Large String Objects via a user defined string class.<br>
            <br>
Even though std::string exists, there
is still a need&nbsp; to
add your own, more scalable, sometimes even application specific,
string class. See examples <a href="otl3_examples.htm#EX_244">244-248</a>
for more
detail.<br>
            <br>
OTL from this release on requires more functions to be implemented by
the user defined strng class: see updated example <a
 href="otl3_ex119.htm">119</a>, <a href="otl3_ex120.htm">120</a>, <a
 href="otl3_ex121.htm">121</a>. Those who already defined their string
class may want to double check their source code, when upgrading to
this release of OTL.<a href="#OTL4028"><br>
            </a></li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.70):<br>
        <br>
        <ul>
          <li>Private copy constructors and assignment operators were
added to the otl_connect, and otl_stream classes (for all flavors of
OTL) in order to prevent instances of otl_stream and otl_connect from
being copied / put in containers. otl_connect and otl_stream objects
are wrappers around database API resources, which are not really
sharable.<br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OL 4.0.69):<br>
        <br>
        <ul>
          <li>OTL throws <a href="otl3_exception_class.htm">otl_exception</a>'s,
catches the exceptions, and rethrows them&nbsp; internally (in the OTL
header file). GNU C++ 3.3.1 does not compile some of the
"catch(otl_exception...)" catch blocks correctly. The fix for this
problem is that all the catch blocks have to catch "const
otl_exception&amp;" in order to&nbsp; compile okay wih G++ 3.3.1.&nbsp;
All of the catch blocks were changed to catch "const
otl_exception&amp;" when&nbsp; #define <a
 href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a> is enabled, and
if it is not enabled, the catch block have the original format.<br>
            <br>
The compilation problem has been fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.68):<br>
        <br>
        <ul>
          <li>It turns out that&nbsp; OTL/ODBC works fine with the
Informix CLI (which is ODBC 2.5 compliant). However, Informix SQL
allows ":" as a legimimate character in an SQL statement. ":" is
treated by OTL as the prefix of a bind variable. ":" is native to
the Oracle Call Interface syntax, and gets converted by OTL into "?"
for DB2 CLI and ODBC. When used with OTL/ODBC, an SQL satement that has
colons is parsed incorrectly, and there is a need to <a
 href="otl3_bind_variables.htm#COLON_LITERAL">embed colons</a>
(literally) into the SQL statement. OTL/ODBC, starting with release
4.0.68 ad higher, supports the following notation for embedding colon
literals&nbsp; into SQL statments: "<span
 style="font-family: monospace;">\\:</span>". For example: <br>
            <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<span
 style="font-family: monospace;">SELECT * FROM xxx\\:yyy</span>"<br>
            <br>
In this example, <span style="font-family: monospace;">\\:yyy</span>&nbsp;
is not treated / parsed out as a bind variable. <br>
            <br>
          </li>
          <li>The following example causes the SQL statement buffer
overrun (reading / writing beyond the buffer):<br>
            <br>
&nbsp;&nbsp;&nbsp; "<span style="font-family: monospace;">SELECT *
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Line 1<br>
&nbsp; "FROM test_tab
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Line 2<br>
&nbsp; "WHERE f1&gt;=<span
 style="font-style: italic; font-weight: bold;">:f1</span>&lt;int&gt; -
2 "&nbsp;&nbsp; // Line 3<br>
&nbsp; "AND f1&lt;=<span style="font-style: italic; font-weight: bold;">:f1</span></span>"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <span style="font-family: monospace;">//</span>&nbsp; <span
 style="font-family: monospace;">Line 4</span><br
 style="font-family: monospace;">
            <br>
This notation (<span style="font-weight: bold; font-style: italic;">:f1</span>)
is only supported for OTL/OCIx (Oracle), because it is the OCI native
notation. In the example above, the second reference to <span
 style="font-weight: bold; font-style: italic;">:f1 </span><span
 style="font-weight: bold;"></span>(Line 4)<span
 style="font-weight: bold; font-style: italic;"> </span>is treated as
a reference to the same bind variable <span
 style="font-weight: bold; font-style: italic;">:f1</span>., that is,
only one bind variable is defined in the SELECT statement above. This
notation is not supported for OTL/ODBC, OTL/DB2-CLI, because <span
 style="font-family: monospace;">:var&lt;...&gt;</span> notation gets
translated into the question marks("?"), which is native to ODBC and
DB2-CLI.<br>
            <br>
The buffer overrun error is fixed in this release.<br>
            <br>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.67):<br>
        <br>
        <ul>
          <li>In OTL/OCIx, otl_stream::operator
&gt;&gt;(otl_time0&amp;...) may sometimes cause "memory access
viloation", where otl_time0 is an internal DATE&nbsp; container, when
stream returns a result set via a reference cursor. The problem is
fixed in this release.<br>
            <br>
          </li>
          <li>This release introduces support for <a
 href="otl3_bind_variables.htm#bigint">bigint</a> (64-bit integer) bind
variables for OTL/ODBC, OTL/DB2-CLI, when #define <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> is enabled. Se also
examples <a href="otl3_examples.htm#ex242">242, 243</a>.<br>
            <br>
OCI, for the reason of 64-bit integers not being a standard primitive
numeric datatype, or because 64-bit integers have compiler dependent /
specific implementations, does not have any native support for 64-bit
integers. Here is an excerpt from the OCI manual that describes a list
of OCI external numeric datatypes:<br>
            <br>
            <table class="FormalWide" dir="ltr" border="1"
 cellpadding="3" cellspacing="0" frame="hsides" rules="groups"
 width="100%">
              <thead><tr class="Formal">
                <th scope="col" rowspan="1" colspan="2" class="Formal"
 valign="bottom"><font face="Arial, Helvetica, sans-serif"><strong>EXTERNAL
DATATYPE</strong></font>&nbsp;</th>
                <th scope="col" rowspan="2" colspan="1" class="Formal"
 valign="bottom"> <a name="422931"></a><font
 face="Arial, Helvetica, sans-serif"><strong>TYPE OF PROGRAM VARIABLE</strong></font>&nbsp;</th>
                <th scope="col" rowspan="2" colspan="1" class="Formal"
 valign="bottom"> <a name="426865"></a><font
 face="Arial, Helvetica, sans-serif"><strong>OCI DEFINED CONSTANT</strong></font>&nbsp;</th>
              </tr>
              </thead><tbody>
              </tbody><thead> <tr class="Formal">
                <th scope="col" class="Formal" align="left"
 valign="bottom"><a name="422933"></a> <font
 face="Arial, Helvetica, sans-serif"><strong>NAME</strong></font>&nbsp;</th>
                <th scope="col" class="Formal" align="left"
 valign="bottom"> <a name="422935"></a><font
 face="Arial, Helvetica, sans-serif"><strong>CODE</strong></font>&nbsp;</th>
              </tr>
              </thead><tbody>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422939"></a>
                  <p class="TB">VARCHAR2&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422941"></a>
                  <p class="TB">1&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422943"></a>
                  <p class="TB">char[n]&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426869"></a>
                  <p class="TB">SQLT_CHR&nbsp;</p>
                  </td>
                </tr>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422945"></a>
                  <p class="TB">NUMBER&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422947"></a>
                  <p class="TB">2&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422949"></a>
                  <p class="TB">unsigned char[21]&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426871"></a>
                  <p class="TB">SQLT_NUM&nbsp;</p>
                  </td>
                </tr>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422951"></a>
                  <p class="TB">8-bit signed INTEGER&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422953"></a>
                  <p class="TB">3&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422955"></a>
                  <p class="TB">signed char&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426873"></a>
                  <p class="TB">SQLT_INT&nbsp;</p>
                  </td>
                </tr>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422957"></a>
                  <p class="TB">16-bit signed INTEGER&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422959"></a>
                  <p class="TB">3&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422961"></a>
                  <p class="TB">signed short, signed int&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426875"></a>
                  <p class="TB">SQLT_INT&nbsp;</p>
                  </td>
                </tr>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422963"></a>
                  <p class="TB">32-bit signed INTEGER&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422965"></a>
                  <p class="TB">3&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422967"></a>
                  <p class="TB">signed int, signed long&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426877"></a>
                  <p class="TB">SQLT_INT&nbsp;</p>
                  </td>
                </tr>
                <tr class="Formal" align="left" valign="top">
                  <td class="Formal"><a name="422969"></a>
                  <p class="TB">FLOAT&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422971"></a>
                  <p class="TB">4&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="422973"></a>
                  <p class="TB">float, double&nbsp;</p>
                  </td>
                  <td class="Formal"> <a name="426879"></a>
                  <p class="TB">SQLT_FLT <br>
                  </p>
                  </td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.66): <br>
&nbsp;
        <ul>
          <li>In the "LOB stream mode", OTL/ODBC, when the program is
connected to an
MS SQL Server 2000 database, ODBC function SQLPutData() may
return&nbsp;
SQL_NO_DATA, which is a normal code and it is not an error. OTL treated
the code as an error, and raised an otl_exception as a result. It is
not
quite clear why SQLPutData() returns SQL_NO_DATA, and it appears to an
undocumented feature. Here is an excerpt from the MS ODBC manual:</li>
          <h4>SQLPutData Function<br>
          <b>...<br>
Returns</b></h4>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or
SQL_INVALID_HANDLE. <br>
          <br>
The problem was fixed in this release. <br>
&nbsp;
          <li>When a string literal that had "--" (dashes) inside of it
was part of an
SQL statement / PLSQL block / stored procedure call, the dashes were
mistakenly
treated as a one-line comment.&nbsp; The problem was fixed in this
release.</li>
          <br>
&nbsp;
          <li>Support for&nbsp; Oracle 9i TIMESTAMPs WITH [LOCAL] TIME
ZONE via the following new types of&nbsp; bind variables and the <a
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a> container
when #define <a href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a>
is enabled: <a href="otl3_bind_variables.htm#tz_timestamp">tz_timestamp</a>,
            <a href="otl3_bind_variables.htm#ltz_timestamp">ltz_timestamp</a>.
See
also example <a href="otl3_examples.htm#ex241">241</a>.<br>
          </li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.65): <br>
&nbsp;
        <ul>
          <li>A few Borland C++ compilation warnings about implicit
type casting were
fixed in this release.</li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.64): <br>
&nbsp;
        <ul>
          <li>The assignment operator and the copy constructor were
added to the <a
 href="../../../../D%7C/oscl/vc/doc/otl4/otl3_long_string.htm">otl_long_string</a>
class did not copy a NULL terminator byte, which was actually beyond
the
dynamic length. However, it is convenient to have the NULL terminator
for
comparing string and for using C-style functions. The problem is fixed
in this release</li>
          <br>
&nbsp;
          <li>When #define: <a
 href="../../../../D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a>
in a combination with an otl_stream that returns a reference cursor is
used, and the stream has an input bind variable of the&nbsp;<span
 style="font-style: italic;">:v&lt;timestamp,in&gt;</span>
type, OTL throws exception&nbsp; "<span style="font-family: monospace;">Incompatible
data types in stream operation</span>". The problem is fixes in this
release.</li>
          <br>
&nbsp;
          <li>otl_stream:: <a
 href="../../../../D%7C/oscl/vc/doc/otl4/otl3_stream_class.htm#create_stored_proc_call">create_stored_proc_call</a>()
did not support Oracle 9i's TIMESTAMP data type under #define: <a
 href="../../../../D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a>.
The problem is fixed in this release</li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.63): <br>
&nbsp;
        <ul>
          <li>An assignment operator and a copy constructor were added
to the <a href="otl3_long_string.htm">otl_long_string</a>
class.</li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.62): <br>
&nbsp;
        <ul>
          <li>When OTL/ODBC is used with MERANT 3.6 ODBC Driver for
Progress
Database,
and when a SELECT otl_stream returns an empty result set, OTL goes into
an infinite loop. The problem is fixed in this release. I suspect that
the problem is specific to the ODBC driver, because I couldn't recreate
it with any of available ODBC drivers for major databases. If anybody
has
experienced the same problem, some feedback would be appreciated very
much.</li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.61): <br>
&nbsp;
        <ul>
          <li>There are some compilation warnings when a high enough
level of
warnings
is set with g++ 3.2. The warnings were fixed in this release.</li>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">New (in OTL 4.0.60): <br>
&nbsp;
        <ul>
          <li>In OTL/ODBC, DB2-CLI, the format of&nbsp;<span
 style="font-style: italic;">SQL
statements&nbsp;</span>in OTL stream has been extended for calling such
ODBC / DB2-CLI functions as SQLTables(), SQLColumns(), etc., in order
to
be able to access system data dictionaries of different ODBC / DB2-CLI
data sources. For more detail, see <a href="otl4_append_b.htm">Appendix
B</a>, and examples <a href="otl3_examples.htm#ex237">237-240</a>.&nbsp;</li>
          <p><br>
In theory, ODBC / DB2-CLI compliant data sources / drivers should
implement functions for accessing system data dictionaries. Not all
databases
have access to their system data dictionaries via so-called system
views,
that is when functions like SQLTables(), SQLColumns(), etc. come into
play.</p>
        </ul>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.59): <br>
&nbsp;
        <ul>
          <li>A new parameter has been introduced in otl_stream <a
 href="otl3_stream_class.htm#otl_stream_otl_stream">constructors</a>
and <a href="otl3_stream_class.htm#otl_stream_open">open</a>
functions:
SQL statement label. When an SQL statement gets opened via an OTL
stream
and a statement label is specified, then if an otl_exception gets
thrown,
the <a href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a>
field gets populated with the statement label instead of the actual
text
of the SQL statement. SQL statement labels can be used for more
compact,
more readable logging of failed SQL operations. In some cases, it's not
desirable to expose SQL statements at all.In big / complex systems, SQL
statements are normally cataloged, and it would be easier to identify
an
SQL statement by its index / number in the SQL catalog instead of
trying
to sort through the text of failed complex (say, 3Kb each) SQL
statements.
See also examples <a href="otl3_examples.htm#ex234">234, 235, 236</a>.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.58):&nbsp;
        <ul>
          <li>otl_stream::<a
 href="otl3_stream_class.htm#set_all_column_types">set_all_column_types</a>()
and otl_stream::<a href="otl3_stream_class.htm#set_column_type">set_column_type</a>()
behave incorrectly (or crash the program), when used on the same stream
variable after the stream was partly initialized with a bad SQL
statement
that errored out (otl_exception was raised). The problem is fixed in
this
release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.57):&nbsp;
        <ul>
          <li>Under OTL_ORA7, OTL_ORA8, OTL_ORA8I, OTL_ORA_9I, when OTL
is compiled
with
Borland C++ 6.0, there are compilation warnings about implicit type
casting.
The warnings are fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.56):&nbsp;
        <ul>
          <li>Some of the operators &lt;&lt;/&gt;&gt;() under #define
OTL_ORA8,
OTL_ORA8I,OTL_ORA9I
may crash the program because of a NULL pointer dereferencing. The bug
was introduced in OTL 4.0.55 and is fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.55):&nbsp; <br>
&nbsp;
        <ul>
          <li>On Tru64 Unix, Compad C++ v6.3, a "unused variable"
compilation warning
was fixed in this release</li>
          <br>
&nbsp;
          <li>When otl_stream::close() gets called on a stream&nbsp;
that was already
closed, the program crashes. The problem was fixed in this release.
Though,
an obvious workaround is as follows:</li>
          <br>
&nbsp;
          <p>&nbsp; </p>
          <p><tt>&nbsp; if(my_stream.good())&nbsp;</tt> <br>
          <tt>&nbsp;&nbsp;&nbsp;&nbsp; my_stream.close();</tt> <br>
&nbsp;</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.54):&nbsp;
        <ul>
          <li>Operator <a href="otl3_stream_class.htm#operator_int">int</a>()
does
not
return 1 in the case of a result set of one row. The problem is fixed
in
this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.53):&nbsp;
        <ul>
          <li>Operator <a href="otl3_stream_class.htm#operator_int">int</a>()
does
not
return 1 in the case of an empty result set, so one phantom row of data
can be potentially read from the stream. The problem is fixed in this
release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.52):&nbsp;
        <ul>
          <li>New #define <a
 href="otl3_compile.htm#OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR">OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR</a>
is introduced. The #define allows to map DB2 OS/390 VARCHAR table
columns
that are smaller than a specified by the #define numeric value to DB2
CLI's
SQL_VARCHAR datatype, even though the DB2 CLI itself reports them as
SQL_LONG_VARCHARs.
Client DB2 CLI, when connected to a DB2 OS/390 database, reports all
VARCHAR
table columns that are larger than 255 bytes as SQL_LONG_VARCHARs. This
new feature (in OTL) allows the developer to work around portability
problems
across many <i>slightly</i> incompatible flavors of DB2.</li>
          <br>
&nbsp;
          <li>In OTL/DB2-CLI, OTL/ODBC, when a SELECT statement gets
opened via an otl_stream,
and resulting rows [of the SELECT statement] are being fetched, the
underlynig
cursor gets closed as soon as possible, right after the fetch sequence
is exhausted. This can be considered as a small optimization tweak.
Those
who are curious can run a diff on the source code and see for
themselves
what was done.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.51):&nbsp;
        <ul>
          <li>New #define <a
 href="otl3_compile.htm#OTL_FUNC_THROW_SPEC_ON">OTL_FUNC_THROW_SPEC_ON</a>
is introduced. It should be used when #define <a
 href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a>
is on, in order to enable <a href="#OTL_FUNC_THROW">OTL function throw
specifications</a>, introduced in OTL 4.0.50. It looks like there is no
consesus on the merits of this feature of C++ in the C++ community, and
I have to make it optional within the "OTL ANSI CPP" mode.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.50):&nbsp;
        <ul>
          <li>In OTL/ODBC, OTL/DB2-CLI, when #define <a
 href="otl3_compile.htm#OTL_ODBC_SQL_EXTENDED_FETCH_ON">OTL_ODBC_SQL_EXTENDED_FETCH_ON</a>
is defined, in the OTL internal "fetch" functions, there were a number
of local calls to the C++ heap manager (dynamic memory
allocation/deallocation
calls), which degraded performance somewhat, especially in the
multi-threaded
mode (the heap manager in the multi-threaded mode generates critical
section
/ mutex locks, and, unless a special multi-heap manager is used, it
makes
all calls to the heap manager sequential / " single threaded"). The
problem
is fixed in thsi release.</li>
          <br>
&nbsp;
          <li><a name="OTL_FUNC_THROW"></a>Under <a
 href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a>,
all OTL functions / operators have a <i>throw</i> clause, which
specifies
what exception each function may potentially throw (or not to throw
anything
at all). This effort is in making the OTL source code more up to date
with
the ANSI C++ style.</li>
          <br>
C++ compilers have some support in reporting scope exception problems
(e.g., a function call may potentially throw an exception, but there is
no corresponding try/catch block) at compile time. Hopefully, it will
improve
in the future&nbsp;
          <p>Also, in declaration of template classes, under
OTL_ANSI_CPP, class
type parameters are marked with keyword <i>typename</i>, not <i>class</i>,
which is more in the letter and spirit of the ANSI C++ standard.</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.49):&nbsp;
        <ul>
          <li>A bug, that was fixed in 4.0.48, introduced a new bug
under #define <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>:
when the same otl_stream variable gets reused multiple times for
different
SQL statements, the program crashes with "Access Violation" /
"Segmentation
Violation" errors. The new bug is fixed in this release.</li>
          <br>
&nbsp;
          <li>operator <a href="otl3_stream_class.htm#operator_int">int</a>(),
that was
introduced in 4.0.47, returns 0 on the last row to be fetched, before
the
row is fetched, instead of after the row is fetched. The bug is fixed
in
this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.48):&nbsp;
        <ul>
          <li>When <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>
, <a href="otl3_compile.htm#OTL_UNCAUGHT_EXCEPTION_ON">OTL_UNCAUGHT_EXCEPTION_ON</a>
are defined, and an external (non-OTL) exception gets thrown, the
otl_stream::~otl_stream()
destructor tries to access a block of dynamic memory that was already
freed.
This happens only for C++ compilers that support uncaught_exception()
(ANSI
C++). The bug was fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.47):&nbsp;
        <ul>
          <li>operator <a href="otl3_stream_class.htm#operator_int">int</a>()
was
added
to <a href="otl3_stream_class.htm">otl_stream</a>.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.46):&nbsp;
        <ul>
          <li>In OTL/OCI8/OCI8i/OCI9i, when an <a
 href="otl3_lob_stream.htm">otl_lob_stream</a>
was opened for reading a CLOB/BLOB from an Oracle table, if the
CLOB/BLOB
was not read to the end, and the LOB stream gets closed, it causes the
following Oracle error message: "<tt>ORA-03127: no new operations
allowed
until the active operation ends</tt>". The problem is fixed in this
release.</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.45):&nbsp;
        <ul>
          <li>Support for Intel C++ 7.0 (Windows and Linux). In
general, previous
releases
compiled with Intel C++, without the "-ansi" flag. This release of OTL
compiles correctly with the "-ansi" flag. A few inherited member
functions
in a template class had to be qualified with "this-&gt;", in order to
make
the OTL header file compile with Intel C++ the "-ansi" mode.&nbsp;</li>
          <br>
&nbsp;
          <p>&nbsp; </p>
          <p>I suspect that something similar should be the case for HP
UX aCC. If
somebody could provide more information of HP UX aCC problems, I would
appreciate it very much.</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.44):&nbsp;
        <ul>
          <li>#define OTL_VERSION_NUMBER was set incorrectly, it is
fixed in this
release.</li>
          <li>OTL SQL statement parser did not take into account one
line comments
(--...EOLN),
and traditional comments (/* ... */) when parsing an anonymous PL/SQL
block.
In case if a comment contains "<b>:</b>" characters, the parser
mistakenly
recognizes them as <a href="otl3_bind_variables.htm">bind variable</a>
declarations. The problem is fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.43):&nbsp;
        <ul>
          <li>In OTL/OCI8,OCI8i,OCI9i, when <b>oracle:: </b>namespace
gets enabled,
the
actual namespace was <b>oracel::, </b>which was a typo. The bug is
fxed
in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (4.0.42):&nbsp;
        <ul>
          <li>HP UX C++ (aCC)&nbsp; generates a "future error"
compilation waring.
Simply
addition of "this-&gt;" to a reference to a dataabse member in a
template
class fixes the problem. The problem is fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.41):&nbsp;
        <ul>
          <li>Under #define <a
 href="otl3_compile.htm#OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON">OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON</a>
, when the otl_stream gets instantiated with a stored procedure call
(ODBC,
DB2-CLI), or an anonymous PL/SQL block (OCI7, OCI8, OCI8, OCI8i,
OCI9i),
if&nbsp; a bind variable has an invalid datatype, the program crashes
(Memory
Access Violation, Segmentation Violation, etc.) instead of throwing <a
 href="otl3_exception_class.htm">otl_exception</a>.The
bug is fixed in ths release.</li>
          <br>
&nbsp;
          <li>New #define is introduced:: #define <a
 href="otl3_compile.htm#OTL_ORA_MAP_STRINGS_TO_CHARZ">OTL_ORA_MAP_STRINGS_TO_CHARZ</a>e.
See also, example <a href="otl3_examples.htm#ex233">233</a>.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in 4.0.40):&nbsp;
        <ul>
          <li>Received an email from Germany that confirmed that
OTL/ODBC worked okay
with SAP DB. See the <a href="otl3_faq.htm">FAQ</a> page for more
detail.</li>
          <li>In OTL/OCI8/8i/9i: new template &lt;T&gt; <a
 href="otl4_refcur_stream.htm">otl_refcur_stream</a>&amp;
operator&gt;&gt;(<a href="otl4_refcur_stream.htm">otl_refcur_stream</a>&amp;
s, <a href="otl3_value.htm">otl_value</a>&lt;T&gt;&amp; val), which
was actually
forgotten;</li>
          <li>Purify was showing a possible memory leak when #define <a
 href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON </a>was
enabled, because std::vector::clear() function was
being called
inside a loop instead of outside:</li>
          <br>
          <tt>&nbsp;&nbsp; ...</tt> <br>
          <tt>&nbsp;&nbsp; for(int j=0;j&lt;sz;++j){</tt> <br>
          <tt>&nbsp;&nbsp;&nbsp;&nbsp; ...</tt> <br>
          <tt>&nbsp;&nbsp;&nbsp;&nbsp; ce.s.clear();</tt> <br>
          <tt>&nbsp;&nbsp;&nbsp;&nbsp; ...</tt> <br>
          <tt>&nbsp;&nbsp; }</tt> <br>
          <tt>&nbsp;&nbsp; ...</tt> <br>
&nbsp;The problem has been fixed in this release.&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.39):&nbsp;
        <ul>
          <li>A new type of SELECT statements was introduced in OTL
4.0.36: "WITH...
SELECT..." Inadvertently, the parsing of the new type of SELECT
statements
for DB2-CLI was coded so that the "WITH" keyword overrides the 4th
parameter
in the otl_stream constructor, or otl_stream::open() function: <a
 href="otl3_stream_class.htm#implicit_select">otl_implicit_select</a>.
In DB2 CLI, "WITH SELECT" can be treated both as a straight SELECT and
an implicit SELECT (similar to a call to a stored procedure that
returns
a result set), as far as handling the actual sequence of DB2 CLI
function
calls. It's more appropriate to treat the "WITH...SELECT" as implicit
if
the SQL statement gets opened as "otl_implicit_select." This release
fixes
thedeviation in the behavior that was inadvertently introduced in OTL
4.0.36.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.38):&nbsp;
        <ul>
          <li>A new version of <a href="otl3_stream_class.htm#flush">otl_stream::flush</a>()
for OTL/OCI8,8i,9i. See also example <a href="otl3_ex232.htm">232</a>.
This new flavor of the otl_stream::flush() function allows the program
to skip, say, duplicate rows in a batch of rows to be inserted, and
force
flushing of the rest of stream buffer. Only OCI8/8i/9i has teh
necessary
feature. No ODBC/DB2-CLI, sorry.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.37):&nbsp;
        <ul>
          <li>When compiling OTL with aCC / HP UX, a few "Future error"
compilation
warnings
come up because some data members in a base template class were not
accessed
via "this-&gt;" notataion in a derivative template class. That is a
feature
of aCC in the way how it looks up names in template classes. Other C++
compilers that are supported by OTL do not have that problem, and OTL
compiles
just fine. I hope I nailed down all of the compilation warnings. If
not,
let me know right away.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.36):&nbsp;
        <ul>
          <li>In ANSI SQL-92, there are so called <i>common table
expressions</i>,
which
are allowed as part of a <i>full select statement</i>. OTL did not
recongnize
SELECTs with common table expressions, for example: "WITH xx as
(SELECT...)
SELECT * from xx". It is a legitimate SELECT. This SQL construct now
gets
handled correctly by OTL. That is, OTL, in this release, recongnizes
this
kind of thing as a SELECT statement. FYI, only Oracle 9i, and DB2 UDB
(non-OS/390)
support this SQL construct.</li>
          <br>
&nbsp;
          <li>A <i>full select statement</i> is allowed to be enclosed
into parentheses
(but not by all database, MS SQL 7.0/2000 are an exception, for
example):
"((SELECT...FROM...))". OTL did not recognize this kind of construct as
a SELECT statement, and as a result, the statement was getting
instantiated
by OTL as a general input/output stream, instead of a specialized
SELECT
stream. The problem is fixed in this release.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.35):&nbsp;
        <ul>
          <li>When OTL/ODBC is being used in a combinatuion with an
Oracle ODBC
driver
to instantiate a stream with a SELECT statement that points a
nonexistant
table, the program crashes with "Memory Access Violation". The real
problem
is in the fact that the driver deffers the parsing until the "SELECT
describe"
call, or even until a later stage, and the OTL internal
describe_select_list()
allocates an array of 0 elements, which causes the program to crash.
The
bug has been fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.34):&nbsp;
        <ul>
          <li>When OTL stream pooling is used in a combination with
otl_stream::set_flush(false),
and a stream that has, say, an INSERT statement in it, gets saved to
the
stream pool and then reclamed from the pool, the stream would not flush
correctly, in case if otl_stream::flush() gets called explicitly (not
via
close(), or stream's destructor). The bug is fixed in this
release.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.33):&nbsp;
        <ul>
          <li>In order to reduce amount of memory allocated on stack,
some temporary
buffers were moved to the heap in cases, when it does not hurt
performance.
It is really a minor, yet crucial change, that allows platforms like
AIX,
or Windows, to run bigger OTL based programs.</li>
          <br>
&nbsp;
          <li>Set of new <a href="otl3_examples.htm#MyODBC35">examples</a>
for MySQL,
MyODBC 3.51. MyODBC 3.5 supports bind variables in the WHERE clause of
a SELECT statement. No bulk INSERTs / UPDATEs / DELETEs as well as
transaction
support,&nbsp; though.&nbsp;</li>
          <p><br>
Also, with MyODBC 3.5, the OTL MyODBC specific #define OTL_ODBC_MYSQL
is not required any longer, because the MyODBC 3.5 driver is more
compliant
with the ODBC 3.5 specification than before.</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.32):&nbsp;
        <ul>
          <li>In OTL/OCI8,8i,9i, in <a href="otl4_refcur_stream.htm">otl_refcur_stream</a>,
the following #defines are supported:</li>
          <br>
&nbsp;
          <ul>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_NUMERIC_NULL_TO_VAL">OTL_DEFAULT_NUMERIC_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_DATETIME_NULL_TO_VAL">OTL_DEFAULT_DATETIME_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_STRING_NULL_TO_VAL">OTL_DEFAULT_STRING_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_CHAR_NULL_TO_VAL">OTL_DEFAULT_CHAR_NULL_TO_VAL</a></li>
            <br>
&nbsp;
          </ul>
I must have overlooked this stream class.&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.31):&nbsp;
        <ul>
          <li>In OTL/ODBC, OTL/DB2-CLI, the numeric bind variables'
datatypes get
mapped
more accurately. Run a diff on OTL 4.0.30 and OTL 4.0.31 header files,
and see the difference for more detail.</li>
          <br>
&nbsp;
          <li>More verbage was added to the description of otl_stream::<a
 href="otl3_stream_class.htm#set_flush">set_flush</a>(),
because it seemed ambiguous to some folks, so that they misinterpreted
the description and wrote incorrect code.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.30):&nbsp;
        <ul>
          <li>In OTL/ODBC and&nbsp; OTL/DB2-CLI for Windows, <a
 href="otl3_connect_class.htm#set_timeout">otl_connect::set_timeout</a>()
did not have any effect on the otl_connect::<a
 href="otl3_connect_class.htm#rlogon">rlogon</a>()
function. Now it does, meaning that a logon / connect request will time
out correctly, if a timeout is set to something &gt; 0. <br>
          </li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.29 part III):&nbsp; <br>
&nbsp;
        <ul>
          <li>A documentation bug is fixed in the otl_connect::<a
 href="otl3_connect_class.htm#session_begin">session_begin</a>()
function. The function supports the SYSDBA, and SYSOPER modes, besides
the DEFAULT mode.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.29, part II):&nbsp;
        <ul>
          <li>A documentation bug is fixed in the otl_stream::<a
 href="otl3_stream_class.htm#get_rpc">get_rpc</a>()
function. This was apparently overlooked in the process of putting OTL
4.0.6 together, was a big release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.29):&nbsp;
        <ul>
          <li>Slight performance degradation was noticed in OTL 4.0.28
in operators
&lt;&lt;/&gt;&gt;
(std::string&amp;) after the operators had been extended to work with
Large
String Objects. Performance of reading/writing normal strings degraded
a little bit. I had to replace some if() statements with a switch,
which
is, apparently, more efficient.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="OTL4028"></a>New (in OTL 4.0.28):&nbsp;
        <ul>
          <li> <a href="otl3_stream_class.htm">otl_stream</a>, <a
 href="otl4_refcur_stream.htm">otl_refcur_stream</a>
operators &lt;&lt;(const std::string&amp;) /
&gt;&gt;(std::string&amp;), that
read and write std::strings (and also, corresponding versions of the
operators
for ACE_TStrnigs, <a href="http://www.cs.wustl.edu/%7Eschmidt/ACE.html">ACE</a>,
#define <a href="otl3_compile.htm#OTL_ACE">OTL_ACE</a>), and
enabled&nbsp;
by #define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>, <a
 href="otl3_compile.htm#OTL_STLPORT">OTL_STLPORT</a>,
now can read Large String Objects, like TEXT, LONG, CLOB, etc.,
depending
on the database type.</li>
          <p><br>
Some individuals got annoyed very much (thank you, guys, for the
format of your input!) by inconvenience of operators
&gt;&gt;(otl_long_string&amp;)
/ &lt;&lt;(const otl_long_string&amp;), so I had no choice but extend
the
std::string read/write operators to make them work with Large String
Objects.
Though, it may be more convenient, but it is less efficient, especially
in the case of Oracle CLOBs and operator&gt;&gt;(std::string&amp;),
because a
buffer of a fixed known size, allocated in advance,&nbsp; is required.
What operator &gt;&gt;(std::string&amp; ) has to do is to allocate the
buffer,
read the CLOB value into it, and then copy the value into the
std::string
output parameter. For multi-threaded programs, which will do a lot of
Oracle
CLOB reads, operator &gt;&gt;(std::string&amp;) may become a
bottleneck, unless
a special multi-heap memory allocator is used as a substitute for the
C++
default operators new() &amp; delete().&nbsp; </p>
          <p>See also examples <a href="otl3_examples.htm#EX_220">220-224</a>.</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.27):&nbsp;
        <ul>
          <li>A new function was introduced for OTL/OCI8i,9i:
otl_connect::<a href="otl3_connect_class.htm#change_password">change_password</a>().
The function is for changing Oracle user passwords. It could be used in
an application, that allows the user to change an expired password.</li>
          <p><br>
Also, see example <a href="otl3_examples.htm#EX_219">219</a></p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.26):&nbsp;
        <ul>
          <li>In OTL/OCI8/8i/9i, when the reference cursor flavor of
otl_streams is
being
used, in case if a NULL value gets entered into the stream, OTL sets
the
NULL indicator of the internal buffer of the stream to non-NULL . And
then,
the content of the internal buffer gets interpreted as a legitimte
value,
even thoug it's presumably random. The bug is fixed in this OTL release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.25):&nbsp;
        <ul>
          <li>In SQLBindParameter() call, for string buffers, that are
used&nbsp; for
binding with VARCHAR/CHAR columns, OTL/ODBC and&nbsp; OTL/DB2-CLI used
the string buffer size in&nbsp; the "Column Size" parameter of the
SQLBindParameter()
function. The Big/Little Endian dilemma here was that should the null
terminator
byte be included into the size or not. The practical answer to this
question
is that it should NOT. There is another parameter in the
SQLBindParameter()
call: the "Buffer Size". That parameter should include the null
terminator,
in case of SQL_C_CHAR type of the bind variable.&nbsp;</li>
          <br>
The problem is fixed in this OTL release.&nbsp;
          <p>The problem is actually very marginal, so you could it
only the case
when, say, the maximum allowed size fo VARCHAR/CHAR columns is 255 and,
a string bind variable is defined as char[256] to include the null
terminator.
Some ODBC&nbsp; drivers are more sensitive to this issue than
others.&nbsp;</p>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.24):&nbsp;
        <ul>
          <li>When PL/SQL table containers (OTL/OCIx) are used as input
parameters,
and
then reused, going from a larger string value to a smaller string value
may have the effect that the smaller string gets written over the
larger
value without the null terminator, and the resulting string is a
comnibation
of the two strings. The bug is fixed in this release.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.23):&nbsp;
        <ul>
          <li>New #define <a
 href="otl3_compile.htm#OTL_ADD_NULL_TERMINATOR_TO_STRING_SIZE">OTL_ADD_NULL_TERMINATOR_TO_STRING_SIZE.</a>
Also, see examples <a href="otl3_examples.htm#EX_211">211-216</a></li>
          <br>
&nbsp;
          <li>When <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
is enabled
and a BLOB column is used, the output length of a BLOB value (in a
SELECT
statement) gets counted in Unicode charaters, instead of bytes. The bug
is fixed in this release.</li>
          <br>
&nbsp;
          <li>New function was added to the otl_stream class: <a
 href="otl3_stream_class.htm#cancel">otl_stream::cancel()</a>.
The function allows executing SELECT statements to be canceled in
OTL/ODBC,
and OTL/DB2-CLI. See also example <a href="otl3_examples.htm#EX_217">217-218</a>.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.22):&nbsp;
        <ul>
          <li>New #define <a
 href="otl3_compile.htm#OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON">OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON</a>:
enables bind variable strict type checking.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.21):&nbsp;
        <ul>
          <li>When the OTL stream pooling is on (<a
 href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>)
, in the case of a stream with a SELECT statement, if the stream gets
closed
and reopened several times, otl_stream::eof() returns 0 when it should
return 1 (EOF). The problem was in the fact that the stream didn't
reset
some of its internal variables correctly, when the fetch sequence
was&nbsp;
not complete 100%. The problem is fixed in this release.</li>
          <br>
&nbsp;
          <li>Courtesy of the house. The following #defines work under
OTL_ORA7 starting
with this release:</li>
          <br>
&nbsp;
          <ul>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_NUMERIC_NULL_TO_VAL">OTL_DEFAULT_NUMERIC_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_DATETIME_NULL_TO_VAL">OTL_DEFAULT_DATETIME_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_STRING_NULL_TO_VAL">OTL_DEFAULT_STRING_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_CHAR_NULL_TO_VAL">OTL_DEFAULT_CHAR_NULL_TO_VAL</a></li>
            <br>
&nbsp;
          </ul>
The #defines were originally introduced back in OTL <a
 href="#NEW_OTL406">4.0.6. </a>It turns out that there are some people
who still work
with Oracle
7. For more detail, see example <a
 href="otl3_examples.htm#OTL_DEFAULT_VALUE">169</a>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.20):&nbsp; <br>
&nbsp;
        <ul>
          <li>A little bit of source code trimming (~ 8Kb) has been
done in this
release,
in order to cut down redundant code, that was introduced in OTL
4.0.19.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.19):&nbsp; <br>
&nbsp;
        <ul>
          <li>Now, OTL <a href="otl3_output_iterator.htm">otl_output_iterator</a>,<a
 href="otl3_input_iterator.htm">otl_input_iterator </a>compile with
STLPort 4.0 and STLPort 4.5, so #define <a
 href="otl3_compile.htm#OTL_STLPORT">OTL_STLPORT</a>
does not impose any restrictions on use of the OTL iterators.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.18):&nbsp; <br>
&nbsp;
        <ul>
          <li>Minor fix a problem that was introduced in OTL 4.0.17:
the OTL version
number was not converted correctly from decimal to hexadecimal format.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.17):&nbsp;
        <ul>
          <li>A new #define is introduced: <a
 href="otl3_compile.htm#OTL_VERSION_NUMBER">OTL_VERSION_NUMBER</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.16):&nbsp;
        <ul>
          <li>Basic support for Oracle's RAW datatype, which can be
used in a
combination
with OTL's <a href="otl3_bind_variables.htm#raw_long">raw_long</a>
placeholder
type and <a href="otl3_long_string.htm">otl_long_string</a> container.
For more detail, see example <a href="otl3_examples.htm#EX_210">210</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.15):&nbsp;
        <ul>
          <li>Support for SQL_VARBINARY ODBC datatype (e.g. MS SQL
Server's
varbinary).
OTL maps SQL_VARBINARY into SQL_LONGVARBINARY, which can be used in a
combination
with OTL's <a href="otl3_bind_variables.htm#raw_long">raw_long</a>
placeholder
type and <a href="otl3_long_string.htm">otl_long_string</a> container.
For more detail, see example <a href="otl3_examples.htm#EX_209">209.</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.1.14):&nbsp;
        <ul>
          <li>When otl_lob_stream's for OTL/OCI8/8i/9i are used, it's
possble to use
an anonymous PL/SQL block with a SELECT INTO statement, in order to get
a LOB locator from a table, and update the LOB value. This is an
alternative
form of&nbsp; UPDATE...SET ...=empty_clob()...WHERE...RETURNING... INTO
:XX&lt;clob&gt;</li>
          <br>
OTL didn't trim the LOB automatically, because it was assumed that
the "trimming" would be done via ...=emtpy_clob(). The bug is fixed in
this release of OTL. Fore more detail, see example <a
 href="otl3_examples.htm#EX_208">208</a>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.13):&nbsp;
        <ul>
          <li>A few compilation warnings were fixed for HP UX C++ (aCC).</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.12):&nbsp;
        <ul>
New #define <a href="otl3_compile.htm#OTL_EXCEPTION_HAS_MEMBERS">OTL_EXCEPTION_HAS_MEMBERS</a>..
It allows the <a href="otl3_exception_class.htm">otl_exception</a>
class
to have new members, for example, when the otl_exception class is <a
 href="otl3_compile.htm#OTL_EXCEPTION_DERIVED_FROM">derived</a>
from another class, which is part of an exception class hierarchy. For
more details, see examples <a
 href="otl3_examples.htm#OTL_EXCEPTION_DERIVED_FROM">205-207</a>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.11):&nbsp;
        <ul>
          <li>New #define <a
 href="otl3_compile.htm#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM</a>..
It allows the <a href="otl3_exception_class.htm">otl_exception</a>
class
to be derived from another class, that may be part of already existing
exception class hierarchy. For more details, see examples <a
 href="otl3_examples.htm#OTL_EXCEPTION_DERIVED_FROM">205-207</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 4.0.10):&nbsp;
        <ul>
          <li>When #define OTL_UNICODE is enabled in a combination with
either
OTL_ORA8I,
or OTL_ORA9I, and when reading a LONG, or a CLOB, or an NCLOB value
into
an otl_unicode_long_string, operator&gt;&gt;() puts a zero byte right
in the
middle of the otl_unicode_string. This error was due to the fact that
the
length of the string was calculated in bytes, instead of Unicode
chractares.
This release fixes the problem.</li>
          <br>
&nbsp;
          <li>When #define OTL_ORA_TIMESTAMP is enabled in a
combination of OTL_ORA8I,
or OTL_ORA9I, and external connection was instantiated via
otl_connect::rlogon(OCIEnv
*envhp,OCISvcCtx *svchp), in the XA environment, or in Pro*C,
operations
with otl_datetime fail, because "OCISession *authp" handle was used
instead
of the environment handle (OCIEnv *envhp). This release fixes the
problem.</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL408"></a>New (in OTL 4.0.9):&nbsp;
        <ul>
          <li>This is a maintenance release. The technique of&nbsp;
suppressing
"unused
argument" compilation warnings was changed from OTL_UNUSED_ARG(arg) in
the function body to /* arg */ in the function argument list. It seems
a little cleaner than the previous technique.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL408"></a>New (in OTL 4.0.8):&nbsp;
        <ol>
          <li> <a href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>
structure
was extended with the second's <i>fraction</i> field, and with <i>frac_precision</i>.
These new fields allow the user to specify the second down to its
fraction
part, say, down to milliseconds (MS SQL Server's datetime), or
microseconds
(DB2's, or Oracle 9i's timestamp).</li>
          <br>
&nbsp;
          <li>New #define: <a href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a>,
which enables basic support for Oracle 9i's <i>timestamp</i> datatype
(now
timestamps with [local] time zones yet, though).</li>
          <br>
&nbsp;
          <li>For more detal on (1), (2), see examples <a
 href="otl3_examples.htm#otl_datetime_fraction">202-204</a>.</li>
          <br>
&nbsp;
          <li>Several "unused argument" warnings are fixed.</li>
          <br>
&nbsp;
        </ol>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL407"></a>New (in OTL 4.0.7):&nbsp;
        <ul>
          <li>A new OTL defined exception is introduced: "Stream buffer
size can't be
&gt; 1 in this case." (Code <a href="otl3_exc_list.htm#32017">32017</a>).
This exception is for patching the loophole that allows the user to
define
a stream buffer size larger than 1, in case if the stream has LOB bind
variables/columns, when in reality the limit is 1.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL406"></a>New (in OTL 4.0.6):&nbsp;
        <ul>
          <li>In OTL/OCI, support for Unicode:</li>
          <br>
&nbsp;
          <ul>
            <li>Oracle 8i, UCS-2</li>
            <li>Oracle 9i, UTF-16</li>
            <br>
&nbsp;
          </ul>
Basically, everything that works with / makes sense for the one-byte
character
OTL functionality, should work with the Unicode OTL. For more detail,
see
examples <a href="otl3_examples.htm#OTL_ORA8I_UNICODE">174-187</a> for
Oracle 8i, and examples <a href="otl3_examples.htm#OTL_ORA9I_UNICODE">188-201</a>
for Oracle 9i.&nbsp; <br>
&nbsp;
          <li>New&nbsp; #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>,
that can be used in a combinatiowith either #define OTL_ORA8I, or&nbsp;
#define OTL_ORA9I.</li>
          <br>
&nbsp;
          <li>New class <a
 href="otl3_long_string.htm#otl_long_unicode_string">otl_long_unicode_string</a>,
a specialized derivative of otl_long_string, for operations with LONGs,
CLOBs, and NCLOBs, the character based large object datatypes.</li>
          <br>
&nbsp;
          <li>New in otl_connect (for OTL/OCI8i,OCI9i) function: <a
 href="otl3_connect_class.htm#set_character_set">set_character_set</a>().
The function is needed for proper setting of
client-to-server/server-to-client
character conversions when the default character [set] datatypes
CHAR/VARCHAR2/LONG/CLOB
are used, or the national character [set] datatypes
NCHAR/NVARCHAR2/NCLOB
are used.</li>
          <br>
&nbsp;
          <li>In OTL/OCI8i,OCI9i, in otl_connect class, the OCI
internal "environment
handle" (<tt>otl_connect::connect_struct.envhp</tt>) is available to
access
the Unicode OCI character transformation functions. OCI8i has about 2
dozen
such functions, OCI9i -- about 4-5 dozen (see "National Language /
Globalization
Support Guide").&nbsp;</li>
          <br>
&nbsp;
          <li><b><i>Note</i></b>: besides the Unicode OTL examples,
also see "National
Language Support Guide" (Oracle 8i),&nbsp; "Globalization Support
Guide"
(Oracle 9i), the "OCI Programming with Unicode" chapters of the Oracle
Call Interface Programmer's Guide (both Oracle 8i, and Oracle 9i).</li>
          <br>
&nbsp;
          <li>A bug fix in otl_connect::server_attach(), and
otl_connect::session_begin(),
OTL/ORA8/8i/9i. both functions didn't reset the throw_count flags, so
when
they are used,and when an otl_exception gets thrown, subsequent calls
to
the functions fail, because of the throw_count flag.&nbsp;</li>
          <br>
&nbsp;
          <li>A workaround for a compilation problem in OTL/ORA8/8i/9i
and #include &lt;fstream.h&gt;.
oci.h defines symbol "text", which is either typedef unsigned char, or,
sometimes, it is defined as a #define, depending on the platform, and
the
compiler. OTL introduces a new #define: #define <a
 href="otl3_compile.htm#OTL_ORA_TEXT_ON">OTL_ORA_TEXT_ON</a>.
When it is defined before the OTL header file gets included, OTL
redefines
the "text" symbol as a locally defined #define text OTL_ORA_TEXT, in
order
to mask the extrenal "text"symbol in the OTL header file itself. And,
at
the end of the OTL header file, the locally defined #define text
OTL_ORA_TEXT
gets undefined, in order to return the compilation the state of
before-OTL-was-included.
It has been a very annonying problem to some folks throughout the
co-existance
of&nbsp; the OCI and &lt;fstream.h&gt;. See examples <a
 href="otl3_examples.htm#OTL_ORA_TEXT_ON">172,
173</a> for more detail.&nbsp;</li>
          <br>
&nbsp;
          <li>In a few cases, some folks expressed a need to convert
database NULLs into
something more C++ readable, besides a random value in the output
buffer,
even thouh it is a very standard behavior ni systems like Pro*C,
Embedded
SQL, etc. For example, a string NULL could be converted into "", a
numeric
NULL could be converted into 0, a DATE/TIME NULL could be a date/time
value
from a distant past. Under the assumption that NULL gets converted /
defaulted
to a value, it would be sufficient to check for the value, instead of
checking
for otl_stream::is_null() == true. In order to satisfy those folks'
need,
OTL: introduces the following new #defines:&nbsp;</li>
          <br>
&nbsp;
          <ul>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_NUMERIC_NULL_TO_VAL">OTL_DEFAULT_NUMERIC_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_DATETIME_NULL_TO_VAL">OTL_DEFAULT_DATETIME_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_STRING_NULL_TO_VAL">OTL_DEFAULT_STRING_NULL_TO_VAL</a></li>
            <li> <a
 href="otl3_compile.htm#OTL_DEFAULT_CHAR_NULL_TO_VAL">OTL_DEFAULT_CHAR_NULL_TO_VAL</a></li>
          </ul>
          <p><br>
These new #defines can be defined to anything: a constant, a function
call, etc., that would make sense at compile time.&nbsp; </p>
          <p>This new feature, even though it's generic enough, is not
a shortcut
for otl_stream::is_null().&nbsp; </p>
          <p>For more detail, see examples <a
 href="otl3_examples.htm#OTL_DEFAULT_VALUE">169,
170, 171</a>.&nbsp; <br>
&nbsp; </p>
          <li><a href="otl3_stream_class.htm#clean">otl_stream::clean</a>()
function
was extended to "clean" the stream that executes straight SELECT
statements
(all databases), implicit result sets (e.g. MS SQL Server, Sybase, or
DB2
via stored procedures), referenced cursors (Oracle 7, 8, 8i, 9i),
before&nbsp;
the fetch sequence is exhausted (not all rows are yet fetched, in other
words), or in the case of a database error, or any other C++ exception
has occurred. Fore more detail, see examples <a
 href="otl3_examples.htm#clean_select">159-168</a>.</li>
          <ul>
&nbsp;
          </ul>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL405"></a>New (in OTL 4.0.5):&nbsp;
        <ul>
          <li>In OTL/ODBC, OTL/DB2-CLI, a new function and a new
constructor in
otl_connect: <a href="otl3_connect_class.htm#ext_logon_odbc">rlogon</a>(HENV,HDBC,int),<a
 href="otl3_connect_class.htm#ext_otl_connect_odbc">otl_connect</a>(HENV,HDBC,int).
It allows the ODBC or DB2-CLI code to be patched with OTL. In other
words,
if you have a piece of legacy code in straight ODBC, or DB2-CLI, you
could
use the primary, existing database connection (environment, and
database
connect handles), in order to instantiate a secondary, OTL connect.
More
more detail, see examples <a href="otl3_examples.htm#ext_logon_odbc">157,
158</a>.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL404"></a>New (in OTL 4.0.4):&nbsp;
        <ul>
          <li>This is a maintenance release, which fixes a bug,
recently (in 4.0.3)
introduced
in OTL/ODBC.&nbsp;</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL403"></a>New (in OTL 4.0.3):&nbsp;
        <ul>
          <li>This is a maintenance release, which fixes a bug,
recently introduced
in
OTL/ODBC for ODBC 3.x. A return code of a call to ODBC was not checked
for errors.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL402"></a>New (in OTL 4.0.2):&nbsp;
        <ul>
          <li>In OTL/OCI8/9, a new function in otl_connect: <a
 href="otl3_connect_class.htm#cancel">cancel</a>().
The function allows asynchronous cancellation of any database call,
executiing
through&nbsp; the otl_connect object. For more detail, see example <a
 href="otl4_ex156.htm">156</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL401"></a>New (in OTL 4.0.1):&nbsp; <br>
&nbsp;
        <ul>
          <li>In OTL/ODBC, and OTL/DB2-CLI, a new function in
otl_connect: <a
 href="otl3_connect_class.htm#set_transaction_isolation_level">set_transaction_isolation_level</a>().
It allows the user to set up the following transaction isolation
level:&nbsp;</li>
          <br>
&nbsp;
          <ul>
            <li>READ COMMITTED</li>
            <li>READ UNCOMMITTED&nbsp;</li>
            <li>REPEATABLE READ</li>
            <li>SERIALIZABLE</li>
            <br>
&nbsp;
          </ul>
For detail, see examples <a
 href="otl3_examples.htm#transaction_isolation_level">154,
155</a>
          <ul>
&nbsp;
          </ul>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><a name="NEW_OTL400"></a>New (in OTL 4.0.0):&nbsp;
        <ul>
          <li>It is an accumulative release that fixes a number of bugs
(e.g. a bug
in
stream pooling and exceptions), compilation warnings and provides&nbsp;
better support for newer compilers like GNU C++ 3.0.x, Forte C++ 6.x
(successor
of&nbsp; Sun Pro C++), aCC (ANSI C++ for HP UX), as well as xlC 5.x
(IBM
C++ on AIX).</li>
          <br>
&nbsp;
          <li>Support for Open Source <a
 href="http://www.borland.com/devsupport/interbase/opensource/">Interbase
6.x</a> via <a href="http://www.xtgsystems.com/">XTG Systems</a> '
Open
Source <a href="http://www.xtgsystems.com/ib6odbc.php3">ODBC driver
for
Interbase</a>. A new #define <a href="otl3_compile.htm#INTERBASE">OTL_ODBC_XTG_IBASE6</a>
was introduced in order to make OTL work correctly with the driver. A
number
of code examples to illustrate this new feature (<a
 href="otl3_examples.htm#INTERBASE">133,
134, 135, 136, 137, 138, 139</a>) were added to the list of <a
 href="otl3_examples.htm">OTL
code examples</a>.</li>
          <br>
&nbsp;
          <li>Support for Open Source <a
 href="http://www.postgresql.org">PostgreSQL
7.x.x&nbsp;</a> via the <a href="http://odbc.postgresql.org">PostgreSQL
ODBC</a> driver that is also Open Source. A number of code examples to
illustrate this new feature (<a href="otl3_examples.htm#POSTGRESQL">140,
141, 142, 143, 144, 145, 146</a> ) were added to the list of <a
 href="otl3_examples.htm">OTL
code examples</a>.</li>
          <br>
&nbsp;
          <li>Better backward compatibility with ODBC 2.5
specification. When ODBCVER
is set to 0x0250 (#define ODBCVER 0x0250) , OTL makes ODBC 2.5
compliant
calls, instead of assuming that the level of ODBC is greater than or
equal
to 0x0300. See example <a href="otl4_ex147.htm">147</a>&nbsp; for more
detail.</li>
          <br>
&nbsp;
          <li>Support for Oracle 9i. A new #define was introduced:
#define <a href="otl3_compile.htm#OTLORA9I">OTL_ORA9I</a>.
Basically, everything that works for OTL_ORAXX, works for OTL_ORA9I,
therefore,
this new #define should be okay to use with already existing code.
Later
on, new, Oracle 9i specific features will be introduced under #define
OTL_ORA9I.
This time, no special examples are need to illustrate the new #define.
Any example for OTL/OCI7, OTL/OCI8 can be used with #define OTL_ORA9I.</li>
          <br>
&nbsp;
          <li>Support for a new bind variable type in <a
 href="otl3_stream_class.htm">otl_stream</a>
for OCI8/9: :var&lt;<b><a href="otl3_bind_variables.htm#refcur"> refcur</a></b>,out[XXX]&gt;.
It allows the otl_stream to return multiple reference cursors from the
same PL/SQL block/stored procedure call. This new type of bind
variables
allows the user to combine reference cursors with other input/output
parameters
in a single stored procedure call. See examples <a
 href="otl3_examples.htm#otl_refcur_stream">148,
149, 150, 151</a> for more detail.&nbsp;</li>
          <br>
&nbsp;
          <li>New in otl_stream for OTL/OCI8/9 function: <a
 href="otl3_stream_class.htm#get_stream_type">get_stream_type</a>().
The function returns the <a href="otl3_stream_class.htm#stream_types">type</a>
of SQL statement, which the stream was instantiated with. See example <a
 href="otl4_ex152.htm">152</a>
for more detail.</li>
          <br>
&nbsp;
          <li>New in otl_stream for OTL/OCI8/9 function: <a
 href="otl3_stream_class.htm#create_stored_proc_call">create_stored_proc_call</a>(),
that automatically creates a stored procedure call with definitions of
the procedure's parameters. See example <a href="otl4_ex153.htm">153</a>,
for more detail.</li>
          <br>
&nbsp;
          <li>New function in otl_connect: <a
 href="otl3_connect_class.htm#otl_terminate">otl_terminate</a>.
This function is static in class and defined only for OTL/OCI8i,9i.</li>
          <br>
&nbsp;
          <li>&nbsp;New #define is introduced: #define <a
 href="otl3_compile.htm#OTL_ODBC_SQL_EXTENDED_FETCH_ON">OTL_ODBC_SQL_EXTENDED_FETCH_ON</a>.
Normally, if ODBC version is set to &gt;= 3.0, SQLFetchScroll is used.
However,
some ODBC drivers, as well as DB2 CLI in Linux (DB2 in Linux, even in
Linux/390),
have a bug in SQLFetchScroll, when CLOB/BLOB fields are used. This new
#define forces OTL to use SQLExtendedFetch instead, or even SQLFetch,
in
the case of the stream buffer size of 1.&nbsp;</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 3.2.20):&nbsp;
        <ul>
          <li>A fix for problem <a href="otl3_prob.htm#prob62">62</a></li>
          <br>
&nbsp;
          <li>A fix for problem <a href="otl3_prob.htm#prob63">63</a>.
Now, OTL throws
a new <a href="otl3_exc_list.htm#32013">OTL-defined exception</a> with
error code 32013.</li>
          <br>
&nbsp;
          <li>A <a href="otl3_stream_class.htm#describe_vars">group</a>
of new functions
was introduced for describing the otl_stream's bind variables:</li>
          <br>
&nbsp;
          <ul>
            <li> <a href="otl3_stream_class.htm#describe_in_vars">describe_in_vars</a>
()</li>
            <li> <a href="otl3_stream_class.htm#describe_out_vars">describe_out_vars</a>
()</li>
            <li> <a href="otl3_stream_class.htm#describe_next_in_var">describe_next_in_var</a>
()</li>
            <li> <a href="otl3_stream_class.htm#describe_next_out_var">describe_next_out_var</a>
()</li>
            <br>
&nbsp;
          </ul>
For more detail, see examples <a href="otl3_ex130.htm">130</a>, <a
 href="otl3_ex131.htm">131</a>, <a href="otl3_ex132.htm">132</a>.&nbsp;
          <ul>
&nbsp;
          </ul>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>New (in OTL 3.2.19):&nbsp;
        <ul>
          <a href="otl3_lob_stream.htm">LOB stream mode</a>, previously
implemented
in OTL 3.1.14 for OCI8 only, is extented to OTL/ODBC and OTL/DB2 CLI<font
 size="+1">
:</font> now, the <a href="otl3_lob_stream.htm">otl_lob_stream</a>
class
implements the LOB stream mode for OTL/OCI8, OTL/ODBC, and
OTL/DB2-CLI.&nbsp;
          <p>Also, a new function in the otl_stream class was
introduced in order
to support the LOB stream mode: <a
 href="otl3_stream_class.htm#set_lob_stream_mode">set_lob_stream_mode</a>().&nbsp;
          </p>
          <p>For more detal, see examples <a href="otl3_ex122.htm">122</a>
, <a href="otl3_ex123.htm">123</a>, <a href="otl3_ex124.htm">124</a>,
          <a href="otl3_ex125.htm">125</a>, <a href="otl3_ex126.htm">126</a>,
          <a href="otl3_ex127.htm">127</a> , <a href="otl3_ex128.htm">128</a>,
          <a href="otl3_ex129.htm">129.</a> <br>
&nbsp; </p>
          <li>A fix for problem <a href="otl3_prob.htm#prob61">61</a></li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td>OTL 3.2.18 compared to OTL 3.2.17 has no visible changes.
This is a
maintenace release. A few changes were made under #define <a
 href="otl3_compile.htm#OTL_ACE">OTL_ACE</a>
to use more appropriate containers for better implementation of&nbsp;
the <a href="otl3_stream_pooling.htm">otl_stream pooling</a>.</td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.17):&nbsp;
        <ul>
          <li>New #define <a href="otl3_compile.htm#OTL_STLPORT">OTL_STLPORT</a>
was
inroduced in order to fix problems <a href="otl3_prob.htm#prob60">60</a>
. Briefly, OTL_STLPORT can be used whenever OTL_STL is used, except for
            <a href="otl3_output_iterator.htm">otl_output_iterator</a>,
            <a href="otl3_input_iterator.htm">otl_input_iterator </a>.</li>
          <br>
&nbsp;
          <li>New #define <a
 href="otl3_compile.htm#OTL_VALUE_TEMPLATE_ON">OTL_VALUE_TEMPLATE_ON</a>
was introduced in order to make the <a href="otl3_value.htm">otl_value&lt;T&gt;</a>
class available without turning #define <a
 href="otl3_compile.htm#OTL_STL">OTL_STL</a>
on. Fore more detail, see examples <a href="otl3_ex119.htm">119</a> , <a
 href="otl3_ex120.htm">120</a>,<a href="otl3_ex121.htm">121</a></li>
          <br>
&nbsp;
          <li>New #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">OTL_USER_DEFINED_STRING_CLASS_ON</a>
was introduced for specifying a string class name for reading from /
writing
to&nbsp; the otl_streamm other than STL's <i>std::string</i>. This
feature
is useful for specifynig <i>(1)</i> a third-party string class other
than
std::string, or, specifying <i>(2)</i> std::string class without
turning
on #define OTL_STL. <br>
          </li>
          <p>(1) makes sense for multi-threaded, scalable application,
when a more
efficient [than std::string] string class is required. For example, a
string
class without string reference counters, and any internal locking, with
a more optimal string memory allocator.&nbsp; </p>
          <p>(2) makes sense for cases when&nbsp; it would be nice to
have operators
&lt;&lt;(otl_stream&amp;,...) and &gt;&gt;(otl_stream&amp;,...) defined
for a
third-party string class, or even for std::string without turning on
#define
OTL_STL, since not all C++ compilers compile OTL successfully with
OTL_STL
on.&nbsp; </p>
          <p>Fore more detail, see examples <a href="otl3_ex119.htm">119</a>
, <a href="otl3_ex120.htm">120</a>, <a href="otl3_ex121.htm">121</a> <br>
&nbsp; </p>
          <li>New #define <a href="otl3_compile.htm#OTL_ACE">OTL_ACE</a>
was inroduced
as an effort to integrate OTL with <a
 href="http://www.cs.wustl.edu/%7Eschmidt/ACE.html">ACE.</a>
More precisely, STL-like features of OTL (string class in otl_stream
operations,
OTL_STREAM_POOLING, based on STL containers, etc.). In case with ACE,
when
OTL_ACE is defined, OTL_STERAM_POOLING is implemented on top of ACE's
Array
and Hasp_Map classes. The string class for otl_stream's operations is
ACE_TString.&nbsp;</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.16):&nbsp;
        <ul>
          <li>Problems <a href="otl3_prob.htm#prob57">57</a>, <a
 href="otl3_prob.htm#prob58">58</a>, <a href="otl3_prob.htm#prob59">59</a>
are fixed.</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.15):&nbsp;
        <ul>
          <li>Problems <a href="otl3_prob.htm#prob52">52</a>, <a
 href="otl3_prob.htm#prob54">54</a>, <a href="otl3_prob.htm#prob55">55</a>
are fixed.</li>
          <br>
&nbsp;
          <li>As a fix to problem <a href="otl3_prob.htm#prob53">53</a>
, a new otl_stream
function was introduced: otl_stream::<a
 href="otl3_stream_class.htm#set_flush">
set_flush</a>(). See also examples <a href="otl3_ex116.htm">116</a>, <a
 href="otl3_ex117.htm">117</a>,<a href="otl3_ex118.htm">118</a>.</li>
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.14):&nbsp;
        <ul>
          <li>Problems <a href="otl3_prob.htm#prob50">50</a>, <a
 href="otl3_prob.htm#prob51">51</a>
are fixed.&nbsp;</li>
          <br>
&nbsp;
          <li>A new mechanism was implemented: <a
 href="otl3_stream_pooling.htm">otl_stream
pooling</a>. In order to activate it, a new #define and a function were
introduced: #define <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>,
otl_connect::<a href="otl3_connect_class.htm#set_stream_pool_size">
set_stream_pool_size</a>().
otl_stream::<a href="otl3_stream_class.htm#close"> close</a>() was also
extended with an extra parameter. For more detail, examples <a
 href="otl3_ex113.htm">113</a>,<a href="otl3_ex114.htm">114</a>
, <a href="otl3_ex115.htm">115</a>.</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.13):&nbsp;
        <ul>
          <li>Problem <a href="otl3_prob.htm#prob45">45</a> is
fixed.&nbsp;</li>
          <br>
&nbsp;
          <li>Problem <a href="otl3_prob.htm#prob46">46</a> is fixed.
A new #define was
introduced to enable the fix / feature: <a
 href="otl3_compile.htm#OTL_UNCAUGHT_EXCEPTION_ON">OTL_UNCAUGHT_EXCEPTION_ON</a>.
For more detail, see examples <a href="otl3_ex101.htm">101</a>, <a
 href="otl3_ex102.htm">102</a>, <a href="otl3_ex103.htm">103</a> , and
read the description
of the problem <a href="otl3_prob.htm#prob46">46</a> more carefully.</li>
          <br>
&nbsp;
          <li>Problem <a href="otl3_prob.htm#prob47">47</a> is fixed.
A new #define <a href="otl3_compile.htm#OTL_EXTENDED_EXCEPTION">OTL_EXTENDED_EXCEPTION</a>
was introduced to enable the otl_exception's <a
 href="otl3_exception_class.htm#EXTENDED">extended
fields</a> for OTL/ODBC and OTL/DB2-CLI. See also example <a
 href="otl3_ex104.htm">104</a>.</li>
          <br>
&nbsp;
          <li>Problem <a href="otl3_prob.htm#prob48">48</a> is fixed.
See also example <a href="otl3_ex105.htm">105</a>. If MS SQL Server is
being
accessed from
Linux via a ODBC-to-ODBC brigde, the corresponding ODBC driver on the
Linux
side should be compliant with ODBC 3.5. Otherwise, support of GUIDs
will
not be enabled, and the result of running the example 105 will be
unpredictable.</li>
          <br>
&nbsp;
          <li>Problem <a href="otl3_prob.htm#prob49">49</a> is fixed.
See also examples <a href="otl3_ex106.htm">106</a>, <a
 href="otl3_ex107.htm">107</a>
, <a href="otl3_ex108.htm">108</a>, <a href="otl3_ex109.htm">109</a>
. This actually is a new
feature in OTL/ODBC
and in OTL/DB2-CLI: bulk operations with LOB data types (LONG, LONG
RAW,
CLOB, BLOB, TEXT, IMAGE, etc.). Keep in mind, when writing portable
code,
that this feature is NOT compatible with with OTL/OCIx.</li>
          <br>
&nbsp;
          <li>New <a href="otl3_stream_class.htm#set_all_column_types">otl_stream::set_all_column_types</a>
() function, which allows to override the default mapping of column
groups
in SELECT otl_stream's. For example: map all numeric columns to
strings,
map all date columns to strings, or the combination of both.This
feature
provides a handier interface in case of large numbers or date-to-string
handling, when the structure of the SELECT statement is unknown in
advance.</li>
          <br>
See also example <a href="otl3_ex110.htm">110</a>, <a
 href="otl3_ex111.htm">111</a>, <a href="otl3_ex112.htm">112</a>.&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.12): problem <a
 href="otl3_prob.htm#prob44">44</a>
is fixed.Also it was reported that, in fact, problem <a
 href="otl3_prob.htm#prob39">39</a>
was resolved for at least DB2 7.x, xlC/Visual Age 5, in AIX.</td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.11): problem <a
 href="otl3_prob.htm#prob43">43</a>
is fixed. No other changes.</td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.10): problem <a
 href="otl3_prob.htm#prob42">42</a>
is fixed. The following new #define is introduced: #define <a
 href="otl3_compile.htm#OTL_STL_NOSTD_NAMESPACE">OTL_STL_NOSTD_NAMESPACE</a>.
I didn't create any code samples for this. Here's how to use this new
#define
with aCC and #define OTL_STL:&nbsp;
        <p>...&nbsp; <br>
#define OTL_STL&nbsp; <br>
#define OTL_STL_NOSTD_NAMESPACE</p>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.9):&nbsp;
        <ul>
          <li>This release fixes problem <a href="otl3_prob.htm#prob40">40</a>,
that
was introduced in OTL 3.2.8.&nbsp;</li>
          <br>
&nbsp;
          <li>This release also fixes problem <a
 href="otl3_prob.htm#prob41">41</a>.
ANSI C++ standard deprecates using the keyword <i>static</i> as a
means
of forcing the scope of a function to be the current compilation module
and it is recommended that unnamed namespaces be used instead.&nbsp;</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.8):&nbsp;
        <ul>
          <li>by requests from some users, otl_connect::<a
 href="otl3_connect_class.htm#auto_commit_on">
auto_commit_on</a>() and otl_connect::<a
 href="otl3_connect_class.htm#auto_commit_off">
auto_commit_off</a>() are back. These functions used to be in the old
OTL
(1.x, 2.x) and were removed in OTL 3.0. I've put them back for partial
backward compatibility. However, I do NOT encourage anybody to use them
because it's a bad practice.</li>
          <br>
&nbsp;
          <li>new template class <a href="otl3_value.htm">otl_value</a>.
It integrates
the scalar value container and the NULL indicator functionality in one
template class. For more detail, see examples <a href="otl3_ex97.htm">97</a>,
            <a href="otl3_ex98.htm">98</a>, <a href="otl3_ex99.htm">99</a>,
            <a href="otl3_ex100.htm">100</a>.</li>
          <br>
&nbsp;
          <li>Problems <a href="otl3_prob.htm#prob36">36</a>, <a
 href="otl3_prob.htm#prob37">37</a>, <a href="otl3_prob.htm#prob38">38</a>
are fixed in this
release of OTL.</li>
          <br>
&nbsp;
        </ul>
        </td>
        <td><br>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.7). A new database backend
is supported: <i><a href="http://www-4.ibm.com/software/data/db2/">DB2</a></i>
with its
native <i>Call Level Interface </i>(CLI) in Windows and Unix
platforms.
Basically, a new OTL-adaptor (OTL/DB2-CLI) was developed for <a
 href="http://www-4.ibm.com/software/data/db2/">DB2-CLI</a>.
Respectively, a new #define was introduced for the new OTL-adaptor:
#define <a href="otl3_compile.htm#OTL_DB2_CLI">OTL_DB2_CLI</a>.
OTL/DB2-CLI uses
both DB2-CLI's native header files and DB2-CLI's native object
libaries.&nbsp;
        <p>Besides the OTL_DB2_CLI macro definition, another #define
was introduced: <a href="otl3_compile.htm#OTL_EXPLICIT_NAMESPACES">OTL_EXPLICIT_NAMESPACES</a>
. It allows to overide OTL's default namespace generation: if one
OTL-adaptor
is enabled than no namespaces are generated, more than one --
namespaces
are generated (<b>oracle::</b>, <b>odbc::</b>, <b>db2::</b>).&nbsp; </p>
        <p>Under OTL_EXPLICIT_NAMESPACES, the namespaces always get
generated.&nbsp; </p>
        <p>Two new datatypes for declaring bind variables were
introduced: <a href="otl3_bind_variables.htm#db2time">db2time</a>, <a
 href="otl3_bind_variables.htm#db2date">db2date</a>. They are
required
when a DB2 DATE or DB2 TIME column is used, respectively.
db2time/db2date
should be used with both OTL/DB2-CLI and OTL/ODBC for DB2.&nbsp; </p>
        <p>This is the only thing that makes DB2 different from other
ODBC data
sources (e.g. MS SQL Server, Sybase, Oracle, MySQL).</p>
        </td>
        <td>The question is: Why OTL/DB2-CLI is released as OTL 3.2.7,
rather than
OTL 3.3.0?&nbsp;
        <p>On the one hand, acquiring a new database / writing a new
OTL-adaptors
has become a routine procedure. On the other hand, the fact that DB2's
Call Level Interface (CLI) is based on the ODBC 3.0 specification plus
extentions, made the task easy, and, OTL/DB2-CLI is not much different
from OTL/ODBC.&nbsp; </p>
        <p>In the core, it's still the same OTL-adaptor, with a couple
of things,
controlled by conditional compilation.&nbsp; </p>
        <p>Bottom line: the OTL header file has grown only a few more
kilobytes
bigger, but it now supports such a new major player database as
DB2.&nbsp; </p>
        <p>For more detail, see <a href="otl3_examples.htm#DB2_CLI">examples</a>
for DB2 Call Level Interface (CLI)</p>
        </td>
      </tr>
      <tr>
        <td>In OTL 3.2.6, a couple of fixes have been made.</td>
        <td>See problems #<a href="otl3_prob.htm#prob34">34</a>, #<a
 href="otl3_prob.htm#prob35">
35</a> for more detail.</td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.5): <a
 href="otl3_pl_tab.htm">STL vector
based containers for PL/SQL tables</a> (OCIx). The containers relax all
possible requirements on sizes/dimensions. Instead of C-style null
terminated
character arrays, vectors of <i>std::string</i>s are supported, as
well
as vectors of <a href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>,
and a number of numeric vectors.&nbsp;
        <p>Briefly, OTL 3.2.5 is an evolutionary step toward a better
handling
of PL/SQL tables from C++. The interface is pretty much the same as the
static or dynamic containers for PL/SQL tables, with the exception of
being
STL-vector based.</p>
        </td>
        <td>For more detail, see examples <a href="otl3_ex85.htm">85</a>,<a
 href="otl3_ex86.htm">86</a>, <a href="otl3_ex87.htm">87</a>, <a
 href="otl3_ex88.htm">88.</a></td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.4): OTL/ODBC supports MySQL
(the Open
Source SQL database server) via [the new] #define <a
 href="otl3_compile.htm#OTL_ODBC_MYSQL">OTL_ODBC_MYSQL</a>
in the Windows platforms. Also, combined with #define OTL_ODBC_UNIX and
the Open Source library, called UnixODBC, OTL/ODBC for MySQL can be
used
in the Linux platform.</td>
        <td>MySQL as a new supported [by OTL] SQL database extends the
series of
databases, covered by the OTL umbrella.&nbsp;
        <p>This makes it possible to write even more [than ever before]
portable
code, without any significant degradation in performance and
readability.&nbsp; </p>
        <p>For more detail, see <a href="otl3_examples.htm#MYODBC">MyODBC
for MySQL</a></p>
        </td>
      </tr>
      <tr>
        <td><blink>New</blink> (in OTL 3.2.3): OTL compiles clean
(without annoying
compiler warnings) with the <a href="http://www.kai.com">KAI</a> C++
compiler.</td>
        <td>I was told that KAI C++ is a more solid, better, bug free
C++ compiler
than many others.</td>
      </tr>
      <tr>
        <td><blink>New</blink> (in OTL 3.2.2): "Default
user"/"extrenal" authentication
now works correctly in OTL/OCI8: db.rlogon("/") gets parsed as a
special
case and works okay with OTL/OCI8</td>
        <td>I missed the fact that in OCI8 "default user"
authentication is done
in a different way compared to OCI7. The assumption was that it was
backward
compatible at the level of OCI.</td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.1):&nbsp;
        <ol>
          <li>New #define <a href="otl3_compile.htm#OTL_ODBC_UNIX">OTL_ODBC_UNIX.</a>
It allows OTL/ODBC to be used with ODBC bridges in Unix.&nbsp;</li>
          <br>
&nbsp;
          <li>OTL/ODBC: in order to get the <i>row processed</i>
count, calls to SQLGetDiagField()
were replaced with calls to SQLRowCount().</li>
          <br>
&nbsp;
          <li>OTL/ODBC: in SQLSetConnectAttr(..., SQL_ATTR_AUTOCOMMIT,
..., <i>SQL_NTS), </i>SQL_NTSwasreplaced with<i> </i>SQL_IS_POINTER.</li>
          <br>
&nbsp;
          <li>OTL/OCI7: in calls to oparse(), the enforcement of strict
compliance with
Oracle 6 was relaxed.&nbsp;</li>
        </ol>
        </td>
        <td>
        <ol>
          <li>I didn't create any new examples on this. OTL/ODBC
examples can be used.</li>
          <br>
&nbsp;
          <li>This was done to streamline the use of ODBC functions. At
least, it allowed
to extend the list of ODBC drivers which OTL/ODBC doesn't crash.</li>
          <br>
&nbsp;
          <li>This doesn't crash any ODBC drivers, that were known to
be working with
OTL/ODBC before, but this change allows the list of ODBC drivers that
don't
crash under OTL/ODBC to be extended , e.g. the ODBC driver for MS
Access
works fine. I've not identified the versions of MS Access ODBC drivers
which OTL/ODBC fails.</li>
          <br>
&nbsp;
          <li>It's about time, isn't it? I mean that Oracle 6 has been
history for a
long time and Oracle 7 is going down the same path (will be
discontinued
relatively soon). <br>
          </li>
          <p>This relaxation in the OCI7 bevahior allows OCI7 calls to
be linked
and successfully used with OCI8 libraries.</p>
        </ol>
        </td>
      </tr>
      <tr>
        <td><blink>New </blink>(in OTL 3.2.0):&nbsp;
        <ol>
          <li>Support of the STL <a
 href="otl3_stream_class.htm#stl_string_read">reading</a>/<a
 href="otl3_stream_class.htm#stl_string_write">writing</a><i>
std::string</i>'s from/to otl_stream's. This feature can be turned on
with
#define OTL_STL.</li>
          <br>
&nbsp;
          <li>STL-compliant OTL stream <a href="otl3_iterators.htm">iterators</a>
: <a href="otl3_input_iterator.htm">otl_input_iterator</a>, <a
 href="otl3_output_iterator.htm">otl_output_iterator</a>s.
The iterators
are supposed to work with all versions of the STL, which are
commercially
or freely available for a variety of C++ compilers. This feature can be
turned on with #define OTL_STL.</li>
          <br>
&nbsp;
          <li>ANSI C++ typecasts are supported. This feature can be
turned on with #define
OTL_ANSI_CPP.</li>
        </ol>
        </td>
        <td>
        <ol>
          <li>For more detail on std::string's, see also example <a
 href="otl3_ex72.htm">72</a>, <a href="otl3_ex73.htm">73</a>, <a
 href="otl3_ex74.htm">74</a></li>
          <br>
&nbsp;
          <li>For more detail on the OTL/STL iterators, see also
example <a href="otl3_ex75.htm">75</a>, <a href="otl3_ex76.htm">76</a>,
            <a href="otl3_ex77.htm">77</a></li>
          <br>
&nbsp;
          <li>For more detail on #define OTL_ANSI_CPP, see also example
            <a href="otl3_ex72.htm">72</a>, <a href="otl3_ex73.htm">73</a>,<a
 href="otl3_ex74.htm">74</a>, <a href="otl3_ex75.htm">75</a>, <a
 href="otl3_ex76.htm">76</a>, <a href="otl3_ex77.htm">77</a>.</li>
        </ol>
        </td>
      </tr>
    </tbody>
  </table>
</ul>
<center><a href="otl3_whatn_2.htm">Continued on page 2</a></center>
<ul>
  <center>
  <hr width="100%">
  <p><a href="home.htm">Go Home</a></p>
  </center>
  <p>Copyright &copy; 1996-2023, Sergei Kuchin, email: <a
 href="mailto:skuchin@gmail.com">skuchin@gmail.com</a>, <a
 href="mailto:skuchin@gmail.com">skuchin@gmail.com&nbsp;
  <script language="JavaScript"><!-- hide from old browsers


 var modDate = new Date(document.lastModified)


 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 


                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");


 //-->


 </script></a>.
  </p>
  <p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</i></p>
</ul>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
pageTracker._trackPageview();
</script>
</body>
</html>
