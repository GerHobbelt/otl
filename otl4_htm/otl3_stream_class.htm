<!DOCTYPE HTML PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=ISO-8859-1">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR"
 content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">
  <meta name="KeyWords"
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
  <title>OTL 4.0, OTL stream class</title>
</head>
<body>
<center>
<h1>OTL 4.0, OTL stream class</h1>
</center>
<h1>
<a name="otl_stream_class"></a>OTL stream class</h1>
The otl_strean class is the actual implementation the <a
 href="otl3_str.htm">OTL
stream concept</a>. Any SQL statement, anonymous PL/SQL block or stored
procedure with input and/or output parameters can be programmed in C++
with the otl_stream class.
<p>Traditionally, a database API has functions to bind host variables
with
placeholders in the SQL statement. So, the developer has to declare
host
arrays in the program, parse the statement, call the bind functions,
fill
out the input variables, execute the statement, read the output
variables,
etc. After the cycle is done, again, fill out the input variables,
execute
the statement, read the output. All that is done automatically in the
otl_stream
class. The class provides full automation of interaction with the
database
as well as performance. Performance is controlled by a single parameter
-- the stream&nbsp;<a name="buffer_size"></a><i>buffer size. </i>The
buffer size is defined in logical rows to be inserted into a table,
selected from a table / view in one round-trip to the database (a.k.a.
batch size, array size).<br>
</p>
<p><span style="font-style: italic;"><a name="STREAM_BUFFER_SIZE_0"></a>Note</span>:
the
stream buffer size can be set to 0 when #define <a
 href="otl3_compile.htm#OTL_TIMESTEN_UNIX">OTL_TIMESTEN_UNIX </a>/ <a
 href="otl3_compile.htm#OTL_TIMESTEN_WINDOWS">OTL_TIMESTEN_WINDOWS</a>
is used against TimesTen 7.0.2 or higher. The buffer size of 0 in this
context means that the default prefetch size would be used. The
stream's internal buffers become arrays of 1 element in this special
case. For more information on the TimesTen Prefeth read the
corresponding manual.<br>
</p>
<p>A SQL statement in the otl_stream needs to have at least one <a
 href="otl3_bind_variables.htm">placeholder
/ bind variable</a>. SQL statements without placeholders are referred
to
as <a href="otl3_const_sql.htm">constant SQL statements</a> and
processed
differently.<br>
</p>
<p>Starting with OTL 4.0.115 and on, the buffer size data type is <span
 style="font-style: italic;">int </span>(the old data type was <span
 style="font-style: italic;">short int</span>). If the old data type is
needed for backward compatibility, #define <a
 href="otl3_compile.htm#OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE">OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE</a>
has to be enabled.<br>
</p>
<p>
</p>
<p>The otl_stream class has the following public functions:<br>
</p>
<pre><font><font size="+2">class otl_stream{<br>public:</font></font></pre>
<p></p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-style: italic;">Function</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">Description</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> <span
 style="font-family: monospace;"> </span>
      <p><a name="otl_stream_otl_stream"></a><span
 style="font-family: monospace;"></span><br>
      <span style="font-family: monospace;">otl_stream(...);</span></p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int arr_size </td>
            <td style="vertical-align: top;">stream <a
 href="otl3_stream_class.htm#buffer_size">buffer size</a> </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm </td>
            <td style="vertical-align: top;">SQL statement or anonymous
PL/SQL block </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db </td>
            <td style="vertical-align: top;">OTL connect object </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a name="ref_cur"></a>const
char*
ref_cur_placeholder=0 </td>
            <td style="vertical-align: top;">If the stream returns a
referenced cursor, this parameter is used to specify the name of the
referenced cursor placeholder </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm_label=0
            </td>
            <td style="vertical-align: top;">SQL statement label. When
specified, it is used to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a>
with, so the actual text of the SQL statement will not be visible and
will be replaced with its label </td>
          </tr>
        </tbody>
      </table>
      <p><span style="font-family: monospace;"><br>
      </span></p>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">Oracle
7/8/9/10/11
only</span>. <br>
      <br>
General constructor. This constructor creates
an otl_stream
object and
then calls the <a href="#open">open</a>() function.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><br>
      <span style="font-family: monospace;">otl_stream(...);</span> </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int arr_size</td>
            <td style="vertical-align: top;">stream <a
 href="otl3_stream_class.htm#buffer_size">buffer size</a></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm</td>
            <td style="vertical-align: top;">SQL statement or stored
procedure call</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db</td>
            <td style="vertical-align: top;">OTL connect object</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int implicit_select =<br>
otl_explicit_select</td>
            <td style="vertical-align: top;">If the stream returns a
result set via a stored procedure call, this parameter needs to be set
to otl_implicit_select</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm_label=0</td>
            <td style="vertical-align: top;">SQL statement label. When
specified, it is used to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a>
with, so the actual text of the SQL statement will not be visible and
will be replaced with its label</td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">ODBC/DB2-CLI
only.</span><b><br>
      <br>
      </b>General constructor. This constructor creates an otl_stream
object, and then calls the <a href="#open">open</a>() function.<br>
      <br>
      <b> </b><big><a name="implicit_select"></a><font size="-1"><big>OTL
4.0/ODBC
and
OTL
4.0/DB2-CLI
define the following global constant to be used with this constructor:</big></font></big>
      <ul>
        <big> </big>
        <li><big> <font size="-1"><big><b>otl_explicit_select</b> --
to indicate
that if
the stream
is a SELECT statement then the statement is a simple SELECT.</big></font></big></li>
        <big> </big>
        <li><big> <font size="-1"><big><b>otl_implicit_select</b> --
to indicate
that
the stream
is a stored procedure call that returns a result set.</big></font></big></li>
        <big> </big>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="otl_stream_open"></a><span
 style="font-family: monospace;">void open(...);</span><br>
      </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int arr_size</td>
            <td style="vertical-align: top;">stream <a
 href="otl3_stream_class.htm#buffer_size">buffer size</a></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm,</td>
            <td style="vertical-align: top;">SQL statement or anonymous
PL/SQL block connect object</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db,</td>
            <td style="vertical-align: top;">OTL connect object<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* <br>
ref_cur_placeholder=0</td>
            <td style="vertical-align: top;">If the stream returns a
referenced cursor,this parameter is used to specify the name of the
referenced cursor placeholder.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* <br>
sqlstm_label=0</td>
            <td style="vertical-align: top;">SQL statement label. When
specified, it is used to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a>
with, so the actual text of the SQL statement will not be visible and
will be replaced with its label.</td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">Oracle
7/8/9/10/11
only</span><b><br>
      <br>
      </b><a name="open"></a>This function opens the SQL statement: the
statement
gets parsed, all input and output <a href="otl3_bind_variables.htm">variables</a>
get dynamically allocated inside the stream and automatically bound to
the placeholders. <br>
      <br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><span style="font-family: monospace;"><a
 name="otl_stream_open2"></a>void open(...);</span> </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int arr_size</td>
            <td style="vertical-align: top;">stream <a
 href="otl3_stream_class.htm#buffer_size">buffer size</a></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm</td>
            <td style="vertical-align: top;">SQL statement or stored
procedure call</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db</td>
            <td style="vertical-align: top;">OTL connect object</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int implicit_select=<br>
otl_explicit_select</td>
            <td style="vertical-align: top;">If the stream returns a
result set via a stored&nbsp; procedure call, this parameter needs to
be set to otl_implicit_select</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* sqlstm_label=0</td>
            <td style="vertical-align: top;">SQL statement label. When
specified, it is used to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a>
with, so the actual text of the SQL statement will not be visible and
will be replaced with its label.<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
      <td style="vertical-align: top;">
      <p style="font-style: italic;">ODBC/DB2-CLI only.<br>
      </p>
      <p>This function open an SQL statement and the statement<br>
gets parsed, all input and output <a href="otl3_bind_variables.htm">variables</a>
get dynamically allocated inside the stream and automatically bound to<br>
the placeholders. </p>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><span style="font-family: monospace;">int eof();</span><br>
      </p>
      </td>
      <td style="vertical-align: top;"><a name="eof"></a>Test if all
data has been already read from the
stream. This
function
has
the same meaning as the eof() funtion in C++ streams<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>int setBufSize(const int buf_size);</p>
      </td>
      <td style="vertical-align: top;"><a name="setBufSize"></a>Set the
stream buffer size. The only
thing that this function does is it saves a new buffer size for further
use with otl_connect::operator<a
 href="otl3_connect_class.htm#operator_gg">&gt;&gt;</a>(otl_stream&amp;).<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>void flush();</p>
      </td>
      <td style="vertical-align: top;"><a name="flush"></a>Flush the
stream output buffer. It actually
means to
execute the SQL statement in <a href="otl3_str.htm#bulk">bulk</a> as
many
times as rows entered into the stream output buffer. The stream is
automatically
flushed when the buffer gets full. This function has the same meaning
as
the flush() function in C++ streams. Also, if the stream <tt><i>auto-commi</i>t</tt>
flag is set then the stream, after flushing the output buffer, commits
the current transaction. For more detail, see the <a
 href="otl3_stream_class.htm#set_commit">set_commit</a>()
function.<br>
      <br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><span style="font-family: monospace;">void flush(...);</span> </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int row_offset=0</td>
            <td style="vertical-align: top;">Specify the first row in
the stream's buffer for flushing</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const bool
force_flush=false</td>
            <td style="vertical-align: top;">Force flushing regardless
of previous errors</td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">OTL/OCI8,8i,9i/10g/11g</span>
has a
version of the flush function with 2
parameters:
row_offset, force_flushing This version of the flush function makes the
process of, say, inserting a big batch of rows more efficient, after,
say,
duplicate rows were discovered in the batch, and an otl_exception was
raised.
For more detail, see OTL examples.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">int get_stream_type();</span><br>
      </td>
      <td style="vertical-align: top;"><a name="get_stream_type"></a><span
 style="font-style: italic;">OTL/OCI8/9/10/11
only</span>. Get the
OTL
stream
type.<br>
      <br>
      <p>The following global&nbsp; constants (int's) are defined: <br>
&nbsp; </p>
      <ul>
        <li> <a name="stream_types"></a><b><font size="-1">otl_no_stream_type</font></b>
-- stream is not instantiated with any SQL statement yet.<br>
          <br>
        </li>
        <li> <b><font size="-1">otl_select_stream_type</font></b> --
stream is
instantiated
with a straight SELECT statement.<br>
          <br>
        </li>
        <li> <b><font size="-1">otl_inout_stream_type</font></b> --
stream
is
instantiated
with an anonymous PL/SQL block which has input/output bind variables,
possibly,
parameters in a stored procedure call.<br>
          <br>
        </li>
        <li> <b><font size="-1">otl_refcur_stream_type</font></b> --
stream is
instantiated
with a PL/SQL block, which returns a reference cursor. In this type of
a PL/SQL block (possibly, a stored procedure call), only input bind
variables
are allowed. The output of the PL/SQL block is the reference cursor
itself.<br>
          <br>
        </li>
        <li> <b><font size="-1">otl_constant_sql_type</font></b> --
special
constant that
is only used in <tt><a
 href="otl3_stream_class.htm#create_stored_proc_call">create_stored_proc_call()</a></tt>,
and
not returned by <a href="otl3_stream_class.htm#get_stream_type">get_stream_type</a>().
However,
the
constant completes this logical group of constants, that represent
types of&nbsp; OTL streams. In the context of
create_stored_proc_call(),
this constant indicates a call to a stored procedure, which has no
parameters,
and it needs to be executed via <a href="otl3_const_sql.htm">otl_cursor::direct_exec</a>().<br>
          <br>
        </li>
        <li><span style="font-weight: bold;"><a
 name="otl_mixed_refcur_stream_type"></a>otl_mixed_refcur_stream_type</span>
-- special constant that is only used in <tt><a
 href="otl3_stream_class.htm#create_stored_proc_call">create_stored_proc_call()</a></tt>,
and
not returned by <a href="otl3_stream_class.htm#get_stream_type">get_stream_type</a>().
However,
the
constant completes this logical group of constants, that represent
types of&nbsp; OTL streams. In the context of
create_stored_proc_call(), this constant indicates a call to a stored
procedure, which has reference cursor(s) as well as scalar (input/)
output parameters (mixed reference cursor stream). If
create_stored_proc_call() returns this constant in its <span
 style="font-family: monospace;">stm_type</span> parameter, and when
create_stored_proc_call()'s <span style="font-family: monospace;">sql_stm</span>
parameter is instantiated, the corresponding otl_stream's buffer size
needs to be set to 1, and <a href="otl4_refcur_stream.htm">otl_refcur_stream</a>
should be used to fetch rows from the <a
 href="otl3_bind_variables.htm#refcur">refcur</a>
bind variables of the <span style="font-family: monospace;">sql_stm</span>'s
text.
Also,
otl_stream::<a href="otl3_stream_class.htm#describe_vars">describe_in_vars</a>()
and
otl_stream::<a href="otl3_stream_class.htm#describe_vars">describe_out_vars</a>()
should
be
used to describe the stream input and output variables in the case of
general-purpose C++ code to handle PL/SQL procedure calls that get
generated by the create_stored_proc_call() function. See example <a
 href="otl4_ex153.htm">153</a> for more
detai</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">static void
create_stored_proc_call(...);</span><br>
      <br>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">otl_connect&amp; db</td>
            <td style="vertical-align: top;">OTL connect object</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">otl_stream&amp; args_strm</td>
            <td style="vertical-align: top;">An instance of otl_stream
that is external to this function. In other
words, an otl_stream variable that needs to be defined externally. The
variable is used to instantiate the stream with "SELECT...FROM
ALL_ARGUMENTS...", in order for the function to be able to access the
Oracle system data dictionary. The stream gets instantiated once, and
can be reused in subsequent calls to the function, especially, in a
high volume environment.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">char* sql_stm</td>
            <td style="vertical-align: top;">output, otl_stream
compatible SQL statement, which has a call to the
stored procedure, with all of the stored proc's parameters expanded.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&amp; stm_type</td>
            <td style="vertical-align: top;">output, stream/statement <a
 href="otl3_stream_class.htm#stream_types">type</a></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">char* refcur_placeholder</td>
            <td style="vertical-align: top;">output, in case of a
stored procedure, returnig a reference cursor,
this parameter returns a "reference cursor placeholder" name, that can
be used in <a href="otl3_stream_class.htm#otl_stream_otl_stream">otl_stream::otl_stream()</a>,
or
in <a href="otl3_stream_class.htm#otl_stream_open">otl_stream::open()</a>
calls.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* proc_name</td>
            <td style="vertical-align: top;">stored procedure name.
this should a stored procedure from a PL/SQL package</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* package_name</td>
            <td style="vertical-align: top;">PL/SQL package name, which
the stored procedure belongs to</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const char* schema_name=0</td>
            <td style="vertical-align: top;">Oracle schema name, which
the stored procedure and/or the PL/SQL package belong to</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const bool
schema_name_included=false</td>
            <td style="vertical-align: top;">indicator of whether the
call to the stored procedure needs to be prefixed with the schema name
or not</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int varchar_size=2001</td>
            <td style="vertical-align: top;">VARCHAR parameters in
stored procedure don't have any sizes. This
parameter defines what size needs to be used in the definitions of
:var&lt;char[XXX]&gt; bind variables<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int all_num2type=<a
 href="otl3_stream_class.htm#otl_var_double">otl_var_double</a></td>
            <td style="vertical-align: top;">This parameter defines how
NUMBER parameters of the stored procedure
will mapped to the corresponding bind variable definitions.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">const int refcur_buf_size=1</td>
            <td style="vertical-align: top;">If the stored procedure
call contains reference cursors, this parameter
can be used to specify the buffer size of the reference cursors,for
example: f4&lt;<a href="otl3_bind_variables.htm#refcur">refcur</a>,out[100]&gt;.
This
can be important for performance.</td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
      <td style="vertical-align: top;">
      <p><a name="create_stored_proc_call"></a><span
 style="font-style: italic;">OTL/OCI8/9/10//11
only</span>.
Not implemented under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>.
Creates
an
otl_stream
compatible
call (string) to a stored procedure by the stored procedure
name. This function is static in class and intended for some automation
in generating Oracle 8/8i/9i/10g/11g stored procedure calls. The
function
uses
Oracle system data dictionary directly (ALL_ARGUMENTS system view), in
order to retrieve information about stored procedure's parameters, and
their data types. Potentially, the function may raise the <a
 href="otl3_exc_list.htm">OTL
defined exceptions</a> with the following error codes: <a
 href="otl3_exc_list.htm#32014">32014</a>, <a
 href="otl3_exc_list.htm#32015">32015</a>, <a
 href="otl3_exc_list.htm#32016">32016</a>.&nbsp; <br>
      </p>
      <p><a name="create_stored_proc_call_types"></a>The function is
able to handle the following types of stored
procedures/functions: <br>
      <br>
      </p>
      <ul>
        <li>stored procedures / functions from PL/SQL packages from
the
current / specified schema, or global procedures / functions from the
current / specified schema.<br>
          <br>
        </li>
        <li>stored procedures / functions from PL/SQL packages
available
via private / public synonyms, or global procedures / functions
available via private / public synonyms.<br>
          <br>
        </li>
        <li> procedures / functions, whose names are not overloaded.</li>
        <li>
          <p>procedures / functions, with scalar input and/or output
parameters, and maybe with output reference cursor(s).</p>
        </li>
      </ul>
      <ul>
        <p> </p>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">void clean(const int
clean_up_error_flag=0);</span><br>
      </td>
      <td style="vertical-align: top;"><a name="clean"></a>Clean up the
stream output
buffer without <a href="otl3_stream_class.htm#flush">flushing</a>
it. The <i>clean_up_error_flag </i>parameter, if set to 1, cleans up
the
otl_stream's internal error flag that usually gets set when the stream
throws an <a href="otl3_exception_class.htm">otl_exception</a>.See
examples <a href="otl3_ex65.htm">65</a>, <a href="otl3_ex66.htm">66</a>,

      <a href="otl3_ex67.htm">67</a>
for more detail on this parameter. The main purpose for introducing
this
parameter was to provide the stream a capability to recover from
a database
error without closing out the stream.<br>
      <br>
In OTL 4.0.6, and later, the function is extended to work with
SELECT
statements, explicit (Oracle reference cursors) and implicit (in DB2,
MS
SQL Server, or Sybase stored procedures) result sets. An unfinished
fetch
sequence can be canceled by calling the function. Also, the function
cleans
up the error flags, that get set inside the stream, in the case of,
say,
a database error.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>void rewind();</p>
      </td>
      <td style="vertical-align: top;">Rewind the stream. If the stream
does not have any input
variables,
this
function forces the stream to execute its SQL statement.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="operator_int"></a><span
 style="font-family: monospace;">operator int();</span></p>
      </td>
      <td style="vertical-align: top;">OTL-stream-to-int conversion
operator It returns the !eof()
status of
the
stream. It allows the operators <a href="#operator_gg">&gt;&gt;</a> to
return
the !EOF status of the stream, and to be used in a while() loop as
follows:<br>
      <br>
      <tt><font size="-1">&nbsp;while(s&gt;&gt;f1&gt;&gt;f2){</font></tt>
      <br>
      <tt><font size="-1">&nbsp; &nbsp;
cout&lt;&lt;"f1="&lt;&lt;f1<br>
&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &lt;&lt;", f2="<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &lt;&lt;f2&lt;&lt;endl;</font></tt> <br>
&nbsp; <tt><font size="-1">}</font></tt>
      <pre><br></pre>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="cancel"></a><span style="font-family: monospace;">void
cancel();</span></p>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">OTL/ODBC,
OTL/DB2-CLI
only</span>. If
the stream has a running SELECT
statement,
or a call to a stored procedure that returns a result set, in one
worker
thread (not the main thread), then the statement can be asynchronously
canceled, by calling this function from another worker thread. The
actual
cancellation of the statement depends on how the SQLCancel() call
(ODBC,
or DB2-CLI) was implemented in the underlying database API. Also, the
error
code, that otl_exception gets initialized with, depends on the
underlying
database API. In some cases, the error code is 0, but an otl_exception
gets thrown, right after the SQLCancel call returns.<br>
      <br>
OTL/OCI8,8i,9i,10g have a similar function but at the level of
otl_connect: <a href="otl3_connect_class.htm#cancel">cancel</a>().
OCI
and
ODBC/DB2-CLI
are different in that regard.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">bool <a name="get_next_diag_rec"></a>get_next_diag_rec(...);<br>
      </span>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Parameter</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">short int&amp; rec_ndx<br>
            </td>
            <td style="vertical-align: top;">Diagnostic record index<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">SQLCHAR* sqlstate_buf<br>
            </td>
            <td style="vertical-align: top;">SQL State buffer. When
Unicode is enabled, the type is SQLWCHAR*<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">SQLCHAR* msg_buf<br>
            </td>
            <td style="vertical-align: top;">Message buffer. When
Unicode is enabled, the type is SQLWCHAR*</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">short int msg_buf_size<br>
            </td>
            <td style="vertical-align: top;">Message buffer size<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&amp; native_error<br>
            </td>
            <td style="vertical-align: top;">Native error<br>
            </td>
          </tr>
        </tbody>
      </table>
      <span style="font-family: monospace;"><br>
      </span></td>
      <td style="vertical-align: top;"><span style="font-style: italic;">OTL/ODBC
only</span>. Under #define <a href="otl3_compile.htm">OTL_ODBC_SQL_STATEMENT_WITH_DIAG_REC_OUTPUT.</a><br>
      <br>
This function should&nbsp; be used to get diagnostic records from such
MS SQL Server commands as BACKUP, DBCC, etc. The function calls
SQLGetDiagRec() inside.. The record index needs to be started with 1.
The function increments the record index (rec_ndx++). For more detail,
see also examples <a href="otl4_ex688.htm">688</a>, <a
 href="otl4_ex689.htm">689</a>. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">SQLHSTMT <a name="get_stm_handle"></a>get_stm_handle();</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">OTL/ODBC
only</span>. Under #define <a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm">OTL_ODBC_SQL_STATEMENT_WITH_DIAG_REC_OUTPUT.</a><br>
      <br>
This function should&nbsp; be used to get the underlying ODBC statement
handle, when, say, calls to SQLMoreResults() need to be made in order
to get all output diagnostic records for a BACKUP command.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a style="font-family: monospace;" name="is_null"></a><span
 style="font-family: monospace;">int is_null();</span><br>
      <br>
      </p>
      </td>
      <td style="vertical-align: top;">Test if NULL was fetched from
the stream.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><a name="set_lob_stream_mode"></a>void
set_lob_stream_mode<br>
(const bool mode=false);</p>
      </td>
      <td style="vertical-align: top;">Set the <a
 href="otl3_lob_stream.htm">LOB stream
mode</a>. This
function
sets the "lob stream mode" flag in the otl_stream, that is, this tells
the otl_stream that <a href="otl3_lob_stream.htm">otl_lob_stream</a>
operations
will be used. It is not required that this function be used in case of
OTL/OCI8. For OTL/ODBC and OTL/DB2-CLI, or when the <a
 href="otl4_stream_read_iterator.htm">otl_stream_read_iterator</a>
is
used, it is required. However, for
writing
portable [across multiple database] code, the function should be called.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><a name="get_rpc"></a>long get_rpc();</p>
      </td>
      <td style="vertical-align: top;">Get the <i>ROWS PROCESSED COUNT
      </i>(RPC). The count is defined
for
INSERT,
UPDATE, DELETE statements, and it shows how rows have been processed in
the last execution of the statement. For INSERT statements, it may be
less
or equal to the stream <a href="otl3_stream_class.htm#buffer_size">buffer
size</a>.For
DELETE
or UPDATE statements, it may be anything, depending upon what how may
rows
are being updated or deleted.<br>
      <br>
In OTL 4.0.6 and higher, the function was extended to return an
accumulative
rows processed count for SELECT statements (all databases), reference
cursors
(Oracle), stored procedures that return implicit result sets.<br>
      <br>
There is a substantial difference in the way the get_rpc()
function works in Oracle and ODBC, or DB2-CLI, in the case of an error,
when the underlying INSERT/UPDATE/DELETE statement errored out with an
otl_exception. In Oracle, in case of error, get_rpc() returns a number
of successfully processed rows, so it's easy to calculate which row
caused
the error. In ODBC, or DB2-CLI, the behavior of the SQLGetRowCount()
function
is undefined, so get_rpc() always returns 0. <br>
      <p><i>Conclusion: </i>for portable, muti-database OTL based
code,
it's
not recommended to use the database specific behavior of the get_rpc()
function. For Oracle OTL based code, it's okay to use it, since this
kind
of behavior is consistent with all versions of Oracle, that are
supported
by OTL.</p>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>void set_commit(int auto_commit=0);</p>
      </td>
      <td style="vertical-align: top;"><a name="set_commit"></a>Set the
stream <i>auto-commit</i>
flag.
When the
output buffer is <a href="otl3_stream_class.htm#flush">flushed</a>,
the current transaction
is automatically commited, if the flag is set. By default, the flag is
set. In order to prevent the current transaction from
"auto-committing",
unset the flag using this function. The stream auto-commit flag has
nothing
to do with the database auto-commit mode. The auto-commit is specific
to
the otl_stream class.<br>
      <br>
      <p><a name="nocommit"></a>If it is more convenient to have the
stream
"auto-commit
off" by default, then the <font size="+1">otl_nocommit_stream </font>can
be
used. otl_nocommit_stream is a class derived directly from
otl_stream
with <i>auto-commit</i> turned off by default, so it does not commit
transactions. </p>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>void set_flush(const bool auto_flush=true);</p>
      </td>
      <td style="vertical-align: top;"><a name="set_flush"></a>Set the
stream's <i>auto-flush</i>
flag.
Default
value is <i>true</i>. By default, the stream's destructor tries to
flush
the buffer, if the buffer is <i>dirty</i>. It is called <i>auto-flushing</i>.
The
auto-flushing can be turned off or on explicitly with the help of
the
set_flush() function (see below). If the auto-flush flag was turned
off,
the stream's buffer needs to be flushed either by calling the
otl_stream::close()
function or the otl_stream::flush() function, because the destructor
would
not flush even if the <i>dirty </i>flag is true. This function could
be
especially useful, when OTL is used in the environment with exceptions
get thrown left and right, to prevent the otl_stream's destructor from
auto-flushing the buffer in the stack unwinding.<br>
      <br>
This function disables ONLY auto-flushing in the otl_stream
destructor,
not the buffer flushing in general. When the stream buffer gets full,
it
gets flushed automatically REGARDLESS. If set_flush(false) call was
made,
it disables the automatic buffer flushing ONLY in the DESTRUCTOR, in
order
to prevent potential cascading otl_exception's.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="describe_out_vars"></a><a
 style="font-family: monospace;"
 href="otl3_stream_class.htm#otl_var_desc">otl_var_desc</a><span
 style="font-family: monospace;">*
describe_out_vars<br>
(int&amp; desc_len); &nbsp;</span></p>
      </td>
      <td style="vertical-align: top;"><a name="describe_vars"></a>A
group of functions for describing
otl_stream's
bind variables, both <i>input</i> and <i>output</i>. The functions
return
a pointer to the otl_var_desc structure:<br>
      <br>
      <p><a name="otl_var_desc"></a>class otl_var_desc{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public: </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Data member</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; param_type; </td>
            <td style="vertical-align: top;">0 - IN variable, 1 - OUT
variable, 2 - INOUT variable </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; ftype; </td>
            <td style="vertical-align: top;">see the <a
 href="otl3_stream_class.htm#otl_var_dbtype">OTL
codes for mapped datatypes</a> </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp;
elem_size; </td>
            <td style="vertical-align: top;">[array] element size in
bytes. </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; array_size; </td>
            <td style="vertical-align: top;">array size, in case if the
variable is scalar, the size is equal to 1 </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp;
pos; </td>
            <td style="vertical-align: top;">In SELECT statements,
pos shows a relative position of the output column: 1,2,3,... </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp;
name_pos;</td>
            <td style="vertical-align: top;">In case if the variable is
defined via the
placeholder notation (:var&lt;...&gt;), name_pos shows a relative
position of the variable in the array of variables: 0,1,2,...<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">char name[128];</td>
            <td style="vertical-align: top;">First 127 bytes of the
variable name, in case if the variable was defined as a placeholder.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; pl_tab_flag;</td>
            <td style="vertical-align: top;">In OTL/OCIx, this field is
equal to 1 in case if the variable is defined as a PL/SQL table, 0 -
otherwise.<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
};<br>
      <br>
      <br>
&nbsp;Describe OUT variables. <i>desc_len</i> returns
the size
of the
array
of otl_var_desc structures. The function returns a pointer to the array
of OUT variable descriptors. In case if the SQL statement does not
contain
any output variables, the functions returns 0. If a variable was
declared
as INOUT, it is presented as part of the array of the variable
descriptors,
returned by this function.<br>
      <br>
OUT variables are the variables that get read FROM the
stream.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><a name="describe_in_vars"></a><a
 href="otl3_stream_class.htm#otl_var_desc">otl_var_desc</a>*
describe_in_vars<br>
(int&amp; desc_len);</p>
      </td>
      <td style="vertical-align: top;">Describe IN variables. <i>desc_len</i>
returns the
size
of the
array
of otl_var_desc structures. The function returns a pointer to the array
of IN variable descriptors. In case if the SQL statement does not
contain
any input variables, the functions returns 0. If a variable was
declared
as INOUT, it is presented as part of the array of the variable
descriptors,
returned by this function.<br>
      <br>
IN variables are the variables that get written TO the stream.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p style="font-family: monospace;"><a name="describe_next_out_var"></a><a
 href="otl3_stream_class.htm#otl_var_desc">otl_var_desc</a>*
describe_next_out_var();</p>
      <br>
      </td>
      <td style="vertical-align: top;">Describe <i>next</i> output
variable. Next means
"next
to be
read
from the stream." That is, before calling one of
otl_stream::operator&lt;&lt;(),
sometimes it is necessary to know what is the type of the next variable
to be read. In case if the stream does not have any output variables,
the
function returns 0.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="describe_next_in_var"></a><a
 style="font-family: monospace;"
 href="otl3_stream_class.htm#otl_var_desc">otl_var_desc</a><span
 style="font-family: monospace;">*
describe_next_in_var();</span></p>
      <br>
      </td>
      <td style="vertical-align: top;">Describe <i>next</i> input
variable. Next means
"next to
be
written
to the stream." That is, before calling one of
otl_stream::operator&gt;&gt;(),
sometimes it is necessary to know what is the type of the next variable
to be written. In case if the stream does not have any input variables,
the function returns 0.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><i>(1)</i> void close();</p>
      </td>
      <td style="vertical-align: top;"><a name="close"></a>Close the
stream. This function has the
same
meaning
as the close() function in C++ streams. The close() function has two
implementations:
the ordinary one <i>(1)</i>, and the extended one <i>(2)</i>, under
#define <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>.<br>
      <br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><i style="font-family: monospace;">(2)</i><span
 style="font-family: monospace;"> void close<br>
(const bool
save_in_stream_pool=true);</span><br>
      <br>
      </p>
      <pre></pre>
      <br>
      </td>
      <td style="vertical-align: top;"><i><span
 style="font-style: italic;"></span></i>Under #define <a
 href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a><i><br>
      <br>
save_in_<a href="otl3_stream_pooling.htm">stream_pool</a></i>
is
an initialized parameter in the function. When it's set to <i>true</i>,
and
if #define OTL_STREAM_POOLING_ON is on, the stream doesn't really
get
closed. The stream gets saved to the pool of unused OTL streams, which
can be reused later, when a similar stream (SQL statement + buffer
size)
gets opened again. The maximum size of the OTL stream pool can be set
by
otl_connect::<a href="otl3_connect_class.htm#set_stream_pool_size">set_stream_pool_size</a>().<br>
      <br>
When the save_in_stream_pool parameter is set to <i>false</i>,
the stream
DOES get closed, and doesn't get saved in any stream pool. This setting
of the parameter can be used to override the default behavior of the
otl_stream
under #define OTL_STREAM_POOLING_ON. For example, a stream with huge
SQL
statement and big buffers, which would be are a drag of the system
resources,
and would need to be deallocated as soon as the use of the stream is
finished.<br>
      <br>
For more detail, see examples <a href="otl3_ex113.htm">113</a>, <a
 href="otl3_ex114.htm">114</a>, <a href="otl3_ex115.htm">115</a><br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>int good();</p>
      </td>
      <td style="vertical-align: top;"><a name="good"></a>Test if the
stream is open. This function has
the same meaning as
the
good()
function in C++ streams.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><a name="describe_select"></a><a
 href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>*
describe_select<br>
(int&amp; <a name="describe_select_desc_len"></a>desc_len);</p>
      </td>
      <td style="vertical-align: top;"><a name="describe_select"></a>Describe
the
output column list
in:<br>
      <ul>
        <li>straight SELECT statement (OCIx, ODBC, and DB2-CLI)</li>
        <li>Referenced cursor (OCIx)</li>
        <li>Result set returned via a stored procedure call (ODBC for
MS
SQL Server
and Sybase, DB2-CLI for DB2)</li>
      </ul>
This function returns a pointer of the <a
 href="otl3_stream_class.htm#otl_column_desc">otl_column_desc</a>
type to the descriptor of the output column list:
      <p><a name="otl_column_desc"></a>class
otl_column_desc{<br>
&nbsp;&nbsp;&nbsp;&nbsp; public:<br>
      </p>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;"><span style="font-style: italic;">Data
member</span></span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">char* name;</td>
            <td style="vertical-align: top;">column name</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; dbtype; </td>
            <td style="vertical-align: top;">database
dependent, column data type code for more detail, see the OCIx and the
ODBC manuals.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; otl_var_dbtype;</td>
            <td style="vertical-align: top;">OTL
defined, column data type code</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; dbsize;</td>
            <td style="vertical-align: top;">column length</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; scale;</td>
            <td style="vertical-align: top;">for numeric
columns, column scale</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; prec;</td>
            <td style="vertical-align: top;">for numeric
columns, column precision</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int&nbsp; nullok;</td>
            <td style="vertical-align: top;">indicator
whether column is nullable or not</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int charset_form; </td>
            <td style="vertical-align: top;"><a name="charset_form"></a>under
#define
            <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
and #define <a href="otl3_compile.htm#OTLORA9I">OTL_ORA9I</a>
/ <a href="otl3_compile.htm#OTL_ORA10G">OTL_ORA10G<br>
            </a><br>
SQLCS_IMPLICIT (1) for on-byte character sets, SQLCS_NCHAR (2) for NLS
multi-byte character sets; 0 otherwise.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int char_size;</td>
            <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
and #define <a href="otl3_compile.htm#OTLORA9I">OTL_ORA9I</a>
/ <a href="otl3_compile.htm#OTL_ORA10G">OTL_ORA10G</a><br>
            <br>
column size in characters, not in bytes this column size is set to 0
for <a href="otl3_compile.htm#OTL_ORA8I">OTL_ORA8I</a>, because the
corresponding attribute is not available in OCI8i<br>
            </td>
          </tr>
        </tbody>
      </table>
      <p>};</p>
      <a name="otl_var_dbtype"></a><font size="-1">OTL 4.0 defines the
following
data types, which the native database data types </font><font size="-1">are
mapped
      </font><font size="-1">to:<br>
      <br>
      </font>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">OTL defined integer
constant</span></td>
            <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">Integer code</span></td>
            <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">Explanation</span></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_bigint

            <br>
            </b></font></td>
            <td style="vertical-align: top;">20<br>
            </td>
            <td style="vertical-align: top;">MS SQL
Server, DB2, MySQL, PostgreSQL, etc. BIGINT (signed 64-bit integer) type</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_blob</b></font></td>
            <td style="vertical-align: top;">12<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">data type
that is
mapped
into BLOB
in Oracle 8/9/10/11</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_char</b></font></td>
            <td style="vertical-align: top;">1<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">null
terminated
string</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_clob

            <br>
            </b></font></td>
            <td style="vertical-align: top;">11<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">data type
that is
mapped
into CLOB
in Oracle 8/9/10/11</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_db2date

            <br>
            </b></font></td>
            <td style="vertical-align: top;">17<br>
            </td>
            <td style="vertical-align: top;">DB2 DATE data type<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_db2time</b></font></td>
            <td style="vertical-align: top;">16<br>
            </td>
            <td style="vertical-align: top;">DB2 TIME data type<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><a name="otl_var_double"></a><font
 size="-1"><b>otl_var_double</b></font></td>
            <td style="vertical-align: top;">2<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">8-byte
floating point number</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_float</b></font></td>
            <td style="vertical-align: top;">3<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">4-byte
floating
point
number</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_int</b></font></td>
            <td style="vertical-align: top;">4<br>
            </td>
            <td style="vertical-align: top;">signed <font size="-1">32-bit&nbsp;
integer</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_long_int</b></font></td>
            <td style="vertical-align: top;">7<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">signed
32-bit integer (for 32-bit, and LLP64 C++ compilers), signed 64-bit
integer (for LP-64 C++ compilers)</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_ltz_timestamp

            <br>
            </b></font></td>
            <td style="vertical-align: top;">19<br>
            </td>
            <td style="vertical-align: top;">Oracle
9i/10g/11g TIMESTAMP WITH LOCAL TIME ZONE type</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-weight: bold;"><a name="otl_var_raw"></a>otl_var_raw</span></td>
            <td style="vertical-align: top;">23<br>
            </td>
            <td style="vertical-align: top;">RAW, BINARY, VARBINARY,
BYTEA,
VARCHAR BYTE, CHAR BYTE, etc.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_raw_long</b></font></td>
            <td style="vertical-align: top;">10<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">data type
that is
mapped into LONG
RAW in Oracle, IMAGE in MS SQL Server and Sybase, BLOB in DB2</font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_short</b></font></td>
            <td style="vertical-align: top;">6<br>
            </td>
            <td style="vertical-align: top;">signed 16-bit integer<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_timestamp</b></font></td>
            <td style="vertical-align: top;">8<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">data type
that is
mapped into Oracle date/timestamp, DB2 timestamp, MS SQL
datetime/datetime2/time/date, Sybase timestamp, etc.<br>
            </font></td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_tz_timestamp</b></font></td>
            <td style="vertical-align: top;">18<br>
            </td>
            <td style="vertical-align: top;">Oracle timestamp with
timezone type<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_unsigned_int</b></font></td>
            <td style="vertical-align: top;">5<br>
            </td>
            <td style="vertical-align: top;">unsigned 32-bit integer<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><font size="-1"><b>otl_var_varchar_long</b></font></td>
            <td style="vertical-align: top;">9<br>
            </td>
            <td style="vertical-align: top;"><font size="-1">data type
that
is
mapped into
LONG in Oracle 7/8/9/10/11, TEXT in MS SQL Server and Sybase, CLOB in
DB2</font></td>
          </tr>
        </tbody>
      </table>
      <font size="-1"><br>
      </font>Besides the pointer to be returned, the function has an
output
parameter: <i><a href="#describe_select_desc_len">desc_len</a>. </i>The
length
of the output column list is
returned
via this
parameter. The pointer points to an internal structure inside the
stream
which gets deallocated at the moment of the stream destruction, so the
user does not need to do any memory deallocation operations with the
pointer.<br>
      <font size="-1"> </font> </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="reset_to_last_valid_row"></a><span
 style="font-family: monospace;">void reset_to_last_valid_row();</span><br>
      </td>
      <td style="vertical-align: top;">When OTL throws <span
 style="font-family: monospace;"><span style="font-family: monospace;"></span></span>"<a
 href="otl3_exc_list.htm#32000">Incompatible data types in stream
operation</a>" exception, the exception is contained to the OTL code
itself. The exception gets thrown before the underlying
INSERT/UPDATE/DELETE statement is executed. reset_to_last_valid_row()
can be called to reset the stream's output buffer to the last valid
state / row. After the stream's state is reset, otl_stream::flush() can
be safely called, for example:<br>
      <br>
      <span style="font-family: monospace;"><small>&nbsp;&nbsp;
otl_stream str<br>
&nbsp;&nbsp; (100,<br>
&nbsp;&nbsp;&nbsp; "INSERT INTO test_tab
VALUES(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)",<br>
&nbsp;&nbsp; db);<br>
&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; try{<br>
&nbsp;&nbsp;&nbsp;&nbsp; // writing rows into the stream<br>
&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; }catch(const otl_exception&amp; ex){<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ex.code==32000){<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str.reset_to_last_valid_row();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str.flush();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; }</small><br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p><a name="unicode_unsigned_read"></a>otl_stream&amp;
operator&gt;&gt;(unsigned char* s);</p>
      </td>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;"><a name="operator_gg"></a></span>Read
objects from the stream.<br>
      <br>
under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
      <br>
returns a null terminated array of unsigned short's (double-byte
Unicode characters). Therefore, "unsigned char*" needs to be type cast
to "unsigned short*". Also, it's recommended to allocate 2 bytes per
each Unicode character. For Oracle Unicode, add extra 2 bytes per
possible surrogate character.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&gt;&gt;(</span><a style="font-family: monospace;"
 href="otl3_long_string.htm#otl_long_unicode_string">otl_long_unicode_string</a><span
 style="font-family: monospace;">&amp;
s);</span> </td>
      <td style="vertical-align: top;">
      <p>under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a></p>
      <p>reads the Unicode LOB from the stream.</p>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><a name="unicode_gg"></a><span style="font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(OTL_UNICODE_CHAR_TYPE&amp;
c);</span><br>
      </p>
      </td>
      <td style="vertical-align: top;">
      <p>under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a></p>
reads a Unicode character. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <p><span style="font-family: monospace;">otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&gt;&gt;(OTL_UNICODE_CHAR_TYPE*
s);
      </span><br>
      </p>
      </td>
      <td style="vertical-align: top;">
      <p>under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a></p>
reads a Unicode string<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><a
 name="unicode_string_gg"></a>otl_stream&amp;
operator&gt;&gt;(OTL_UNICODE_STRING_TYPE&amp; s);</td>
      <td style="vertical-align: top;">
      <p>under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a></p>
reads Unicode string into a string class variable. VARCHAR/CHAR can
be&nbsp;
read as well as Large Text Objects (NTEXT, CLOB, NCLOB, etc.)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;"> otl_stream&amp;
operator&gt;&gt;(char&amp; c); </span><br>
      </td>
      <td style="vertical-align: top;">reads a single one-byte character<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(unsigned char&amp; c); </span><br>
      </td>
      <td style="vertical-align: top;">reads a single one-byte unsigned
character<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(char* s); </span><br>
      </td>
      <td style="vertical-align: top;">reads a string of one-byte
characters<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(unsigned char* s); </span><br>
      </td>
      <td style="vertical-align: top;">reads a string of one-byte
unsigned characters<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="long_string_read"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&gt;&gt;(</span><a style="font-family: monospace;"
 href="otl3_long_string.htm">otl_long_string</a><span
 style="font-family: monospace;">&amp;
s); </span><br>
      </td>
      <td style="vertical-align: top;">reads a LOB from the stream</td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><a
 name="stl_string_read"></a>otl_stream&amp;
operator&gt;&gt;(std::string&amp; s);</td>
      <td style="vertical-align: top;">reads the ANSI C++ std::string
(under #define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(ACE_TString&amp;
s);</td>
      <td style="vertical-align: top;">reads the ACE_TString (under
#define <a href="otl3_compile.htm#OTL_ACE">OTL_ACE</a>)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(<a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">USER_DEFINED_STRING_CLASS</a>
&amp; s);</td>
      <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">USER_DEFINED_STRING_CLASS</a><br>
under #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">OTL_USER_DEFINED_CLASS_ON</a><br>
      <br>
reads a string class (std::string compliant). <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(int&amp;
n);</td>
      <td style="vertical-align: top;">reads a signed 32-bit integer<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(unsigned&amp;
u);</td>
      <td style="vertical-align: top;">reads an unsigned 32-bit integer<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(short&amp;
sh);</td>
      <td style="vertical-align: top;">reads a signed 16-bit integer<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(long
int&amp; l);</td>
      <td style="vertical-align: top;">reads a signed long integer (32,
or 64-bit, depending on whether it's a 32-bit, LLP64 or LP64 platform)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(float&amp;
f);</td>
      <td style="vertical-align: top;">reads a 4-byte floating point
value<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(double&amp;
d);</td>
      <td style="vertical-align: top;">reads an 8-byte floating point
value<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><a
 name="64_bit_integer_write"></a>otl_stream&amp;
operator&gt;&gt;(<a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>&amp;
d);</td>
      <td style="vertical-align: top;">
      <p><span style="text-decoration: underline;"></span> when #define
      <a href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> is enabled.
For ODBC drivers that do not support bigint binding of host variables
natively, this operator can convert a numeric string value to a bigint
numeric value. That is, when a numeric value is returned from the SQL
statement as a string, this operator will convert the string to a
signed 64-bit integer in C++, when #define&nbsp; <a
 href="otl3_compile.htm#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>, and
and #define <a href="otl3_compile.htm#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>
are defined.<span style="text-decoration: underline;"></span></p>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(<a href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>&amp;
dt);</td>
      <td style="vertical-align: top;">reads date/time info from the
stream</td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&gt;&gt;(<a href="otl3_pl_tab.htm">otl_XXX_tab</a>&lt;&#8230;&gt;&amp;
tab);</td>
      <td style="vertical-align: top;">reads PL/SQL tables from the
stream (OCIx)</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="stream_read_lob"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&gt;&gt;(</span><a style="font-family: monospace;"
 href="otl3_lob_stream.htm">otl_lob_stream</a><span
 style="font-family: monospace;">&amp;
lob); </span><br>
      </td>
      <td style="vertical-align: top;">reads reference to
CLOB/BLOB/TEXT/IMAGE from otl_stream into otl_lob_stream. In other
words, initializes otl_lob_stream for reading
CLOB/BLOB/TEXT/IMAGE&nbsp; in stream mode.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><a
 name="stream_read_refcur"></a>otl_stream&amp; <br>
operator&gt;&gt;(<a href="otl4_refcur_stream.htm">otl_refcur_stream</a>&amp;
refcur);</td>
      <td style="vertical-align: top;">reads a reference cursor
descriptor to a variable of&nbsp; the <a href="otl4_refcur_stream.htm">otl_refcur_stream</a>
type. That is, initializes otl_refcur_stream for reading rows from the
reference cursor.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;"><a
 name="unicode_unsigned_char_write"></a>otl_stream&amp; <br>
operator&lt;&lt;(const unsigned char* s);</td>
      <td style="vertical-align: top;"><a name="operator_ll"></a>Write
objects into the stream<br>
      <br>
under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
      <br>
writes a null terminated array of unsigned short's (double-byte Unicode
characters) into the stream . Therefore, "unsigned short*"&nbsp; needs
to be
type cast to "unsigned char*". Also, it's recommended to allocate 2
bytes per each Unicode character. For Oracle Unicode,&nbsp; add extra 2
bytes per possible surrogate character.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">&nbsp;otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&lt;&lt;(</span><a
 style="font-family: monospace;"
 href="otl3_long_string.htm#otl_long_unicode_string">otl_long_unicode_string</a><span
 style="font-family: monospace;">&amp;
s);</span><br>
      </td>
      <td style="vertical-align: top;">writes a Unicode LOB to the
stream</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&lt;&lt;(const
OTL_UNICODE_CHAR_TYPE&amp; c); </span><br>
      <br>
      </td>
      <td style="vertical-align: top;"><a name="under_define"></a>under
#define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a><br>
      <br>
Writes a Unicode character<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&lt;&lt;(const
OTL_UNICODE_CHAR_TYPE* s);</span> </td>
      <td style="vertical-align: top;">Writes Unicode string </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&gt;&gt;<br>
(const OTL_UNICODE_STRING_TYPE&amp; s);</span> </td>
      <td style="vertical-align: top;"><a name="unicode_string_ll"></a>under
#define
      <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a><br>
under
#define <a href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a><br>
under #define <a href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a><br>
      <br>
Writes Unicode string from a string class variable into the stream.
[N]VARCHAR/[N]CHAR can be written as well&nbsp; as Large Text Objects
(NTEXT,
CLOB, NCLOB, etc.)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const char c);</span> </td>
      <td style="vertical-align: top;">Writes a single character into
the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const
unsigned char c);</span> </td>
      <td style="vertical-align: top;">Writes a single unsigned
character into the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const char*
s);</span> </td>
      <td style="vertical-align: top;">Writes a null terminated string
of characters into the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const
unsigned char* s);</span> </td>
      <td style="vertical-align: top;">Writes a null terminated string
of unsigned characters into the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="long_string_write"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const </span><a style="font-family: monospace;"
 href="otl3_long_string.htm">otl_long_string</a><span
 style="font-family: monospace;">&amp;
d);</span> </td>
      <td style="vertical-align: top;">Writes the LOB into the stream </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="stl_string_write"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const std::string&amp; s);&nbsp;</span> </td>
      <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_STL">OTL_STL</a><br>
      <br>
Writes the ANSI C++
std::string. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const ACE_TString &amp;s);&nbsp;</span> </td>
      <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_ACE">OTL_ACE</a><br>
      <br>
Writes an ACE_TString value<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp;
operator&lt;&lt;<br>
(const </span><a style="font-family: monospace;"
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">USER_DEFINED_STRING_CLASS</a><span
 style="font-family: monospace;">
&amp;s); </span><br>
      </td>
      <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">USER_DEFINED_STRING_CLASS</a><br>
under #define <a
 href="otl3_compile.htm#OTL_USER_DEFINED_STRING_CLASS_ON">OTL_USER_DEFINED_CLASS_ON</a><br>
      <br>
Writes a USER_DEFINE_STRING_CLASS value<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
int n);</td>
      <td style="vertical-align: top;">Writes an signed int into the
stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
unsigned
u);</td>
      <td style="vertical-align: top;">Writes an unsigned int int the
stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
short
sh);</td>
      <td style="vertical-align: top;">Writes a short int into the
stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
long
int l);</td>
      <td style="vertical-align: top;">Writes a signed long int into
the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
float
f);</td>
      <td style="vertical-align: top;">Writes a float into the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
double
d);</td>
      <td style="vertical-align: top;">Writes a double into the stream<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="64_bit_integer_read"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const </span><a style="font-family: monospace;"
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a><span
 style="font-family: monospace;">
d);</span> </td>
      <td style="vertical-align: top;">Under #define <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>. For ODBC drivers
that do not support bigint binding of host
variables natively, this operator can convert a C++ bigint numeric
value to a string value. That is, when a numeric value is being written
to the stream and the corresponding host variable has a string binding,
this operator will convert a signed 64-bit integer in C++ to a string,
which will get passed to the SQL statement, when #define&nbsp; <a
 href="otl3_compile.htm#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>, and
and #define <a href="otl3_compile.htm#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>
are defined.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">otl_stream&amp;
operator&lt;&lt;(const
      <a href="otl3_stream_class.htm#otl_null">otl_null</a>
&amp;n);</td>
      <td style="vertical-align: top;">Writes NULL into the stream.<br>
      <br>
OTL 4.0 defines a dummy class to allow NULLs to be written into
the
stream:<br>
      <br>
      <p><a style="font-family: monospace;" name="otl_null"></a>class
otl_null{<br>
public:<br>
&nbsp;&nbsp; otl_null(){}<br>
&nbsp;&nbsp; ~otl_null(){}<br>
};<span style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span></p>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const </span><a style="font-family: monospace;"
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a><span
 style="font-family: monospace;">&amp;
dt);</span> </td>
      <td style="vertical-align: top;">Writes date/time
info into the stream.<br>
      <br>
OTL defines the otl_datetime class to allow date/time
information
to written into / read from the stream:<br>
      <br>
      <p><a name="otl_datetime"></a>class
otl_datetime{<br>
public:<br>
      </p>
      <table style="text-align: left; width: 487px; height: 289px;"
 border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Data member</span><br>
            </td>
            <td style="vertical-align: top;"><span
 style="font-style: italic;">Description</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int
year; <br>
            </td>
            <td style="vertical-align: top;">year<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int
month;</td>
            <td style="vertical-align: top;">month<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int day;</td>
            <td style="vertical-align: top;">day<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int hour;</td>
            <td style="vertical-align: top;">hour<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int minute;</td>
            <td style="vertical-align: top;">minute<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int second;</td>
            <td style="vertical-align: top;">second<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">unsigned
long fraction;</td>
            <td style="vertical-align: top;">second's fractional part.
Equals 0 by default.</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">int
frac_precision;</td>
            <td style="vertical-align: top;">second's precision. Equals
0 by default</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">short int
tz_hour;<br>
            <br>
            </td>
            <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> or <br>
under #define <a href="otl3_compile.htm#OTL_ODBC_TIME_ZONE">OTL_ODBC_TIME_ZONE<br>
            </a><br>
time zone hour;<br>
            <br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">short int
tz_minute</td>
            <td style="vertical-align: top;">under #define <a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> or <br>
under #define <a href="otl3_compile.htm#OTL_ODBC_TIME_ZONE">OTL_ODBC_TIME_ZONE<br>
            <br>
            </a><a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ODBC_TIME_ZONE"></a>time
zone
minute</td>
          </tr>
        </tbody>
      </table>
      <br>
      <p><i>Fraction</i> can
be up to nine decimal
significant digits
long, depending on what the second's precision (frac_precision) is
supported
by the database (MS SQL Server 2005 down to&nbsp; milliseconds, MS SQL
Server 2008 down to 100s of a nanosecond, Sybase down
to milliseconds, DB2 down to microseconds, etc.), and what precision is
specified in the timestamp data type (Oracle 9i/10g/11g: decimal digits
in
the
range
of [1..6] digits). Fraction does not have any effect in case if the
database
supports the timestamp data type with whole seconds only.</p>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(const </span><a style="font-family: monospace;"
 href="otl3_pl_tab.htm">otl_XXX_tab</a><span
 style="font-family: monospace;">&lt;&#8230;&gt;&amp;
tab);</span> </td>
      <td style="vertical-align: top;">Reads
PL/SQL tables from the stream (OCIx) </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 style="font-family: monospace;" name="stream_write_lob"></a><span
 style="font-family: monospace;">otl_stream&amp; <br>
operator&lt;&lt;(</span><a style="font-family: monospace;"
 href="otl3_lob_stream.htm">otl_lob_stream</a><span
 style="font-family: monospace;">&amp;
lob);&nbsp;</span> </td>
      <td style="vertical-align: top;">Writes otl_lob_stream descriptor
into the otl_stream (OCI8). In other
words, initializes otl_lob_stream for writing CLOB/BLOB in stream mode.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">void
set_all_column_types<br>
(const
unsigned int amask=0);</td>
      <td style="vertical-align: top;"><a name="set_all_column_types"></a>Set
data
types of a group of
SELECT
output columns. This function can override data types of column groups:
all numeric columns to string, all date columns to string, or the
combination
of both. <i>amask </i>parameter can be set to the following values:
      <ul>
        <li>otl_all_num2str, e.g.:
set_all_column_types(otl_all_num2str);</li>
        <li>otl_all_date2str, e.g.:
set_all_column_types(otl_all_date2str);</li>
        <li>otl_all_num2str | otl_all_date2str, e.g.:
set_all_column_types(otl_all_num2str
| otl_all_date2str);</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">
      <p>&nbsp;void set_column_type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const int column_ndx,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const int col_type,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const int col_size=0);</p>
      </td>
      <td style="vertical-align: top;"><a name="set_column_type"></a>Set
a
SELECT output column
data type.
In other
words, override the default mapping of output column data types.<br>
      <br>
      <i>column_ndx</i> is the relative index of the columns in
the
query: 1,2,3...<br>
      <br>
      <i>col_type</i> is one of the <a
 href="otl3_stream_class.htm#otl_var_dbtype">data type
constants</a>,
defined by OTL.<br>
      <br>
      <i>col_size</i> is the size, associated with the new data type of
the
column. It has be to specified for the otl_var_char type only. Sizes
of
all numeric types are calculated.<br>
      <br>
This function can be called for straight SELECT statements (both
Oracle
and ODBC), referenced cursor SELECT statements (Oracle), and implicit
SELECT
statements / result sets (ODBC for MS SQL Server and Sybase).<br>
      <br>
The usability of this function is limited by the following
data type
compatibility matrix:<br>
      <br>
      <a name="mapping"></a><br>
      <table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; font-style: italic;">Database&nbsp;
data
type</td>
            <td style="vertical-align: top; font-style: italic;">Default
data
type</td>
            <td style="vertical-align: top; font-style: italic;">Data
type override</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">NUMBER (Oracle)</td>
            <td style="vertical-align: top;">otl_var_double</td>
            <td style="vertical-align: top;">otl_var_char, otl_var_int,
otl_var_float, otl_var_short,
otl_var_unsigned_int</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">NUMERIC, FLOAT, REAL,
MONEY, DECIMAL (MS SQL Server,
Sybase, DB2)</td>
            <td style="vertical-align: top;">otl_var_double</td>
            <td style="vertical-align: top;">otl_var_char, otl_var_int,
otl_var_float, otl_var_short,
otl_var_unsigned_int,
otl_var_long_int</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">INT (MS SQL Server,
Sybase, DB2)</td>
            <td style="vertical-align: top;">otl_var_int</td>
            <td style="vertical-align: top;">otl_var_char,
otl_var_double, otl_var_float, otl_var_short,
otl_var_unsigned_int,
otl_var_long_int</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">SMALLINT, TINYINT (MS SQL
Server, Sybase, DB2)</td>
            <td style="vertical-align: top;">otl_var_short</td>
            <td style="vertical-align: top;">otl_var_char, otl_var_int,
otl_var_float, otl_var_double,
otl_var_unsigned_int,
otl_var_long_int</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">DATE (Oracle), DATETIME
(MS SQL Server, Sybase)</td>
            <td style="vertical-align: top;">otl_timestamp</td>
            <td style="vertical-align: top;">otl_var_char</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">LONG (Oracle)</td>
            <td style="vertical-align: top;">otl_var_varchar_long</td>
            <td style="vertical-align: top;">otl_var_char (&lt;=32000
bytes)</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">TEXT (MS SQL Server,
Sybase)</td>
            <td style="vertical-align: top;">otl_var_varchar_long</td>
            <td style="vertical-align: top;">otl_var_char(&lt;= max.
size of varchar, e.g. &lt;=8000 in
MS SQL)</td>
          </tr>
        </tbody>
      </table>
      <br>
      <p>It is recommended that this function and data type overrides
be used with
caution.
This feature is introduced to address issues like: NUMBER is too large
to fit into the otl_var_double container and it is necessary to convert
the NUMBER into otl_var_char. Or, for small enough LONG or TEXT
columns,
sometimes it is more convenient to use the otl_var_char container. <br>
      </p>
      <blockquote> </blockquote>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">int
get_dirty_buf_len();</td>
      <td style="vertical-align: top;"><a name="get_dirty_buf_len"></a>Gets
the
stream dynamic "dirty
buffer length". For INSERT / UPDATE / DELETE statements, when the
stream buffer size is set to a value &gt; 1, the stream buffers logical
rows. When the buffer gets full, the stream automatically flushes the
buffer (executes the SQL statement, the stream is instantiated with).
If the stream buffer is not full yet, the stream buffer can be flushed
by calling <a href="otl3_stream_class.htm#flush">flush</a>().
Sometimes, it is useful to
get the actual number of rows in the stream buffer.This function
returns the actual number of rows in the stream buffer. <br>
      <br>
When the stream buffer size is set to 1, this function always returns
0, because when the stream accumulates a whole row (all the columns of
a logical row) in the buffer, the stream automatically flushes the
buffer, and the buffer gets reset right after the auto-flush.<br>
      <br>
      <a name="get_dirty_buf_len2"></a>The function also returns the
number of "dirty" (yet to be read) rows in the otl_stream buffer of a
SELECT statement / PL/SQL reference cursor, or a stored procedure that
returns an implicit result set. The number of dirty rows in the stream
buffer can be less or equal to the otl_stream buffer size.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-family: monospace;">int
get_prefetched_row_count();</td>
      <td style="vertical-align: top;"><a
 name="get_prefetched_row_count"></a>Returns the accumulative number of
prefetched [by otl_stream] rows for SELECT statements, stored
procedures that return implicit result sets, or Oracle reference
cursors. For other types of SQL statements, stored procedure calls, or
PL/SQL blocks, the function returns 0. <br>
      <br>
For example, the stream buffer is 50, and the stream fetches 50 rows in
the first batch, 50 rows in the second batch, and 23 in the third
batch. This function will return 50, 100, and 123, while the
corresponding batch is being processed.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">void skip_to_end_of_row();</span></td>
      <td style="vertical-align: top;"><a name="skip_to_end_of_row"></a>Skips
to
the end of the current row, for example:<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">while(!s.eof()){</span><br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
s&gt;&gt;f1;<br>
&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; s.skip_to_end_of_row(); <br>
      </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      <span style="font-family: monospace;">...<br>
&nbsp;&nbsp; }<br>
      </span> <br>
otl_stream
sets the internal pointers to the "end of the current row", so that the
next call to operator &gt;&gt; will fetch the first value of the next
logical row, or reach the end of the fetch sequence.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">void check_end_of_row();</span><br>
      </td>
      <td style="vertical-align: top;"> <a name="check_end_of_row"></a>Checks
the
"end-of-row"
condition. The function throws the "<a href="otl3_exc_list.htm#32035">END-OF-ROW
check
failed</a>" otl_exception if the condition is not met. The
function addresses the concern about "<a
 href="http://soci.sourceforge.net/doc/rationale.html">row-tearing</a>"
in a SELECT statement.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">otl_stream&amp; </span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">operator&gt;&gt;(otl_stream&amp;
(*pf)
(otl_stream&amp;));</span><br>
      </td>
      <td style="vertical-align: top;">This operator calls the (*pf)
stream manipulator function. The operator can be called in a chain of
operator&gt;&gt;()'s, for example:<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
s&gt;&gt;f1&gt;&gt;f2&gt;&gt;endr; // calls
check_end_of_row()</span><br>
      <br>
otl_stream
manipulator functions are global functions,&nbsp; defined in the same
namespace as the otl_stream class itself. The following
stream manipulators are available:<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">otl_stream&amp;
endr(otl_stream&amp;);
//
"end-of-row" check</span><br>
      <br>
This stream manipulator calls the otl_stream::check_end_of_row()
function.<br>
      </td>
    </tr>
  </tbody>
</table>
<p><span style="font-family: monospace;"></span></p>
<span style="font-family: monospace;"></span>
<p> </p>
<blockquote></blockquote>
<pre><font size="+2">}; // end of otl_stream</font></pre>
<center>
<hr width="100%">
<p><a href="otl3_class.htm">Prev</a> <a href="otl3_bind_variables.htm">Next</a><a
 href="otl3.htm">Contents</a><a href="home.htm">Go
Home</a></p>
</center>
<p>Copyright &copy; 1996-2009, Sergei Kuchin, email: <a
 href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com
<script language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </script></a>.
</p>
<p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE
AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.</i>
</p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
pageTracker._trackPageview();
</script>
</body>
</html>
